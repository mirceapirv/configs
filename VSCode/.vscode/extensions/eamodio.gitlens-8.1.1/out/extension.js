module.exports=function(e){var t={};function i(s){if(t[s])return t[s].exports;var o=t[s]={i:s,l:!1,exports:{}};return e[s].call(o.exports,o,o.exports,i),o.l=!0,o.exports}return i.m=e,i.c=t,i.d=function(e,t,s){i.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:s})},i.r=function(e){Object.defineProperty(e,"__esModule",{value:!0})},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="",i.oe=function(e){process.nextTick(function(){throw e})},i.w={},i(i.s=9)}([function(e,t){e.exports=require("vscode")},function(e,t){e.exports=require("path")},function(e,t){e.exports=require("fs")},function(e,t){e.exports=require("tslib")},function(e,t){e.exports=require("iconv-lite")},function(e,t){e.exports=require("crypto")},function(e,t){e.exports=require("date-fns")},function(e,t){e.exports=require("child_process")},function(e,t){e.exports=require("date-fns/locale/en")},function(e,t,i){"use strict";var s,o;i.r(t),function(e){e.entries=function*(e){for(const t in e)yield[t,e[t]]},e.flatten=function(e,t="",i=!1){const s=Object.create(null);return function e(t,i,s,o=!1){if(Object(s)!==s)t[i]=o?null==s?null:"string"==typeof s?s:JSON.stringify(s):s;else if(Array.isArray(s)){const a=s.length;for(let r=0;r<a;r++)e(t,`${i}[${r}]`,s[r],o);0===a&&(t[i]=null)}else{let a=!0;for(const r in s)a=!1,e(t,i?`${i}.${r}`:r,s[r],o);a&&i&&(t[i]=null)}}(s,t,e,i),s},e.paths=function e(t,i){const s=[];for(const o in t){const a=t[o];"object"==typeof a?s.push(...e(a,void 0===i?o:`${i}.${o}`)):s.push(void 0===i?o:`${i}.${o}`)}return s},e.values=function*(e){for(const t in e)yield e[t]}}(s||(s={})),function(e){function t(e,i,o=!0){if(void 0===e.children)return e;const a=[...s.values(e.children)];for(const e of a)t(e,i,!1);if(!o&&1===a.length){const t=a[0];void 0===t.value&&(e.name=i(e.name,t.name),e.relativePath=t.relativePath,e.children=t.children)}return e}e.countUniques=function(e,t){const i=Object.create(null);for(const s of e){const e=t(s);i[e]=(i[e]||0)+1}return i},e.filterMap=function(e,t){return e.reduce((e,i)=>{const s=t(i);return null!=s&&e.push(s),e},[])},e.filterMapAsync=async function(e,t){return e.reduce(async(e,i)=>{const s=await t(i);return null!=s&&e.push(s),e},[])},e.groupBy=function(e,t){return e.reduce((e,i)=>{const s=t(i);return e[s]=e[s]||[],e[s].push(i),e},Object.create(null))},e.makeHierarchical=function(e,i,s,o=!1){const a={name:"",relativePath:"",children:Object.create(null),descendants:[]},r=e.reduce((e,t)=>{let o=e,a="";for(const e of i(t)){a=s(a,e),void 0===o.children&&(o.children=Object.create(null));let i=o.children[e];void 0===i&&(o.children[e]=i={name:e,relativePath:a,children:void 0,descendants:void 0}),void 0===o.descendants&&(o.descendants=[]),o.descendants.push(t),o=i}return o.value=t,e},a);return o?t(r,s,!0):r},e.compactHierarchy=t,e.uniqueBy=function(e,t,i){const s=Object.create(null);return e.filter(e=>{const o=t(e);return!s[o]&&(s[o]=t,!i||i(e))})}}(o||(o={}));var a=i(6);const r=i(8);r.distanceInWords=function(){const e={lessThanXSeconds:{one:"less than a second",other:"less than {{count}} seconds"},xSeconds:{one:"1 second",other:"{{count}} seconds"},halfAMinute:"half a minute",lessThanXMinutes:{one:"a few seconds",other:"less than {{count}} minutes"},xMinutes:{one:"a minute",other:"{{count}} minutes"},aboutXHours:{one:"an hour",other:"{{count}} hours"},xHours:{one:"an hour",other:"{{count}} hours"},xDays:{one:"a day",other:"{{count}} days"},aboutXMonths:{one:"a month",other:"{{count}} months"},xMonths:{one:"a month",other:"{{count}} months"},aboutXYears:{one:"a year",other:"{{count}} years"},xYears:{one:"a year",other:"{{count}} years"},overXYears:{one:"a year",other:"{{count}} years"},almostXYears:{one:"a year",other:"{{count}} years"}};return{localize:function(t,i,s){s=s||{},12===i&&"xMonths"===t&&(t="aboutXYears",i=1);const o=e[t];let a;return a="string"==typeof o?o:1===i?o.one:o.other.replace("{{count}}",i.toString()),s.addSuffix?s.comparison>0?"in "+a:a+" ago":a}}}();const n={addSuffix:!0,locale:r};var h;!function(e){function t(e){const t=new Date("number"==typeof e?e:e.getTime());return t.setHours(0,0,0,0),t}e.dateDaysFromNow=function(e,i=Date.now()){const s=t(i),o=t(e),a=s.getTime()-6e4*s.getTimezoneOffset(),r=o.getTime()-6e4*o.getTimezoneOffset();return Math.round((a-r)/864e5)},e.startOfDay=t,e.toFormatter=function(e){return{fromNow:()=>Object(a.distanceInWordsToNow)(e,n),format:t=>Object(a.format)(e,t)}}}(h||(h={}));var c=i(3);const l=i(11),d=i(10);var m,u;!function(e){async function t(e){await new Promise(t=>setTimeout(t,e))}e.debounce=function(e,t,i){const s=Object.assign({track:!1},i||{}),{track:o}=s,a=c.__rest(s,["track"]);if(!0!==o)return l(e,t,a);let r=!1;const n=l(function(){return r=!1,e.apply(this,arguments)},t,i),h=function(){return r=!0,n.apply(this,arguments)};return h.pending=function(){return r},h.cancel=function(){return n.cancel.apply(n,arguments)},h.flush=function(...e){return n.flush.apply(n,arguments)},h},e.once=function(e){return d(e)},e.propOf=function(e,t){const i=(e,t)=>{const s=void 0===i.value?t:`${i.value}.${t}`;return i.value=s,Object.assign(s=>i(e[t],s),{value:s})};return i(e,t)},e.seeded=function(e,t){let i=t;return(...t)=>{if(void 0!==i){const e=Promise.resolve(i);return i=void 0,e}return e(...t)}},e.wait=t,e.waitUntil=async function(e,i){const s=Math.round(i/100);let o=0;for(;;){if(e())return!0;if(o>s)return!1;await t(100),o++}}}(m||(m={})),function(e){function t(e,t){for(const i of e)if(t(i))return!0;return!1}e.count=function(e){let t,i=0;for(;!(t=e.next()).done;)i++;return i},e.every=function(e,t){for(const i of e)if(!t(i))return!1;return!0},e.filter=function*(e,t){if(void 0===t)for(const t of e)null!=t&&(yield t);else for(const i of e)t(i)&&(yield i)},e.filterMap=function*(e,t){for(const i of e){const e=t(i);null!=e&&(yield e)}},e.forEach=function(e,t){let i=0;for(const s of e)t(s,i),i++},e.find=function(e,t){for(const i of e)if(t(i))return i;return null},e.first=function(e){return e[Symbol.iterator]().next().value},e.flatMap=function*(e,t){for(const i of e)yield*t(i)},e.has=function(e,i){return t(e,e=>e===i)},e.isIterable=function(e){return"function"==typeof e[Symbol.iterator]},e.join=function(e,t){let i="";const s=e[Symbol.iterator]();let o=s.next();if(o.done)return i;for(;;){const e=o.value.toString();if((o=s.next()).done){i+=e;break}i+=`${e}${t}`}return i},e.last=function(e){let t=null;for(t of e);return t},e.map=function*(e,t){for(const i of e)yield t(i)},e.next=function(e){return e.next().value},e.skip=function*(e,t){let i=0;for(const s of e)i>=t&&(yield s),i++},e.some=t,e.take=function*(e,t){if(t>0){let i=0;for(const s of e)if(yield s,++i>=t)break}},e.union=function*(...e){for(const t of e)for(const e of t)yield e}}(u||(u={}));class g{constructor(){this._value="",this._pos=0}reset(e){return this._value=e,this._pos=0,this}next(){return this._pos+=1,this}join(e){return e.join("")}hasNext(){return this._pos<this._value.length-1}cmp(e){return e.charCodeAt(0)-this._value.charCodeAt(this._pos)}value(){return this._value[this._pos]}}class p{reset(e){return this._value=e.replace(/\\$|\/$/,""),this._from=0,this._to=0,this.next()}hasNext(){return this._to<this._value.length}join(e){return e.join("/")}next(){this._from=this._to;let e=!0;for(;this._to<this._value.length;this._to++){const t=this._value.charCodeAt(this._to);if(t===p._fwd||t===p._bwd){if(!e)break;this._from++}else e=!1}return this}cmp(e){let t=0;const i=e.length;let s=this._from;for(;t<i&&s<this._to;){const i=e.charCodeAt(t)-this._value.charCodeAt(s);if(0!==i)return i;t+=1,s+=1}return i===this._to-this._from?0:t<i?-1:1}value(){return this._value.substring(this._from,this._to)}}p._fwd="/".charCodeAt(0),p._bwd="\\".charCodeAt(0);class f{isEmpty(){return void 0===this.left&&void 0===this.mid&&void 0===this.right&&void 0===this.element}}class v{constructor(e){this._iter=e}static forPaths(){return new v(new p)}static forStrings(){return new v(new g)}clear(){this._root=void 0}set(e,t){const i=this._iter.reset(e);let s;for(this._root||(this._root=new f,this._root.str=i.value()),s=this._root;;){const e=i.cmp(s.str);if(e>0)s.left||(s.left=new f,s.left.str=i.value()),s=s.left;else if(e<0)s.right||(s.right=new f,s.right.str=i.value()),s=s.right;else{if(!i.hasNext())break;i.next(),s.mid||(s.mid=new f,s.mid.str=i.value()),s=s.mid}}const o=s.element;return s.element=t,o}get(e){const t=this._iter.reset(e);let i=this._root;for(;i;){const e=t.cmp(i.str);if(e>0)i=i.left;else if(e<0)i=i.right;else{if(!t.hasNext())break;t.next(),i=i.mid}}return i?i.element:void 0}delete(e){const t=this._iter.reset(e),i=[];let s=this._root;for(;s;){const e=t.cmp(s.str);if(e>0)i.push([1,s]),s=s.left;else if(e<0)i.push([-1,s]),s=s.right;else{if(!t.hasNext()){for(s.element=void 0;i.length>0&&s.isEmpty();){const[e,t]=i.pop();switch(e){case 1:t.left=void 0;break;case 0:t.mid=void 0;break;case-1:t.right=void 0}s=t}break}t.next(),i.push([0,s]),s=s.mid}}}findSubstr(e){const t=this._iter.reset(e);let i,s=this._root;for(;s;){const e=t.cmp(s.str);if(e>0)s=s.left;else if(e<0)s=s.right;else{if(!t.hasNext())break;t.next(),i=s.element||i,s=s.mid}}return s&&s.element||i}findSuperstr(e){const t=this._iter.reset(e);let i=this._root;for(;i;){const e=t.cmp(i.str);if(e>0)i=i.left;else if(e<0)i=i.right;else{if(!t.hasNext()){if(!i.mid)return;const e=new v(this._iter);return e._root=i.mid,e}t.next(),i=i.mid}}}forEach(e){this._forEach(this._root,[],e)}_forEach(e,t,i){void 0!==e&&(this._forEach(e.left,t,i),t.push(e.str),e.element&&i(e.element,this._iter.join(t)),this._forEach(e.mid,t,i),t.pop(),this._forEach(e.right,t,i))}any(){return void 0!==this._root&&!this._root.isEmpty()}count(){return void 0===this._root||this._root.isEmpty()?0:u.count(this.entries())}entries(){return this._iterator(this._root,[])}values(){return u.map(this.entries(),e=>e[0])}highlander(){if(void 0===this._root||this._root.isEmpty())return;const e=this.entries();let t,i,s=0;for(;!(t=e.next()).done;)if(i=t.value,++s>1)return;return i}*_iterator(e,t){void 0!==e&&(yield*this._iterator(e.left,t),t.push(e.str),e.element&&(yield[e.element,this._iter.join(t)]),yield*this._iterator(e.mid,t),t.pop(),yield*this._iterator(e.right,t))}}var w,C,b=i(5);!function(e){const t=/\$\{([^|]*?)(?:\|(\d+)(\-|\?)?)?\}/g,i=/\$\{(\w*?)(?:\W|\d)*?\}/g;function s(e,t,i=" "){const s=t-h(e);return s<=0?e:i.repeat(s)+e}function o(e,t,i=" "){const s=t-h(e);return s<=0?e:e+i.repeat(s)}e.getTokensFromTemplate=function(e){const i=[];let s=t.exec(e);for(;null!=s;){const o=s[2],a=s[3];i.push({key:s[1],options:{truncateTo:null==o?void 0:parseInt(o,10),padDirection:"-"===a?"left":"right",collapseWhitespace:"?"===a}}),s=t.exec(e)}return i},e.interpolate=function(e,t){return e?void 0===t?e.replace(i,""):(e=e.replace(i,"$${this.$1}"),new Function(`return \`${e}\`;`).call(t)):e},e.lines=function*(e){let t=0;for(;t<e.length;){let i=e.indexOf("\n",t);-1===i&&(i=e.length),yield e.substring(t,i),t=i+1}},e.md5=function(e,t="base64"){return Object(b.createHash)("md5").update(e).digest(t)},e.normalizePath=function(e){return e&&e.replace(/\\/g,"/")},e.pad=function(e,t=0,i=0,s=" "){return 0===t&&0===i?e:`${0===t?"":s.repeat(t)}${e}${0===i?"":s.repeat(i)}`},e.padLeft=s,e.padLeftOrTruncate=function(e,t,i){const o=h(e);return o<t?s(e,t,i):o>t?r(e,t):e},e.padRight=o,e.padOrTruncate=function(e,t,i){const a=t<0;t=Math.abs(t);const n=h(e);return n<t?a?s(e,t,i):o(e,t,i):n>t?r(e,t):e},e.padRightOrTruncate=function(e,t,i){const s=h(e);return s<t?o(e,t,i):s>t?r(e,t):e};const a=/[\\/:*?"<>|\x00-\x1f\x80-\x9f]/g;function r(e,t,i="…"){if(!e)return e;const s=h(e);if(s<=t)return e;if(s===e.length)return`${e.substring(0,t-1)}${i}`;let o=Math.floor(t/(s/e.length)),a=h(e.substring(0,o));for(;a<t;)a+=h(e[o++]);return a>=t&&o--,`${e.substring(0,o)}${i}`}e.sanitizeForFileSystem=function(e,t="_"){return e?e.replace(a,t):e},e.sha1=function(e,t="base64"){return Object(b.createHash)("sha1").update(e).digest(t)},e.truncate=r;const n=/[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[a-zA-Z\\d]*)*)?\\u0007)|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))/g;function h(e){if(!e||0===e.length)return 0;let t=0,i=0,s=0;const o=[...e=e.replace(n,"")];for(let e=0;e<o.length;e++){const a=o[e].codePointAt(0);if(!(a<=31||a>=127&&a<=159||a>=768&&a<=879))if(a>=128512&&a<=128591||a>=127744&&a<=128511||a>=128640&&a<=128767||a>=9728&&a<=9983||a>=9984&&a<=10175||a>=65024&&a<=65039||a>=129280&&a<=129535||a>=65024&&a<=65039||a>=8400&&a<=8447){if(a>=127995&&a<=127999)continue;i++,t+=2}else 8205!==a?(a>65535&&e++,t+=c(a)?2:1):(s++,t-=2)}const a=i-s;return a>1&&(t+=a-1),t}function c(e){return e>=4352&&(e<=4447||9001===e||9002===e||11904<=e&&e<=12871&&12351!==e||12880<=e&&e<=19903||19968<=e&&e<=42182||43360<=e&&e<=43388||44032<=e&&e<=55203||63744<=e&&e<=64255||65040<=e&&e<=65049||65072<=e&&e<=65131||65281<=e&&e<=65376||65504<=e&&e<=65510||110592<=e&&e<=110593||127488<=e&&e<=127569||131072<=e&&e<=262141)}e.width=h}(w||(w={})),function(e){function t(e,t,i,s){return{major:"string"==typeof e?parseInt(e,10):e,minor:"string"==typeof t?parseInt(t,10):t,patch:"string"==typeof i?parseInt(i,10):i,pre:s}}e.compare=function(e,t){return e.major>t.major?1:e.major<t.major?-1:e.minor>t.minor?1:e.minor<t.minor?-1:e.patch>t.patch?1:e.patch<t.patch?-1:void 0===e.pre&&void 0!==t.pre?1:void 0!==e.pre&&void 0===t.pre?-1:void 0!==e.pre&&void 0!==t.pre?e.pre.localeCompare(t.pre):0},e.from=t,e.fromString=function(e){const[i,s]=e.split("-"),[o,a,r]=i.split(".");return t(o,a,r,s)}}(C||(C={}));var y,x,S,$,D,F,k,P,_,R,T,E,B,A,N=i(0);!function(e){e.File="file",e.Window="window"}(y||(y={})),function(e){e.DiffWithPrevious="gitlens.diffWithPrevious",e.ShowQuickCommitDetails="gitlens.showQuickCommitDetails",e.ShowQuickCommitFileDetails="gitlens.showQuickCommitFileDetails",e.ShowQuickCurrentBranchHistory="gitlens.showQuickRepoHistory",e.ShowQuickFileHistory="gitlens.showQuickFileHistory",e.ToggleFileBlame="gitlens.toggleFileBlame"}(x||(x={})),function(e){e.Document="document",e.Containers="containers",e.Blocks="blocks"}(S||(S={})),function(e){e.Bitbucket="Bitbucket",e.BitbucketServer="BitbucketServer",e.Custom="Custom",e.GitHub="GitHub",e.GitLab="GitLab"}($||($={})),function(e){e.Absolute="absolute",e.Relative="relative"}(D||(D={})),function(e){e.List="list",e.Tree="tree"}(F||(F={})),function(e){e.Auto="auto",e.List="list",e.Tree="tree"}(k||(k={})),function(e){e.Blame="blame",e.Heatmap="heatmap",e.RecentChanges="recentChanges"}(P||(P={})),function(e){e.Auto="auto",e.History="history",e.Repository="repository"}(_||(_={})),function(e){e.Faces="wavatar",e.Geometric="identicon",e.Monster="monsterid",e.MysteryMan="mm",e.Retro="retro",e.Robot="robohash"}(R||(R={})),function(e){e.Gutter="gutter",e.Line="line",e.Overview="overview"}(T||(T={})),function(e){e.Alternate="alternate",e.Chorded="chorded",e.None="none"}(E||(E={})),function(e){e.Silent="silent",e.Errors="errors",e.Verbose="verbose",e.Debug="debug"}(B||(B={})),function(e){e.DiffWithPrevious="gitlens.diffWithPrevious",e.DiffWithWorking="gitlens.diffWithWorking",e.ShowQuickCommitDetails="gitlens.showQuickCommitDetails",e.ShowQuickCommitFileDetails="gitlens.showQuickCommitFileDetails",e.ShowQuickCurrentBranchHistory="gitlens.showQuickRepoHistory",e.ShowQuickFileHistory="gitlens.showQuickFileHistory",e.ToggleCodeLens="gitlens.toggleCodeLens",e.ToggleFileBlame="gitlens.toggleFileBlame"}(A||(A={}));const U="gitlens",L="GitLens",O="GitLens",I="eamodio.gitlens",M=1e8;var W,H,j,G,V,Q,K,q,z,Y,X;function J(e,t){return N.commands.executeCommand(W.SetContext,e,t)}function Z(e){const t=N.window.activeTextEditor;return void 0!==t&&t.document===e}function ee(e){const t=e.document.uri.scheme;return t!==V.Output&&t!==V.DebugConsole}(H=W||(W={})).CloseActiveEditor="workbench.action.closeActiveEditor",H.CloseAllEditors="workbench.action.closeAllEditors",H.CursorMove="cursorMove",H.Diff="vscode.diff",H.EditorScroll="editorScroll",H.ExecuteDocumentSymbolProvider="vscode.executeDocumentSymbolProvider",H.ExecuteCodeLensProvider="vscode.executeCodeLensProvider",H.Open="vscode.open",H.NextEditor="workbench.action.nextEditor",H.PreviewHtml="vscode.previewHtml",H.RevealLine="revealLine",H.SetContext="setContext",H.ShowReferences="editor.action.showReferences",(G=j||(j={})).ActiveHasRemote="gitlens:activeHasRemote",G.ActiveIsBlameable="gitlens:activeIsBlameable",G.ActiveFileIsTracked="gitlens:activeIsTracked",G.ActiveIsRevision="gitlens:activeIsRevision",G.AnnotationStatus="gitlens:annotationStatus",G.CanToggleCodeLens="gitlens:canToggleCodeLens",G.Enabled="gitlens:enabled",G.ExplorersCanCompare="gitlens:explorers:canCompare",G.GitExplorer="gitlens:gitExplorer",G.GitExplorerAutoRefresh="gitlens:gitExplorer:autoRefresh",G.GitExplorerView="gitlens:gitExplorer:view",G.HasRemotes="gitlens:hasRemotes",G.Key="gitlens:key",G.KeyMap="gitlens:keymap",G.ResultsExplorer="gitlens:resultsExplorer",G.ResultsExplorerKeepResults="gitlens:resultsExplorer:keepResults",(Q=V||(V={})).DebugConsole="debug",Q.File="file",Q.Git="git",Q.GitLensGit="gitlens-git",Q.Output="output",(q=K||(K={})).ArrowBack="↩",q.ArrowDown="↓",q.ArrowDropRight="⤷",q.ArrowLeft="←",q.ArrowLeftRight="↔",q.ArrowRight="→",q.ArrowRightHollow="⇨",q.ArrowUp="↑",q.ArrowUpRight="↗",q.Asterisk="∗",q.Check="✓",q.Dash="—",q.Dot="•",q.DoubleArrowLeft="≪",q.DoubleArrowRight="⋘",q.Ellipsis="…",q.MiddleEllipsis="⋯",q.Pensil="✎",q.Space=" ",q.SquareWithBottomShadow="❏",q.SquareWithTopShadow="❐",q.ZeroWidthSpace="​",(z||(z={})).GitLensVersion="gitlensVersion",(X=Y||(Y={})).GitExplorerAutoRefresh="gitlens:gitExplorer:autoRefresh",X.GitExplorerView="gitlens:gitExplorer:view",X.ResultsExplorerKeepResults="gitlens:resultsExplorer:keepResults";class te{}const ie=new class extends te{equals(e,t){return e===t}},se=new class extends te{equals(e,t,i={useId:!1,usePosition:!1}){return e===t||void 0!==e&&void 0!==t&&(!i.usePosition||e.viewColumn===t.viewColumn)&&(!i.useId||e.document&&t.document?ie.equals(e.document,t.document):e.id===t.id)}},oe=new class extends te{equals(e,t){return e===t||void 0!==e&&void 0!==t&&e.scheme===t.scheme&&e.fsPath===t.fsPath}};var ae,re;(re=ae||(ae={})).Computing="computing",re.Computed="computed";class ne extends N.Disposable{constructor(e,t,i,s){super(()=>this.dispose()),this.editor=e,this.trackedDocument=t,this.decoration=i,this.highlightDecoration=s,this.correlationKey=ne.getCorrelationKey(this.editor),this.document=this.editor.document,this.disposable=N.Disposable.from(N.window.onDidChangeTextEditorSelection(this.onTextEditorSelectionChanged,this))}static getCorrelationKey(e){return void 0!==e?e.id:""}async dispose(){await this.clear(),this.disposable&&this.disposable.dispose()}async onTextEditorSelectionChanged(e){if(ie.equals(this.document,e.textEditor&&e.textEditor.document))return this.selection(e.selections[0].active.line)}get editorId(){return void 0===this.editor||void 0===this.editor.document?"":this.editor.id}get editorUri(){if(void 0!==this.editor&&void 0!==this.editor.document)return this.editor.document.uri}async clear(){if(this.status=void 0,void 0!==this.editor){if(void 0!==this.decoration)try{this.editor.setDecorations(this.decoration,[])}catch(e){}if(void 0!==this.additionalDecorations&&this.additionalDecorations.length>0){for(const e of this.additionalDecorations)try{this.editor.setDecorations(e.decoration,[])}catch(e){}this.additionalDecorations=void 0}if(void 0!==this.highlightDecoration)try{this.editor.setDecorations(this.highlightDecoration,[])}catch(e){}}}async reset(e){void 0===this._resetDebounced&&(this._resetDebounced=m.debounce(this.onReset,250)),this._resetDebounced(e)}async onReset(e){void 0!==e&&(await this.clear(),this.decoration=e.decoration,this.highlightDecoration=e.highlightDecoration),await this.provideAnnotation(void 0===this.editor?void 0:this.editor.selection.active.line)}async restore(e){if(!1!==this.editor._disposed){if(this.status=ae.Computing,e===N.window.activeTextEditor&&await J(j.AnnotationStatus,this.status),this.editor=e,this.correlationKey=ne.getCorrelationKey(e),this.document=e.document,void 0!==this.decorations&&this.decorations.length&&(this.editor.setDecorations(this.decoration,this.decorations),void 0!==this.additionalDecorations&&this.additionalDecorations.length))for(const e of this.additionalDecorations)this.editor.setDecorations(e.decoration,e.ranges);this.status=ae.Computed,e===N.window.activeTextEditor&&(await J(j.AnnotationStatus,this.status),await this.selection(e.selection.active.line))}}async provideAnnotation(e){return this.status=ae.Computing,await this.onProvideAnnotation(e)?(this.status=ae.Computed,!0):(this.status=void 0,!1)}}const he=`[${L}]`;class ce{static configure(e){e.subscriptions.push(ua.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(ua.initializingChangeEvent)}static onConfigurationChanged(e){const t=ua.initializing(e);let i=ua.name("debug").value;(t||ua.changed(e,i))&&(this.debug=ua.get(i)),i=ua.name("outputLevel").value,(t||ua.changed(e,i))&&(this.level=ua.get(i),this.level===B.Silent?void 0!==this.output&&(this.output.dispose(),this.output=void 0):this.output=this.output||N.window.createOutputChannel(L))}static log(e,...t){this.debug&&console.log(this.timestamp,he,e,...t),void 0===this.output||this.level!==B.Verbose&&this.level!==B.Debug||this.output.appendLine((this.debug?[this.timestamp,e,...t]:[e,...t]).join(" "))}static error(e,t,...i){this.debug&&console.error(this.timestamp,he,t,e,...i),void 0!==this.output&&this.level!==B.Silent&&this.output.appendLine((this.debug?[this.timestamp,t,e,...i]:[t,e,...i]).join(" "))}static warn(e,...t){this.debug&&console.warn(this.timestamp,he,e,...t),void 0!==this.output&&this.level!==B.Silent&&this.output.appendLine((this.debug?[this.timestamp,e,...t]:[e,...t]).join(" "))}static get timestamp(){const e=new Date;return`[${e.toISOString().replace(/T/," ").replace(/\..+/,"")}:${("00"+e.getUTCMilliseconds()).slice(-3)}]`}static logGitCommand(e,t){this.level===B.Debug&&(void 0===this.gitOutput&&(this.gitOutput=N.window.createOutputChannel(`${L} (Git)`)),this.gitOutput.appendLine(`${this.timestamp} ${e} (${t})`))}}ce.debug=!1,ce.level=B.Silent;class le extends N.Disposable{constructor(e,t,i,s){super(()=>this.dispose()),this._document=e,this.key=t,this.dirty=i,this._eventDelegates=s,this._onDidBlameStateChange=new N.EventEmitter,this._disposed=!1,this._forceDirtyStateChangeOnNextDocumentChange=!1,this._hasRemotes=!1,this._isDirtyIdle=!1,this._isTracked=!1,this._blameFailed=!1,this._repo=this.initialize(e.uri)}get onDidBlameStateChange(){return this._onDidBlameStateChange.event}dispose(){this._disposed=!0,this.reset("dispose"),this._disposable&&this._disposable.dispose()}async initialize(e){if(void 0===la.git&&!await m.waitUntil(()=>void 0!==la.git,2e3))throw ce.log(`TrackedDocument.initialize(${e.toString()})`,"Timed out waiting for the GitService to start"),new Error("TrackedDocument timed out waiting for the GitService to start");if(this._uri=await je.fromUri(e),this._disposed)return;const t=await la.git.getRepository(this._uri);return this._disposed?void 0:(void 0!==t&&(this._disposable=t.onDidChange(this.onRepositoryChanged,this)),await this.update({initializing:!0,repo:t}),t)}onRepositoryChanged(e){e.changed(ot.Repository)&&(this.reset("repository"),this.update())}get forceDirtyStateChangeOnNextDocumentChange(){return this._forceDirtyStateChangeOnNextDocumentChange}get hasRemotes(){return this._hasRemotes}get isBlameable(){return!this._blameFailed&&this._isTracked}get isDirtyIdle(){return this._isDirtyIdle}set isDirtyIdle(e){this._isDirtyIdle=e}get isRevision(){return void 0!==this._uri&&!!this._uri.sha}get isTracked(){return this._isTracked}get lineCount(){return this._document.lineCount}get uri(){return this._uri}activate(){J(j.ActiveIsRevision,this.isRevision),J(j.ActiveFileIsTracked,this.isTracked),J(j.ActiveIsBlameable,this.isBlameable),J(j.ActiveHasRemote,this.hasRemotes)}async ensureInitialized(){await this._repo}is(e){return e===this._document}reset(e){this._blameFailed=!1,this._isDirtyIdle=!1,void 0!==this.state&&(this.state=void 0,ce.log(`Reset state for '${this.key}', reason=${e}`))}setBlameFailure(){const e=this.isBlameable;this._blameFailed=!0,e&&Z(this._document)&&this.update({forceBlameChange:!0})}resetForceDirtyStateChangeOnNextDocumentChange(){this._forceDirtyStateChangeOnNextDocumentChange=!1}setForceDirtyStateChangeOnNextDocumentChange(){this._forceDirtyStateChangeOnNextDocumentChange=!0}async update(e={}){if(this._disposed||void 0===this._uri)return this._hasRemotes=!1,void(this._isTracked=!1);this._isDirtyIdle=!1;const t=function(e){const t=N.window.activeTextEditor;return void 0!==t&&t.document===e?t:void 0}(this._document),i=e.forceBlameChange?void 0:this.isBlameable;this._isTracked=await la.git.isTracked(this._uri);let s=void 0;if(this._isTracked&&void 0===(s=e.repo)&&(s=await this._repo),this._hasRemotes=void 0!==s&&await s.hasRemote(),void 0!==t){const s=this.isBlameable;if(J(j.ActiveIsRevision,this.isRevision),J(j.ActiveFileIsTracked,this.isTracked),J(j.ActiveIsBlameable,s),J(j.ActiveHasRemote,this.hasRemotes),!e.initializing&&i!==s){const e={editor:t,document:this,blameable:s};this._onDidBlameStateChange.fire(e),this._eventDelegates.onDidBlameStateChange(e)}}}}class de{constructor(e){this.key=e,this.cache=new Map}get(e){return this.cache.get(e)}set(e,t){this.cache.set(e,t)}}class me{constructor(e,t){this.commit=e,this.logCommit=t}}class ue extends N.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeBlameState=new N.EventEmitter,this._onDidChangeDirtyState=new N.EventEmitter,this._onDidTriggerDirtyIdle=new N.EventEmitter,this._documentMap=new Map,this._disposable=N.Disposable.from(ua.onDidChange(this.onConfigurationChanged,this),N.window.onDidChangeActiveTextEditor(m.debounce(this.onActiveTextEditorChanged,0),this),N.workspace.onDidChangeTextDocument(m.debounce(this.onTextDocumentChanged,50),this),N.workspace.onDidCloseTextDocument(this.onTextDocumentClosed,this),N.workspace.onDidSaveTextDocument(this.onTextDocumentSaved,this)),this.onConfigurationChanged(ua.initializingChangeEvent)}get onDidChangeBlameState(){return this._onDidChangeBlameState.event}get onDidChangeDirtyState(){return this._onDidChangeDirtyState.event}get onDidTriggerDirtyIdle(){return this._onDidTriggerDirtyIdle.event}dispose(){this._disposable&&this._disposable.dispose(),this.clear()}initialize(){this.onActiveTextEditorChanged(N.window.activeTextEditor)}onConfigurationChanged(e){const t=ua.initializing(e);if(!t&&(ua.changed(e,ua.name("blame")("ignoreWhitespace").value,null)||ua.changed(e,ua.name("advanced")("caching")("enabled").value)))for(const e of this._documentMap.values())e.reset("config");const i=ua.name("advanced")("blame")("delayAfterEdit").value;(t||ua.changed(e,i))&&(this._dirtyIdleTriggerDelay=ua.get(i),this._dirtyIdleTriggeredDebounced=void 0)}onActiveTextEditorChanged(e){if(void 0!==e&&!ee(e))return;if(void 0===e)return J(j.ActiveIsRevision,!1),J(j.ActiveFileIsTracked,!1),J(j.ActiveIsBlameable,!1),void J(j.ActiveHasRemote,!1);const t=this._documentMap.get(e.document);void 0===t?this.addCore(e.document):t.activate()}onTextDocumentChanged(e){if(e.document.uri.scheme!==V.File)return;let t=this._documentMap.get(e.document);void 0===t&&(t=this.addCore(e.document)),t.reset("document");const i=e.document.isDirty,s=N.window.activeTextEditor;void 0!==this._dirtyIdleTriggeredDebounced&&(i?this._dirtyIdleTriggeredDebounced({editor:s,document:t}):this._dirtyIdleTriggeredDebounced.cancel()),(t.forceDirtyStateChangeOnNextDocumentChange||t.dirty!==i)&&(t.resetForceDirtyStateChangeOnNextDocumentChange(),t.dirty=i,void 0!==s&&s.document===e.document&&this.fireDocumentDirtyStateChanged({editor:s,document:t,dirty:t.dirty}))}onTextDocumentClosed(e){const t=this._documentMap.get(e);void 0!==t&&(t.dispose(),this._documentMap.delete(e),this._documentMap.delete(t.key))}onTextDocumentSaved(e){let t=this._documentMap.get(e);void 0===t?Z(e)&&(t=this.addCore(e)):t.update({forceBlameChange:!0})}add(e){return this._add(e)}clear(){for(const e of this._documentMap.values())e.dispose();this._documentMap.clear()}get(e){return this._get(e)}async getOrAdd(e){let t=await this._get(e);return void 0===t&&(t=await this._add(e)),t}has(e){return("string"==typeof e||e instanceof N.Uri)&&(e=je.toKey(e)),this._documentMap.has(e)}async _add(e){if(e instanceof je)try{e=await N.workspace.openTextDocument(e.fileUri({useVersionedPath:!0}))}catch(t){if(!t.toString().includes("File not found"))throw t;e=new ge(e)}else e instanceof N.Uri&&(e=await N.workspace.openTextDocument(e));const t=await this.addCore(e);return await t.ensureInitialized(),t}async _get(e){e instanceof je?e=je.toKey(e.fileUri({useVersionedPath:!0})):("string"==typeof e||e instanceof N.Uri)&&(e=je.toKey(e));const t=this._documentMap.get(e);if(void 0!==t)return await t.ensureInitialized(),t}addCore(e){const t=je.toKey(e.uri),i=new le(e,t,!1,{onDidBlameStateChange:e=>this._onDidChangeBlameState.fire(e)});return this._documentMap.set(e,i),this._documentMap.set(t,i),i}fireDocumentDirtyStateChanged(e){if(e.dirty)return setImmediate(async()=>{void 0!==this._dirtyStateChangedDebounced&&this._dirtyStateChangedDebounced.cancel(),N.window.activeTextEditor===e.editor&&(await e.document.ensureInitialized(),this._onDidChangeDirtyState.fire(e))}),void(this._dirtyIdleTriggerDelay>0&&(void 0===this._dirtyIdleTriggeredDebounced&&(this._dirtyIdleTriggeredDebounced=m.debounce(async e=>{void 0!==this._dirtyIdleTriggeredDebounced&&this._dirtyIdleTriggeredDebounced.pending()||(await e.document.ensureInitialized(),e.document.isDirtyIdle=!0,this._onDidTriggerDirtyIdle.fire(e))},this._dirtyIdleTriggerDelay,{track:!0})),this._dirtyIdleTriggeredDebounced({editor:e.editor,document:e.document})));void 0===this._dirtyStateChangedDebounced&&(this._dirtyStateChangedDebounced=m.debounce(async e=>{N.window.activeTextEditor===e.editor&&(await e.document.ensureInitialized(),this._onDidChangeDirtyState.fire(e))},250)),this._dirtyStateChangedDebounced(e)}}class ge{constructor(e){this.gitUri=e,this.uri=e.fileUri({useVersionedPath:!0}),this.eol=N.EndOfLine.LF,this.fileName=this.uri.fsPath,this.isClosed=!1,this.isDirty=!1,this.isUntitled=!1,this.languageId="",this.lineCount=0,this.version=0}getText(e){throw new Error("Method not supported.")}getWordRangeAtPosition(e,t){throw new Error("Method not supported.")}lineAt(e){throw new Error("Method not supported.")}offsetAt(e){throw new Error("Method not supported.")}positionAt(e){throw new Error("Method not supported.")}save(){throw new Error("Method not supported.")}validatePosition(e){throw new Error("Method not supported.")}validateRange(e){throw new Error("Method not supported.")}}var pe,fe;function ve(e){switch(e.type){case pe.Branch:return"Branch";case pe.Branches:return"Branches";case pe.Commit:return"Commit";case pe.File:return"File";case pe.Repo:return"Repository";case pe.Revision:return"Revision";default:return""}}(fe=pe||(pe={})).Branch="branch",fe.Branches="branches",fe.Commit="commit",fe.File="file",fe.Repo="repo",fe.Revision="revision";class we{constructor(e,t,i="https",s,o=!1){this.domain=e,this.path=t,this.protocol=i,this.custom=o,this._name=s}get icon(){return"remote"}get baseUrl(){return`${this.protocol}://${this.domain}/${this.path}`}enrichMessage(e){return e}formatName(e){return void 0!==this._name?this._name:`${e}${this.custom?` (${this.domain})`:""}`}splitPath(){const e=this.path.indexOf("/");return[this.path.substring(0,e),this.path.substring(e+1)]}getUrlForRepository(){return this.baseUrl}async openUrl(e){if(void 0!==e)return N.commands.executeCommand(W.Open,N.Uri.parse(e))}open(e){switch(e.type){case pe.Branch:return this.openBranch(e.branch);case pe.Branches:return this.openBranches();case pe.Commit:return this.openCommit(e.sha);case pe.File:return this.openFile(e.fileName,e.branch,void 0,e.range);case pe.Repo:return this.openRepo();case pe.Revision:return this.openFile(e.fileName,e.branch,e.sha,e.range)}}openRepo(){return this.openUrl(this.getUrlForRepository())}openBranches(){return this.openUrl(this.getUrlForBranches())}openBranch(e){return this.openUrl(this.getUrlForBranch(e))}openCommit(e){return this.openUrl(this.getUrlForCommit(e))}openFile(e,t,i,s){return this.openUrl(this.getUrlForFile(e,t,i,s))}}const Ce=/(^|\s)(issue #([0-9]+))\b/gi,be=/(^|\s)(pull request #([0-9]+))\b/gi;class ye extends we{constructor(e,t,i,s,o=!1){super(e,t,i,s,o)}get icon(){return"bitbucket"}get name(){return this.formatName("Bitbucket")}enrichMessage(e){return e.replace(Ce,`$1[$2](${this.baseUrl}/issues/$3 "Open Issue $2")`).replace(be,`$1[$2](${this.baseUrl}/pull-requests/$3 "Open PR $2")`)}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/commits/branch/${e}`}getUrlForCommit(e){return`${this.baseUrl}/commits/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`#${e}-${s.start.line}`:`#${e}-${s.start.line}:${s.end.line}`),i?`${this.baseUrl}/src/${i}/${e}${o}`:t?`${this.baseUrl}/src/${t}/${e}${o}`:`${this.baseUrl}?path=${e}${o}`}}const xe=/(^|\s)(issue #([0-9]+))\b/gi,Se=/(^|\s)(pull request #([0-9]+))\b/gi;class $e extends we{constructor(e,t,i,s,o=!1){super(e,t,i,s,o)}get baseUrl(){const[e,t]=this.splitPath();return`https://${this.domain}/projects/${e}/repos/${t}`}get icon(){return"bitbucket"}get name(){return this.formatName("Bitbucket Server")}enrichMessage(e){return e.replace(xe,`$1[$2](${this.baseUrl}/issues/$3 "Open Issue $2")`).replace(Se,`$1[$2](${this.baseUrl}/pull-requests/$3 "Open PR $2")`)}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/commits?until=${e}`}getUrlForCommit(e){return`${this.baseUrl}/commits/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`#${s.start.line}`:`#${s.start.line}-${s.end.line}`),i?`${this.baseUrl}/browse/${e}?at=${i}${o}`:t?`${this.baseUrl}/browse/${e}?at=${t}${o}`:`${this.baseUrl}/browse/${e}${o}`}}class De extends we{constructor(e,t,i,s,o){super(e,t,s,o,!0),this.urls=i}get name(){return this.formatName("Custom")}getUrlForRepository(){return w.interpolate(this.urls.repository,this.getContext())}getUrlForBranches(){return w.interpolate(this.urls.branches,this.getContext())}getUrlForBranch(e){return w.interpolate(this.urls.branch,this.getContext({branch:e}))}getUrlForCommit(e){return w.interpolate(this.urls.commit,this.getContext({id:e}))}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?w.interpolate(this.urls.fileLine,{line:s.start.line}):w.interpolate(this.urls.fileRange,{start:s.start.line,end:s.end.line})),i?w.interpolate(this.urls.fileInCommit,this.getContext({id:i,file:e,line:o})):t?w.interpolate(this.urls.fileInBranch,this.getContext({branch:t,file:e,line:o})):w.interpolate(this.urls.file,this.getContext({file:e,line:o}))}getContext(e){const[t,i]=this.splitPath();return Object.assign({repo:this.path,repoBase:t,repoPath:i},e||{})}}const Fe=/(^|\s)((?:#|gh-)([0-9]+))\b/gi,ke=/\b((\w+-?\w+(?!-)\/\w+-?\w+(?!-))#([0-9]+))\b/g;class Pe extends we{constructor(e,t,i,s,o=!1){super(e,t,i,s,o)}get icon(){return"github"}get name(){return this.formatName("GitHub")}enrichMessage(e){return e.replace(Fe,`$1[$2](${this.baseUrl}/issues/$3 "Open Issue $2")`).replace(ke,`[$1](${this.protocol}://${this.domain}/$2/issues/$3 "Open Issue #$3 from $2")`)}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/commits/${e}`}getUrlForCommit(e){return`${this.baseUrl}/commit/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`#L${s.start.line}`:`#L${s.start.line}-L${s.end.line}`),i?`${this.baseUrl}/blob/${i}/${e}${o}`:t?`${this.baseUrl}/blob/${t}/${e}${o}`:`${this.baseUrl}?path=${e}${o}`}}const _e=/(^|\s)(#([0-9]+))\b/gi;class Re extends we{constructor(e,t,i,s,o=!1){super(e,t,i,s,o)}get name(){return this.formatName("GitLab")}enrichMessage(e){return e.replace(_e,`$1[$2](${this.baseUrl}/issues/$3 "Open Issue $2")`)}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/commits/${e}`}getUrlForCommit(e){return`${this.baseUrl}/commit/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`#L${s.start.line}`:`#L${s.start.line}-${s.end.line}`),i?`${this.baseUrl}/blob/${i}/${e}${o}`:t?`${this.baseUrl}/blob/${t}/${e}${o}`:`${this.baseUrl}?path=${e}${o}`}}const Te=/(^|\s)(#([0-9]+))\b/gi,Ee=new Map([["bitbucket.org",(e,t)=>new ye(e,t)],["github.com",(e,t)=>new Pe(e,t)],["gitlab.com",(e,t)=>new Re(e,t)],["visualstudio.com",(e,t)=>new class extends we{constructor(e,t,i,s){super(e,t,i,s)}get name(){return"Visual Studio Team Services"}enrichMessage(e){return e.replace(Te,`$1[$2](${this.baseUrl}/_workitems/edit/$3 "Open Work Item $2")`)}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/?version=GB${e}&_a=history`}getUrlForCommit(e){return`${this.baseUrl}/commit/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`&line=${s.start.line}`:`&line=${s.start.line}&lineEnd=${s.end.line}`),i?`${this.baseUrl}/commit/${i}/?_a=contents&path=%2F${e}${o}`:t?`${this.baseUrl}/?path=%2F${e}&version=GB${t}&_a=contents${o}`:`${this.baseUrl}?path=%2F${e}${o}`}}(e,t)]]);class Be{static factory(e){return(t,i)=>this.create(e,t,i)}static create(e,t,i){try{let s=t.toLowerCase();s.endsWith("visualstudio.com")&&(s="visualstudio.com");const o=e.get(s);if(void 0===o)return;return o(t,i)}catch(e){return void ce.error(e,"RemoteProviderFactory")}}static createMap(e){const t=new Map(Ee);if(null!=e&&e.length>0)for(const i of e){const e=this.getCustomProvider(i);void 0!==e&&t.set(i.domain.toLowerCase(),e)}return t}static getCustomProvider(e){switch(e.type){case $.Bitbucket:return(t,i)=>new ye(t,i,e.protocol,e.name,!0);case $.BitbucketServer:return(t,i)=>new $e(t,i,e.protocol,e.name,!0);case $.Custom:return(t,i)=>new De(t,i,e.urls,e.protocol,e.name);case $.GitHub:return(t,i)=>new Pe(t,i,e.protocol,e.name,!0);case $.GitLab:return(t,i)=>new Re(t,i,e.protocol,e.name,!0)}}}var Ae=i(7),Ne=i(2),Ue=i(1);const Le="win32"===process.platform;function Oe(e){if(e.match(/[\\\/]/))return e;const t=Ue.join(".",e);try{if(Ne.statSync(t))return t}catch(e){}const i=process.env.PATH.split(Le?";":":");for(const t of i){const i=Ue.join(t,e);try{if(Ne.statSync(i))return i}catch(e){}}return e}function Ie(e,t,i={}){const s=Object.assign({maxBuffer:10485760},i),{stdin:o,stdinEncoding:a}=s,r=c.__rest(s,["stdin","stdinEncoding"]);return new Promise((i,s)=>{const n=Object(Ae.execFile)(e,t,r,(o,a,n)=>{if(!o)return n&&ce.warn(`Warning(${e} ${t.join(" ")}): ${n}`),void i(a);"stdout maxBuffer exceeded"===o.message&&s(new Error(`Command output exceeded the allocated stdout buffer. Set 'options.maxBuffer' to a larger value than ${r.maxBuffer} bytes`)),ce.warn(`Error(${r.cwd}): ${e} ${t.join(" ")})\n    (${o.code}) ${o.message}\n${n}`),s(o)});o&&n.stdin.end(o,a||"utf8")})}async function Me(e){const t=await Ie(e,["--version"]);return e&&"git"!==e||(e=function e(t,i){if(!Le)return{cmd:Oe(t),args:i};if(!Ne.existsSync(t)){const s=[".exe",".bat",".cmd",".ps1"];for(const o of s){const s=Oe(`${t}${o}`);if(Ne.existsSync(s))return e(s,i)}}return t.match(/\.ps1$/i)?{cmd:Ue.join(process.env.SYSTEMROOT,"System32","WindowsPowerShell","v1.0","PowerShell.exe"),args:["-ExecutionPolicy","Unrestricted","-NoLogo","-NonInteractive","-File",t].concat(i)}:t.match(/\.(bat|cmd)$/i)?{cmd:Ue.join(process.env.SYSTEMROOT,"System32","cmd.exe"),args:["/C",t,...i]}:t.match(/\.(js)$/i)?{cmd:process.execPath,args:[t].concat(i)}:{cmd:t,args:i}}(e,["--version"]).cmd),{path:e,version:(i=t.trim(),i.replace(/^git version /,""))};var i}function We(e){return e?Me(Ue.join(e,"Git","cmd","git.exe")):Promise.reject(new Error("Unable to find git"))}var He=i(4);class je extends N.Uri{constructor(e,t){if(void 0===e)return void super();if(e.scheme===V.GitLensGit){const t=JSON.parse(e.query),[i,s]=je.ensureValidUNCPath(e.authority,Ue.resolve(t.repoPath,t.fileName));return super({scheme:e.scheme,authority:i,path:s,query:e.query,fragment:e.fragment}),this.repoPath=t.repoPath,void(!ii.isStagedUncommitted(t.sha)&&ii.isUncommitted(t.sha)||(this.sha=t.sha))}if(void 0===t)return void super(e);if("string"==typeof t)return super(e),void(this.repoPath=t);const[i,s]=je.ensureValidUNCPath(e.authority,Ue.resolve(t.repoPath,t.fileName||e.fsPath));super({scheme:e.scheme,authority:i,path:s,query:e.query,fragment:e.fragment}),this.repoPath=t.repoPath,this.versionedPath=t.versionedPath,!ii.isStagedUncommitted(t.sha)&&ii.isUncommitted(t.sha)||(this.sha=t.sha)}get shortSha(){return this.sha&&ii.shortenSha(this.sha)}fileUri(e={}){return e.useVersionedPath&&void 0!==this.versionedPath?N.Uri.file(this.versionedPath):N.Uri.file(!e.noSha&&this.sha?this.path:this.fsPath)}getFormattedPath(e=w.pad(K.Dot,2,2),t){let i=Ue.dirname(this.fsPath);return this.repoPath&&(i=Ue.relative(this.repoPath,i)),void 0!==t&&(i=Ue.relative(t,i)),(i=w.normalizePath(i))&&"."!==i?`${Ue.basename(this.fsPath)}${e}${i}`:Ue.basename(this.fsPath)}getRelativePath(e){let t=Ue.relative(this.repoPath||"",this.fsPath);return void 0!==e&&(t=Ue.relative(e,t)),w.normalizePath(t)}static ensureValidUNCPath(e,t){if("\\"===t[0]&&"\\"===t[1]){const i=t.indexOf("\\",2);-1===i?(e=t.substring(2),t="\\"):(e=t.substring(2,i),t=t.substring(i)||"\\")}return[e,t]}static fromCommit(e,t=!1){return t?new je(e.previousUri,{repoPath:e.repoPath,sha:e.previousSha}):new je(e.uri,e)}static fromFileStatus(e,t,i,s=!1){const o=N.Uri.file(Ue.resolve(t,s&&e.originalFileName||e.fileName));return new je(o,void 0===i?t:{repoPath:t,sha:i})}static fromRepoPath(e,t){return new je(N.Uri.file(e),void 0===t?e:{repoPath:e,sha:t})}static fromRevisionUri(e){return new je(e)}static async fromUri(e){if(e instanceof je)return e;if(!la.git.isTrackable(e))return new je(e);if(e.scheme===V.GitLensGit)return new je(e);if(e.scheme===V.Git){const t=JSON.parse(e.query),i=await la.git.getRepoPath(t.path);let s;switch(t.ref){case"":case"~":s=ii.stagedUncommittedSha;break;case null:s=void 0;break;default:s=t.ref}return new je(e,{fileName:t.path,repoPath:i,sha:s})}const t=await la.git.getVersionedUri(e);return void 0!==t?t:new je(e,await la.git.getRepoPath(e))}static getDirectory(e,t){let i=Ue.dirname(e);return void 0!==t&&(i=Ue.relative(t,i)),(i=w.normalizePath(i))&&"."!==i?i:""}static getFormattedPath(e,t=w.pad(K.Dot,2,2),i){let s;if(e instanceof N.Uri){if(e instanceof je)return e.getFormattedPath(t,i);s=e.fsPath}else s=e;const o=je.getDirectory(s,i);return o?`${Ue.basename(s)}${t}${o}`:Ue.basename(s)}static getRelativePath(e,t,i){let s;if(e instanceof N.Uri){if(e instanceof je)return e.getRelativePath(t);s=e.fsPath}else s=e;let o=Ue.relative(i||"",s);return void 0!==t&&(o=Ue.relative(t,o)),w.normalizePath(o)}static toKey(e){return w.normalizePath("string"==typeof e?e:e.fsPath).toLowerCase()}static toRevisionUri(e,t,i){let s,o,a;"string"==typeof e?(s="string"==typeof t?t:Ue.resolve(i,t.fileName),o=e,a=ii.shortenSha(o)):(s=e.fsPath,i=e.repoPath,o=e.sha,a=e.shortSha);const r={fileName:w.normalizePath(Ue.relative(i,s)),repoPath:i,sha:o},n=Ue.parse(s);return N.Uri.parse(`${V.GitLensGit}:${Ue.join(n.dir,n.name)}:${a}${n.ext}?${JSON.stringify(r)}`)}}const Ge=new Map;var Ve,Qe;(Qe=Ve||(Ve={})).Blame="blame",Qe.Branch="branch",Qe.File="file",Qe.Stash="stash",Qe.StashFile="stash-file";const Ke={dateFormat:void 0,dateStyle:void 0,reset:()=>{Ke.dateStyle=ua.get(ua.name("defaultDateStyle").value),Ke.dateFormat=ua.get(ua.name("defaultDateFormat").value)}};class qe{constructor(e,t,i,s,o,a,r,n,h,c,l){this.repoPath=t,this.sha=i,this.author=s,this.email=o,this.date=a,this.message=r,this.type=e,this._fileName=n||"",this.originalFileName=h,this._previousSha=c,this.previousFileName=l}get fileName(){return this.isFile?this._fileName:""}get formattedDate(){return Ke.dateStyle===D.Absolute?this.formatDate(Ke.dateFormat):this.fromNow()}get shortSha(){return void 0===this._shortSha&&(this._shortSha=Ht.shortenSha(this.sha)),this._shortSha}get isFile(){return this.type===Ve.Blame||this.type===Ve.File||this.type===Ve.StashFile}get isStash(){return this.type===Ve.Stash||this.type===Ve.StashFile}get isStagedUncommitted(){return void 0===this._isStagedUncommitted&&(this._isStagedUncommitted=Ht.isStagedUncommitted(this.sha)),this._isStagedUncommitted}get isUncommitted(){return void 0===this._isUncommitted&&(this._isUncommitted=Ht.isUncommitted(this.sha)),this._isUncommitted}get previousFileShortSha(){return Ht.shortenSha(this.previousFileSha)}get previousSha(){return this._previousSha}set previousSha(e){e!==this._previousSha&&(this._previousSha=e,this._resolvedPreviousFileSha=void 0)}get previousShortSha(){return this.previousSha&&Ht.shortenSha(this.previousSha)}get previousUri(){return this.previousFileName?N.Uri.file(Ue.resolve(this.repoPath,this.previousFileName||this.originalFileName)):this.uri}get uri(){return N.Uri.file(Ue.resolve(this.repoPath,this.fileName))}formatDate(e){return null==e&&(e="MMMM Do, YYYY h:mma"),void 0===this._dateFormatter&&(this._dateFormatter=h.toFormatter(this.date)),this._dateFormatter.format(e)}fromNow(){return void 0===this._dateFormatter&&(this._dateFormatter=h.toFormatter(this.date)),this._dateFormatter.fromNow()}getFormattedPath(e=w.pad(K.Dot,2,2)){return je.getFormattedPath(this.fileName,e)}getGravatarUri(e,t=16){const i=this.email?`${this.email.trim().toLowerCase()}:${t}`:"";let s=Ge.get(i);if(void 0!==s)return s;const o=(s=N.Uri.parse(`https://www.gravatar.com/avatar/${this.email?w.md5(this.email,"hex"):"00000000000000000000000000000000"}.jpg?s=${t}&d=${e}`)).toString;return s.toString=function(e){return o.call(s,!0)},Ge.set(i,s),s}getShortMessage(e=`${K.Space}${K.Ellipsis}`){const t=this.message.indexOf("\n");return-1===t?this.message:`${this.message.substring(0,t)}${e}`}async resolvePreviousFileSha(){void 0===this._resolvedPreviousFileSha&&(this._resolvedPreviousFileSha=await la.git.resolveReference(this.repoPath,this.previousFileSha,this.fileName?this.previousUri:void 0))}toGitUri(e=!1){return je.fromCommit(this,e)}getChangedValue(e,t){return void 0===e?t:null!==e?e:void 0}}class ze extends qe{constructor(e,t,i,s,o,a,r,n,h,c,l){super(Ve.Blame,e,t,i,s,o,a,r,n,h,c),this.lines=l}get previousFileSha(){return void 0!==this._resolvedPreviousFileSha?this._resolvedPreviousFileSha:`${this.sha}^`}with(e){return new ze(this.repoPath,e.sha||this.sha,this.author,this.email,this.date,this.message,e.fileName||this.fileName,this.getChangedValue(e.originalFileName,this.originalFileName),this.getChangedValue(e.previousSha,this.previousSha),this.getChangedValue(e.previousFileName,this.previousFileName),this.getChangedValue(e.lines,e.sha||e.fileName?[]:this.lines)||[])}}class Ye{constructor(e,t,i=!1,s,o=0,a=0){this.repoPath=e,t.startsWith("remotes/")?(t=t.substring(8),this.remote=!0):this.remote=!1,this.current=i,this.name=t,this.tracking=""===s||null==s?void 0:s,this.state={ahead:o,behind:a}}getBasename(){if(void 0===this._basename){const e=this.getName(),t=e.lastIndexOf("/");this._basename=-1!==t?e.substring(t+1):e}return this._basename}getName(){return void 0===this._name&&(this._name=this.remote?this.name.substring(this.name.indexOf("/")+1):this.name),this._name}getRemote(){return this.remote?Ye.getRemote(this.name):void 0!==this.tracking?Ye.getRemote(this.tracking):void 0}isValid(){return Ye.isValid(this.name)}static getRemote(e){return e.substring(0,e.indexOf("/"))}static isValid(e){return null===e.match(/\s/)}}const Xe=/^(.*?)\t(.*?)(?:\t(.*?))?$/gm,Je=/^\s*(\d+)\sfiles? changed(?:,\s+(\d+)\s+insertions?\(\+\))?(?:,\s+(\d+)\s+deletions?\(-\))?/,Ze=/^@@ -([\d]+),([\d]+) [+]([\d]+),([\d]+) @@([\s\S]*?)(?=^@@)/gm;class et{static parse(e,t=!1){if(!e)return;const i=[];let s,o,a,r=null;do{if(null==(r=Ze.exec(`${e}\n@@`)))break;s=(" "+r[5]).substr(1),o=parseInt(r[3],10),a=parseInt(r[1],10),i.push(new tt(s,{start:o,end:o+parseInt(r[4],10)},{start:a,end:a+parseInt(r[2],10)}))}while(null!=r);return i.length?{diff:t?e:void 0,chunks:i}:void 0}static parseChunk(e){const t=u.skip(w.lines(e),1),i=[],s=[];let o=0;for(const e of t)switch(e[0]){case"+":i.push({line:` ${e.substring(1)}`,state:"added"}),o>0?o--:s.push(void 0);break;case"-":o++,s.push({line:` ${e.substring(1)}`,state:"removed"});break;default:for(;o>0;)o--,i.push(void 0);i.push({line:e,state:"unchanged"}),s.push({line:e,state:"unchanged"})}const a=[];let r=void 0,n=void 0;for(let e=0;e<i.length;e++)if(void 0!==(n=i[e]))r={line:n.line,state:n.state,previous:[s[e]]},a.push(r);else{if(void 0===r)continue;if(void 0===r.previous){r.previous=[s[e]];continue}r.previous.push(s[e])}return a}static parseNameStatus(e,t){if(!e)return;const i=[];let s=null;do{if(null==(s=Xe.exec(e)))break;i.push(Tt.parseStatusFile(t,s[1],s[2],s[3]))}while(null!=s);return i.length?i:void 0}static parseShortStat(e){if(!e)return;const t=Je.exec(e);if(null==t)return;const i=t[1],s=t[2],o=t[3];return{files:null==i?0:parseInt(i,10),insertions:null==s?0:parseInt(s,10),deletions:null==o?0:parseInt(o,10)}}}class tt{constructor(e,t,i){this.currentPosition=t,this.previousPosition=i,this._chunk=e}get lines(){return void 0===this._lines&&(this._lines=et.parseChunk(this._chunk),this._chunk=void 0),this._lines}}class it extends qe{constructor(e,t,i,s,o,a,r,n,h,c,l,d,m,u){super(e,t,i,s,o,a,r,n,l,d,m),this.fileStatuses=h,this.status=c,this.parentShas=u}get isMerge(){return this.parentShas&&this.parentShas.length>1}get nextShortSha(){return this.nextSha&&Ht.shortenSha(this.nextSha)}get nextUri(){return this.nextFileName?N.Uri.file(Ue.resolve(this.repoPath,this.nextFileName)):this.uri}get previousFileSha(){return void 0!==this._resolvedPreviousFileSha?this._resolvedPreviousFileSha:this.isFile&&this.previousSha?this.previousSha:`${this.sha}^`}getDiffStatus(){let e=0,t=0,i=0;for(const s of this.fileStatuses)switch(s.status){case"A":case"?":e++;break;case"D":t++;break;default:i++}return`+${e} ~${i} -${t}`}toFileCommit(e){let t;if("string"==typeof e){const i=w.normalizePath(Ue.relative(this.repoPath,e));if(void 0===(t=this.fileStatuses.find(e=>e.fileName===i)))return}else t=e;const i=this.isFile?this.previousSha:`${this.sha}^`;return this.with({type:this.isStash?Ve.StashFile:Ve.File,fileName:t.fileName,originalFileName:t.originalFileName,previousSha:i,previousFileName:t.originalFileName||t.fileName,status:t.status,fileStatuses:[t]})}with(e){return new it(e.type||this.type,this.repoPath,this.getChangedValue(e.sha,this.sha),e.author||this.author,e.email||this.email,e.date||this.date,e.message||this.message,e.fileName||this.fileName,this.getChangedValue(e.fileStatuses,this.fileStatuses)||[],e.status||this.status,this.getChangedValue(e.originalFileName,this.originalFileName),this.getChangedValue(e.previousSha,this.previousSha),this.getChangedValue(e.previousFileName,this.previousFileName),void 0)}}var st,ot,at,rt;!function(e){e.Fetch="fetch",e.Push="push"}(st||(st={}));class nt{constructor(e,t,i,s,o,a){this.repoPath=e,this.name=t,this.domain=i,this.path=s,this.provider=o,this.types=a}}(at=ot||(ot={})).Config="config",at.Remotes="remotes",at.Repository="repository",at.Stashes="stashes",at.Tags="tags";class ht{constructor(e){this.repository=e,this.changes=[]}changed(e,t=!1){return t?1===this.changes.length&&this.changes[0]===e:this.changes.includes(e)}}(rt||(rt={})).StatusNode="statusNode";class ct extends N.Disposable{constructor(e,t,i,s,o){super(()=>this.dispose()),this.folder=e,this.path=t,this.root=i,this.onAnyRepositoryChanged=s,this._onDidChange=new N.EventEmitter,this._onDidChangeFileSystem=new N.EventEmitter,this._fireChangeDebounced=void 0,this._fireFileSystemChangeDebounced=void 0,this._fsWatchCounter=0,this._pendingChanges={},this.formattedName=i?e.name:`${e.name} (${Ue.relative(e.uri.fsPath,t)})`,this.index=e.index,this.name=e.name,this.normalizedPath=(this.path.endsWith("/")?this.path:`${this.path}/`).toLowerCase(),this._suspended=o;const a=N.workspace.createFileSystemWatcher(new N.RelativePattern(e,"{**/.git/config,**/.git/index,**/.git/HEAD,**/.git/refs/stash,**/.git/refs/heads/**,**/.git/refs/remotes/**,**/.git/refs/tags/**,**/.gitignore}"));this._disposable=N.Disposable.from(a,a.onDidChange(this.onRepositoryChanged,this),a.onDidCreate(this.onRepositoryChanged,this),a.onDidDelete(this.onRepositoryChanged,this),ua.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(ua.initializingChangeEvent)}get onDidChange(){return this._onDidChange.event}get onDidChangeFileSystem(){return this._onDidChangeFileSystem.event}dispose(){this.stopWatchingFileSystem(),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=ua.initializing(e),i=ua.name("remotes").value;(t||ua.changed(e,i,this.folder.uri))&&(this._providerMap=Be.createMap(ua.get(i,this.folder.uri)),t||(this._remotes=void 0,this.fireChange(ot.Remotes)))}onFileSystemChanged(e){/\.git/.test(e.fsPath)||this.fireFileSystemChange(e)}onRepositoryChanged(e){if(void 0!==e&&e.path.endsWith("refs/stash"))this.fireChange(ot.Stashes);else{if(this._branch=void 0,void 0!==e&&e.path.endsWith("refs/remotes"))return this._remotes=void 0,void this.fireChange(ot.Remotes);if(void 0!==e&&e.path.endsWith("refs/tags"))this.fireChange(ot.Tags);else{if(void 0!==e&&e.path.endsWith("config"))return this._remotes=void 0,void this.fireChange(ot.Config,ot.Remotes);this.onAnyRepositoryChanged(this),this.fireChange(ot.Repository)}}}fireChange(...e){void 0===this._fireChangeDebounced&&(this._fireChangeDebounced=m.debounce(this.fireChangeCore,250)),void 0===this._pendingChanges.repo&&(this._pendingChanges.repo=new ht(this));const t=this._pendingChanges.repo;for(const i of e)t.changes.includes(i)||t.changes.push(i);this._suspended||this._fireChangeDebounced(t)}fireChangeCore(e){this._pendingChanges.repo=void 0,this._onDidChange.fire(e)}fireFileSystemChange(e){void 0===this._fireFileSystemChangeDebounced&&(this._fireFileSystemChangeDebounced=m.debounce(this.fireFileSystemChangeCore,2500)),void 0===this._pendingChanges.fs&&(this._pendingChanges.fs={repository:this,uris:[]});const t=this._pendingChanges.fs;t.uris.push(e),this._suspended||this._fireFileSystemChangeDebounced(t)}fireFileSystemChangeCore(e){this._pendingChanges.fs=void 0,this._onDidChangeFileSystem.fire(e)}containsUri(e){return e instanceof je&&(e=void 0!==e.repoPath?N.Uri.file(e.repoPath):e.fileUri()),this.folder===N.workspace.getWorkspaceFolder(e)}getBranch(){return void 0===this._branch&&(this._branch=la.git.getBranch(this.path)),this._branch}getBranches(){return la.git.getBranches(this.path)}getChangedFilesCount(e){return la.git.getChangedFilesCount(this.path,e)}getRemotes(){if(void 0===this._remotes){if(void 0===this._providerMap){const e=ua.get(ua.name("remotes").value,this.folder.uri);this._providerMap=Be.createMap(e)}this._remotes=la.git.getRemotesCore(this.path,this._providerMap)}return this._remotes}getStashList(){return la.git.getStashList(this.path)}getStatus(){return la.git.getStatusForRepo(this.path)}getTags(){return la.git.getTags(this.path)}async hasRemote(){const e=await this.getBranch();return void 0!==e&&void 0!==e.tracking}async hasRemotes(){const e=await this.getRemotes();return void 0!==e&&e.length>0}resume(){this._suspended&&(this._suspended=!1,void 0!==this._pendingChanges.repo&&this._fireChangeDebounced(this._pendingChanges.repo),void 0!==this._pendingChanges.fs&&this._fireFileSystemChangeDebounced(this._pendingChanges.fs))}startWatchingFileSystem(){if(this._fsWatchCounter++,void 0!==this._fsWatcherDisposable)return;const e=N.workspace.createFileSystemWatcher(new N.RelativePattern(this.folder,"**"));this._fsWatcherDisposable=N.Disposable.from(e,e.onDidChange(this.onFileSystemChanged,this),e.onDidCreate(this.onFileSystemChanged,this),e.onDidDelete(this.onFileSystemChanged,this))}stopWatchingFileSystem(){void 0!==this._fsWatcherDisposable&&(--this._fsWatchCounter>0||(this._fsWatcherDisposable.dispose(),this._fsWatcherDisposable=void 0))}suspend(){this._suspended=!0}}class lt extends it{constructor(e,t,i,s,o,a,r,n,h,c,l,d){super(e,i,s,"You",void 0,o,a,r,n,h,c,void 0===l?`${s}^`:l,d),this.stashName=t}get shortSha(){return this.stashName}with(e){return new lt(e.type||this.type,this.stashName,this.repoPath,this.getChangedValue(e.sha,this.sha),e.date||this.date,e.message||this.message,e.fileName||this.fileName,this.getChangedValue(e.fileStatuses,this.fileStatuses)||[],e.status||this.status,this.getChangedValue(e.originalFileName,this.originalFileName),this.getChangedValue(e.previousSha,this.previousSha),this.getChangedValue(e.previousFileName,this.previousFileName))}}class dt{constructor(e,t,i,s,o){this.repoPath=e,this.indexStatus=t,this.workTreeStatus=i,this.fileName=s,this.originalFileName=o}get status(){return this.indexStatus||this.workTreeStatus||"?"}get staged(){return void 0!==this.indexStatus}get uri(){return N.Uri.file(Ue.resolve(this.repoPath,this.fileName))}getFormattedDirectory(e=!1){return dt.getFormattedDirectory(this,e)}getFormattedPath(e=w.pad(K.Dot,2,2)){return dt.getFormattedPath(this,e)}getOcticon(){return ut(this.status)}with(e){return new dt(this.repoPath,this.getChangedValue(e.indexStatus,this.indexStatus),this.getChangedValue(e.workTreeStatus,this.workTreeStatus),e.fileName||this.fileName,this.getChangedValue(e.originalFileName,this.originalFileName))}getChangedValue(e,t){return void 0===e?t:null!==e?e:void 0}static getFormattedDirectory(e,t=!1,i){const s=je.getDirectory(e.fileName,i);return t&&"R"===e.status&&e.originalFileName?`${s} ${w.pad(K.ArrowLeft,1,1)} ${e.originalFileName}`:s}static getFormattedPath(e,t=w.pad(K.Dot,2,2),i){return je.getFormattedPath(e.fileName,t,i)}static getRelativePath(e,t){return je.getRelativePath(e.fileName,t)}}const mt={"!":"$(diff-ignored)","?":"$(diff-added)",A:"$(diff-added)",C:"$(diff-added)",D:"$(diff-removed)",M:"$(diff-modified)",R:"$(diff-renamed)",T:"$(diff-modified)",U:"$(alert)",X:"$(question)",B:"$(question)"};function ut(e,t=K.Space.repeat(4)){return mt[e]||t}const gt={"!":"icon-status-ignored.svg","?":"icon-status-untracked.svg",A:"icon-status-added.svg",C:"icon-status-copied.svg",D:"icon-status-deleted.svg",M:"icon-status-modified.svg",R:"icon-status-renamed.svg",T:"icon-status-modified.svg",U:"icon-status-conflict.svg",X:"icon-status-unknown.svg",B:"icon-status-unknown.svg"};function pt(e){return gt[e]||gt.X}class ft{constructor(e,t){this.repoPath=e,this.name=t}}class vt{static parse(e,t,i){if(!e)return;const s=new Map,o=new Map,a=[];let r,n,h=t&&i,c=void 0,l=!0;for(r of w.lines(e))if(!((n=r.split(" ")).length<2))if(void 0!==c)switch(n[0]){case"author":c.author=Ht.isUncommitted(c.sha)?"You":n.slice(1).join(" ").trim();break;case"author-mail":c.authorEmail=n.slice(1).join(" ").trim();const e=c.authorEmail.indexOf("<");if(e>=0){const t=c.authorEmail.indexOf(">",e);c.authorEmail=t>e?c.authorEmail.substring(e+1,t):c.authorEmail.substring(e+1)}break;case"author-time":c.authorDate=n[1];break;case"author-tz":c.authorTimeZone=n[1];break;case"summary":c.summary=n.slice(1).join(" ").trim();break;case"previous":c.previousSha=n[1],c.previousFileName=n.slice(2).join(" ");break;case"filename":c.fileName=n.slice(1).join(" "),l&&void 0===t&&(t=w.normalizePath(i.replace(i.startsWith("/")?`/${c.fileName}`:c.fileName,"")),h=w.normalizePath(Ue.relative(t,i))),l=!1,vt.parseEntry(c,t,h,o,s,a),c=void 0}else c={sha:n[0],originalLine:parseInt(n[1],10)-1,line:parseInt(n[2],10)-1,lineCount:parseInt(n[3],10)};return o.forEach(e=>{if(void 0===e.author)return;const t=s.get(e.author);void 0!==t&&(t.lineCount+=e.lines.length)}),{repoPath:t,authors:new Map([...s.entries()].sort((e,t)=>t[1].lineCount-e[1].lineCount)),commits:o,lines:a}}static parseEntry(e,t,i,s,o,a){let r=s.get(e.sha);if(void 0===r){if(void 0!==e.author){let t=o.get(e.author);void 0===t&&(t={name:e.author,lineCount:0},o.set(e.author,t))}r=new ze(t,e.sha,e.author,e.authorEmail,new Date(1e3*e.authorDate),e.summary,i,i!==e.fileName?e.fileName:void 0,e.previousSha,e.previousSha&&e.previousFileName,[]),s.set(e.sha,r)}for(let t=0,i=e.lineCount;t<i;t++){const i={sha:e.sha,line:e.line+t,originalLine:e.originalLine+t};r.previousSha&&(i.previousSha=r.previousSha),r.lines.push(i),a[i.line]=i}}}const wt=/^(\*?)\s+(.+?)\s+([0-9,a-f]+)\s+(?:\[(.*?\/.*?)(?:\:\s(.*)\]|\]))?/gm,Ct=/^(?:ahead\s([0-9]+))?[,\s]*(?:behind\s([0-9]+))?/;class bt{static parse(e,t){if(!e)return;const i=[];let s=null;do{if(null==(s=wt.exec(e)))break;const[o,a]=this.parseState(s[5]);i.push(new Ye(t,s[2],"*"===s[1],s[4],o,a))}while(null!=s);return i.length?i:void 0}static parseState(e){if(null==e)return[0,0];const t=Ct.exec(e);if(null==t)return[0,0];const i=parseInt(t[1],10),s=parseInt(t[2],10);return[isNaN(i)?0:i,isNaN(s)?0:s]}}const yt=/diff --git a\/(.*) b\/(.*)/,xt={};class St{static parse(e,t,i,s,a,r,n,h){if(!e)return;let c,l,d=void 0,m=xt,u=void 0,g=0,p=!0;const f=w.lines(e+"</f>");let v=f.next();if(v.done)return;void 0!==i&&(i=w.normalizePath(i));const C=new Map,b=new Map;for(;!((v=f.next()).done||(u=v.value,n&&r&&g>=r));)switch(l=u.charCodeAt(1)){case 114:m={ref:u.substring(4)};break;case 97:m.author=Ht.isUncommitted(m.ref)?"You":u.substring(4);break;case 101:m.email=u.substring(4);break;case 100:m.date=u.substring(4);break;case 112:m.parentShas=u.substring(4).split(" ");break;case 115:for(;!(v=f.next()).done&&"</s>"!==(u=v.value);)void 0===m.summary?m.summary=u:m.summary+=`\n${u}`;void 0!==m.summary&&(m.summary=m.summary.slice(0,-1));break;case 102:if((v=f.next()).done||"</f>"===v.value)break;for(;!(v=f.next()).done&&"</f>"!==(u=v.value);)if(!u.startsWith("warning:"))if(t===Ve.Branch){const e={status:u[0],fileName:u.substring(1),originalFileName:void 0};this.parseFileName(e),e.fileName&&(void 0===m.fileStatuses&&(m.fileStatuses=[]),m.fileStatuses.push(e))}else{if(u.startsWith("diff")){const e=yt.exec(u);if(null!=e){m.fileName=e[1];const t=e[2];m.fileName!==t&&(m.originalFileName=t),m.status=m.fileName!==m.originalFileName?"R":"M"}for(;!(v=f.next()).done&&"</f>"!==v.value;);break}m.status=u[0],m.fileName=u.substring(1),this.parseFileName(m)}void 0!==m.fileStatuses&&(m.fileName=o.filterMap(m.fileStatuses,e=>e.fileName?e.fileName:void 0).join(", ")),p&&void 0===i&&t===Ve.File&&void 0!==s?(i=w.normalizePath(s.replace(s.startsWith("/")?`/${m.fileName}`:m.fileName,"")),c=w.normalizePath(Ue.relative(i,s))):c=m.fileName,p=!1;const e=b.get(m.ref);void 0===e&&g++,d=St.parseEntry(m,e,t,i,c,b,C,d)}return{repoPath:i,authors:C,commits:b,sha:a,count:g,maxCount:r,range:h,truncated:!!(r&&g>=r&&1!==r)}}static parseEntry(e,t,i,s,o,a,r,n){if(void 0===t){if(void 0!==e.author){let t=r.get(e.author);void 0===t&&(t={name:e.author,lineCount:0},r.set(e.author,t))}const n=o!==e.fileName?e.fileName:void 0;i===Ve.File&&(e.fileStatuses=[{status:e.status,fileName:o,originalFileName:n}]),t=new it(i,s,e.ref,e.author,e.email,new Date(1e3*e.date),void 0===e.summary?"":e.summary,o,e.fileStatuses||[],e.status,n,void 0,void 0,e.parentShas),a.set(e.ref,t)}return void 0!==n&&(n.previousSha=t.sha,t.nextSha=t.sha!==n.sha?n.sha:n.nextSha,i===Ve.File&&(n.previousFileName=t.originalFileName||t.fileName,t.nextFileName=n.originalFileName||n.fileName)),t}static parseFileName(e){if(void 0===e.fileName)return;const t=e.fileName.indexOf("\t")+1;if(t>0){const i=e.fileName.indexOf("\t",t)+1;i>0?(e.originalFileName=e.fileName.substring(t,i-1),e.fileName=e.fileName.substring(i)):e.fileName=e.fileName.substring(t)}}}const $t=/^(.*)\t(.*)\s\((.*)\)$/gm,Dt=/^(?:git:\/\/(.*?)\/|https:\/\/(.*?)\/|http:\/\/(.*?)\/|git@(.*):|ssh:\/\/(?:.*@)?(.*?)(?::.*?)?\/)(.*)$/;class Ft{static parse(e,t,i){if(!e)return[];const s=[],o=Object.create(null);let a=null;do{if(null==(a=$t.exec(e)))break;const r=a[2],[n,h]=this.parseGitUrl(r),c=`${n}/${h}`;let l=o[c];void 0===l?(l=new nt(t,a[1],n,h,i(n,h),[{url:r,type:a[3]}]),s.push(l),o[c]=l):l.types.push({url:r,type:a[3]})}while(null!=a);return s.length?s:[]}static parseGitUrl(e){const t=Dt.exec(e);return null==t?["",""]:[t[1]||t[2]||t[3]||t[4]||t[5],t[6].replace(/\.git\/?$/,"")]}}const kt={};class Pt{static parse(e,t){if(!e)return;const i=w.lines(e+"</f>");let s=i.next();if(s.done)return;void 0!==t&&(t=w.normalizePath(t));const a=new Map;let r,n=kt,h=void 0;for(;!(s=i.next()).done;)switch(r=(h=s.value).charCodeAt(1)){case 114:n={ref:h.substring(4)};break;case 100:n.date=h.substring(4);break;case 108:n.stashName=h.substring(4);break;case 115:for(;!(s=i.next()).done&&"</s>"!==(h=s.value);)void 0===n.summary?n.summary=h:n.summary+=`\n${h}`;void 0!==n.summary&&(n.summary=n.summary.slice(0,-1));break;case 102:if((s=i.next()).done||"</f>"===s.value)break;for(;!(s=i.next()).done&&"</f>"!==(h=s.value);){if(h.startsWith("warning:"))continue;const e={status:h[0],fileName:h.substring(1),originalFileName:void 0};St.parseFileName(e),e.fileName&&(void 0===n.fileStatuses&&(n.fileStatuses=[]),n.fileStatuses.push(e))}void 0!==n.fileStatuses&&(n.fileNames=o.filterMap(n.fileStatuses,e=>e.fileName?e.fileName:void 0).join(", "));let e=a.get(n.ref);e=Pt.parseEntry(n,e,t,a)}return{repoPath:t,commits:a}}static parseEntry(e,t,i,s){return void 0===t&&(t=new lt(Ve.Stash,e.stashName,i,e.ref,new Date(1e3*e.date),void 0===e.summary?"":e.summary,e.fileNames,e.fileStatuses||[])),s.set(e.ref,t),t}}const _t=/(?:ahead ([0-9]+))/,Rt=/(?:behind ([0-9]+))/;class Tt{static parse(e,t,i){if(!e)return;const s=e.split("\n").filter(e=>!!e);return 0!==s.length?i<2?this.parseV1(s,t):this.parseV2(s,t):void 0}static parseV1(e,t){let i;const s=[],o={ahead:0,behind:0};let a,r=-1;for(;++r<e.length;){const n=e[r];if(n.startsWith("##")){const e=n.split(" ");if([i,a]=e[1].split("..."),e.length>2){const t=e.slice(2).join(" "),i=_t.exec(t);o.ahead=null==i?0:+i[1]||0;const s=Rt.exec(t);o.behind=null==s?0:+s[1]||0}}else{const e=n.substring(0,2),i=n.substring(3);if("R"===e[0]){const[o,a]=i.replace(/\"/g,"").split("->");s.push(this.parseStatusFile(t,e,a.trim(),o.trim()))}else s.push(this.parseStatusFile(t,e,i))}}return{branch:i||"",repoPath:w.normalizePath(t),sha:"",state:o,files:s,upstream:a}}static parseV2(e,t){let i;const s=[];let o;const a={ahead:0,behind:0};let r,n=-1;for(;++n<e.length;){const h=e[n];if(h.startsWith("#")){const e=h.split(" ");switch(e[1]){case"branch.oid":o=e[2];break;case"branch.head":i=e[2];break;case"branch.upstream":r=e[2];break;case"branch.ab":a.ahead=+e[2].substring(1),a.behind=+e[3].substring(1)}}else{const e=h.split(" ");switch(e[0][0]){case"1":s.push(this.parseStatusFile(t,e[1],e.slice(8).join(" ")));break;case"2":const i=e.slice(9).join(" ").split("\t");s.push(this.parseStatusFile(t,e[1],i[0],i[1]));break;case"u":s.push(this.parseStatusFile(t,e[1],e.slice(10).join(" ")));break;case"?":s.push(this.parseStatusFile(t," ?",e.slice(1).join(" ")))}}}return{branch:i||"",repoPath:w.normalizePath(t),sha:o||"",state:a,files:s,upstream:r}}static parseStatusFile(e,t,i,s){let o="."!==t[0]?t[0].trim():void 0;""!==o&&null!==o||(o=void 0);let a=void 0;return t.length>1&&(""!==(a="."!==t[1]?t[1].trim():void 0)&&null!==a||(a=void 0)),new dt(e,o,a,i,s)}}class Et{static parse(e,t){if(!e)return;const i=o.filterMap(e.split("\n"),e=>e?new ft(t,e):void 0);return i.length?i:void 0}}let Bt;const At=["blame","--root","--incremental"],Nt=["log","--name-status","-M",`--format=${["%x3c%x2ff%x3e","%x3cr%x3e %H","%x3ca%x3e %an","%x3ce%x3e %ae","%x3cd%x3e %at","%x3cp%x3e %P","%x3cs%x3e","%B","%x3c%x2fs%x3e","%x3cf%x3e"].join("%n")}`],Ut=["stash","list","--name-status","-M",`--format=${["%x3c%x2ff%x3e","%x3cr%x3e %H","%x3cd%x3e %at","%x3cl%x3e %gd","%x3cs%x3e","%B","%x3c%x2fs%x3e","%x3cf%x3e"].join("%n")}`],Lt={notARepository:/Not a git repository/,outsideRepository:/is outside repository/,noPath:/no such path/,noCommits:/does not have any commits/,notFound:/Path \'.*?\' does not exist in/,foundButNotInRevision:/Path \'.*?\' exists on disk, but not in/,headNotABranch:/HEAD does not point to a branch/,noUpstream:/no upstream configured for branch \'(.*?)\'/,unknownRevision:/ambiguous argument \'.*?\': unknown revision or path not in the working tree/};async function Ot(e,...t){try{return await Mt(e,...t)}catch(i){return Wt(i,e,...t)}}const It=new Map;async function Mt(e,...t){const i=process.hrtime(),{correlationKey:s}=e,o=c.__rest(e,["correlationKey"]),a=e.encoding||"utf8",r=Object.assign({},o,{encoding:"utf8"===a?"utf8":"binary",env:Object.assign({},e.env||process.env,{GCM_INTERACTIVE:"NEVER",GCM_PRESERVE_CREDS:"TRUE",LC_ALL:"C"})}),n=`git ${t.join(" ")}`,h=`(${r.cwd}${void 0!==s?s:""}): ${n}`;let l,d=It.get(h);void 0===d?(ce.log(`Running${h}`),t.splice(0,0,"-c","core.quotepath=false","-c","color.ui=false"),d=Ie(Bt.path,t,r),It.set(h,d)):ce.log(`Awaiting${h}`);try{l=await d}finally{It.delete(h);const e=process.hrtime(i),t=`in ${1e3*e[0]+Math.floor(e[1]/1e6)} ms`;ce.log(`Completed${h} ${t}`),ce.logGitCommand(`${n} ${t}`,r.cwd)}return"utf8"===a||"binary"===a?l:He.decode(Buffer.from(l,"binary"),a)}function Wt(e,t,...i){const o=e&&e.toString();if(o)for(const e of s.values(Lt))if(e.test(o))return ce.warn("git",...i,`  cwd='${t.cwd}'`,`\n  ${o.replace(/\r?\n|\r/g," ")}`),"";throw ce.error(e,"git",...i,`  cwd='${t.cwd}'`,o&&`\n  ${o.replace(/\r?\n|\r/g," ")}`),e}class Ht{static gitInfo(){return Bt}static getEncoding(e){return void 0!==e&&He.encodingExists(e)?e:"utf8"}static async getGitInfo(e){const t=process.hrtime();Bt=await async function(e){try{return await Me(e||"git")}catch(e){try{switch(process.platform){case"darwin":return await async function(){try{let e=await Ie("which",["git"]);if("/usr/bin/git"!==(e=e.replace(/^\s+|\s+$/g,"")))return Me(e);try{return await Ie("xcode-select",["-p"]),Me(e)}catch(t){return 2===t.code?Promise.reject(new Error("Unable to find git")):Me(e)}}catch(e){return Promise.reject(new Error("Unable to find git"))}}();case"win32":return await We(process.env.ProgramW6432).then(null,()=>We(process.env["ProgramFiles(x86)"])).then(null,()=>We(process.env.ProgramFiles)).then(null,()=>Me("git"));default:return Promise.reject("Unable to find git")}}catch(e){return Promise.reject(new Error("Unable to find git"))}}}(e);const i=process.hrtime(t);return ce.log(`Git found: ${Bt.version} @ ${"git"===Bt.path?"PATH":Bt.path} in ${1e3*i[0]+Math.floor(i[1]/1e6)} ms`),Bt}static async getVersionedFile(e,t,s){const o=await Ht.show(e,t,s,{encoding:"binary"});if(void 0===o)return;Ht.isStagedUncommitted(s)&&(s="");const a=w.truncate(w.sanitizeForFileSystem(Ht.isSha(s)?Ht.shortenSha(s):s),50,""),r=Ue.extname(t),n=await Promise.resolve().then(function(){var e=i(13);return"object"==typeof e&&e&&e.__esModule?e:Object.assign({},"object"==typeof e&&e,{default:e})});return new Promise((i,h)=>{n.file({prefix:`${Ue.basename(t,r)}-${a}__`,postfix:r},(a,r,n,c)=>{a?h(a):(ce.log(`getVersionedFile[${r}]('${e}', '${t}', ${s})`),Ne.appendFile(r,o,{encoding:"binary"},e=>{e?h(e):i(r)}))})})}static isResolveRequired(e){return Ht.isSha(e)&&!Ht.shaStrictRegex.test(e)}static isSha(e){return Ht.shaRegex.test(e)}static isStagedUncommitted(e){return void 0!==e&&Ht.stagedUncommittedRegex.test(e)}static isUncommitted(e){return void 0!==e&&Ht.uncommittedRegex.test(e)}static shortenSha(e,t={}){if(t=Object.assign({stagedUncommitted:"index",uncommitted:"",working:""},t),""===e)return t.working;if(Ht.isStagedUncommitted(e))return t.stagedUncommitted;if(Ht.isUncommitted(e))return t.uncommitted;const i=e.indexOf("^");if(i>6){const t=e.substring(i).substring(0,5);return`${e.substring(0,8-t.length)}${t}`}return e.substring(0,8)}static splitPath(e,t,i=!0){if(t){e=w.normalizePath(e);const i=((t=w.normalizePath(t)).endsWith("/")?t:`${t}/`).toLowerCase();e.toLowerCase().startsWith(i)&&(e=e.substring(i.length))}else t=w.normalizePath(i?Ue.dirname(e):t),e=w.normalizePath(i?Ue.basename(e):e);return[e,t]}static validateVersion(e,t){const[i,s]=Bt.version.split(".");return parseInt(i,10)>=e&&parseInt(s,10)>=t}static async blame(e,t,i,s={}){const[o,a]=Ht.splitPath(t,e),r=[...At];let n;return s.ignoreWhitespace&&r.push("-w"),null!=s.startLine&&null!=s.endLine&&r.push(`-L ${s.startLine},${s.endLine}`),i&&(Ht.isStagedUncommitted(i)?(r.push("--contents","-"),n=await Ht.show(e,t,":")):r.push(i)),Ot({cwd:a,stdin:n},...r,"--",o)}static async blame_contents(e,t,i,s={}){const[o,a]=Ht.splitPath(t,e),r=[...At];return s.ignoreWhitespace&&r.push("-w"),null!=s.startLine&&null!=s.endLine&&r.push(`-L ${s.startLine},${s.endLine}`),r.push("--contents","-"),Ot({cwd:a,stdin:i,correlationKey:s.correlationKey},...r,"--",o)}static branch(e,t={all:!1}){const i=["branch","-vv"];return t.all&&i.push("-a"),Ot({cwd:e},...i)}static checkout(e,t,i){const[s,o]=Ht.splitPath(t,e);return Ot({cwd:o},"checkout",i,"--",s)}static async config_get(e,t){try{return(await Mt({cwd:t||""},"config","--get",e)).trim()}catch(e){return}}static diff(e,t,i,s,o={}){const a=["diff","--diff-filter=M","-M","--no-ext-diff"];return i&&a.push(Ht.isStagedUncommitted(i)?"--staged":i),s&&a.push(Ht.isStagedUncommitted(s)?"--staged":s),Ot({cwd:e,encoding:"utf8"===o.encoding?"utf8":"binary"},...a,"--",t)}static diff_nameStatus(e,t,i,s={}){const o=["diff","--name-status","-M","--no-ext-diff"];return s&&s.filter&&o.push(`--diff-filter=${s.filter}`),t&&o.push(t),i&&o.push(i),Ot({cwd:e},...o)}static diff_shortstat(e,t){const i=["diff","--shortstat","--no-ext-diff"];return t&&i.push(t),Ot({cwd:e},...i)}static difftool_dirDiff(e,t,i,s){const o=["difftool","--dir-diff",`--tool=${t}`,i];return s&&o.push(s),Ot({cwd:e},...o)}static difftool_fileDiff(e,t,i,s){const o=["difftool","--no-prompt",`--tool=${i}`];return s&&o.push("--staged"),o.push("--",t),Ot({cwd:e},...o)}static log(e,t){const i=[...Nt,"--full-history","-m"];return t.maxCount&&!t.reverse&&i.push(`-n${t.maxCount}`),t.ref&&!Ht.isStagedUncommitted(t.ref)&&(t.reverse?i.push("--reverse","--ancestry-path",`${t.ref}..HEAD`):i.push(t.ref)),Ot({cwd:e},...i)}static log_file(e,t,i={renames:!0,reverse:!1}){const[s,o]=Ht.splitPath(t,e),a=[...Nt];return i.maxCount&&!i.reverse&&a.push(`-n${i.maxCount}`),i.renames&&a.push("--follow","-m","--first-parent"),i.ref&&!Ht.isStagedUncommitted(i.ref)&&(i.reverse?a.push("--reverse","--ancestry-path",`${i.ref}..HEAD`):a.push(i.ref)),null!=i.startLine&&null!=i.endLine&&a.push(`-L ${i.startLine},${i.endLine}:${s}`),a.push("--",s),Ot({cwd:o},...a)}static async log_recent(e,t){try{return(await Mt({cwd:e},"log","-M","-n1","--format=%H","--",t)).trim()}catch(e){return}}static async log_resolve(e,t,i){try{return(await Mt({cwd:e},"log","-M","-n1","--format=%H",i,"--",t)).trim()}catch(e){return}}static log_search(e,t=[],i={}){const s=[...Nt,"-m","-i"];return i.maxCount&&s.push(`-n${i.maxCount}`),Ot({cwd:e},...s,...t)}static log_shortstat(e,t){const i=["log","--shortstat","--oneline"];return t.ref&&!Ht.isStagedUncommitted(t.ref)&&i.push(t.ref),Ot({cwd:e},...i)}static async ls_files(e,t,i={}){const s=["ls-files"];i.ref&&!Ht.isStagedUncommitted(i.ref)&&s.push(`--with-tree=${i.ref}`);try{return(await Mt({cwd:e},...s,t)).trim()}catch(e){return""}}static merge_base(e,t,i,s={}){const o=["merge-base"];return s.forkPoint&&o.push("--fork-point"),Ot({cwd:e},...o,t,i)}static remote(e){return Ot({cwd:e},"remote","-v")}static remote_url(e,t){return Ot({cwd:e},"remote","get-url",t)}static async revparse(e,t){try{return(await Mt({cwd:e},"rev-parse",t)).trim()}catch(e){return}}static async revparse_currentBranch(e){const t=["rev-parse","--abbrev-ref","--symbolic-full-name","@","@{u}"],i={cwd:e};try{return await Mt(i,...t)}catch(e){const s=e&&e.toString();if(Lt.headNotABranch.test(s))return;const o=Lt.noUpstream.exec(s);if(null!==o)return o[1];if(Lt.unknownRevision.test(s))try{const t=["symbolic-ref","-q","--short","HEAD"];return await Mt(i,...t)}catch(e){return}return Wt(e,i,...t)}}static async revparse_toplevel(e){try{return(await Mt({cwd:e},"rev-parse","--show-toplevel")).trim()}catch(e){return}}static async show(e,t,i,s={}){const[o,a]=Ht.splitPath(t,e);if(Ht.isStagedUncommitted(i)&&(i=":"),Ht.isUncommitted(i))throw new Error(`sha=${i} is uncommitted`);const r={cwd:a,encoding:s.encoding||"utf8"},n=i.endsWith(":")?`${i}./${o}`:`${i}:./${o}`;try{return await Mt(r,"show",n)}catch(e){const t=e&&e.toString();if(Lt.notFound.test(t)||Lt.foundButNotInRevision.test(t))return;return Wt(e,r,n)}}static stash_apply(e,t,i){if(t)return Ot({cwd:e},"stash",i?"pop":"apply",t)}static stash_delete(e,t){if(t)return Ot({cwd:e},"stash","drop",t)}static stash_list(e){return Ot({cwd:e},...Ut)}static stash_push(e,t,i){const s=["stash","push","-u"];return i&&s.push("-m",i),s.splice(s.length,0,"--",...t),Ot({cwd:e},...s)}static stash_save(e,t){const i=["stash","save","-u"];return t&&i.push(t),Ot({cwd:e},...i)}static status(e,t=1){const i=t>=2?`--porcelain=v${t}`:"--porcelain";return Ot({cwd:e,env:Object.assign({},process.env,{GIT_OPTIONAL_LOCKS:"0"})},"status",i,"--branch","-u")}static status_file(e,t,i=1){const[s,o]=Ht.splitPath(t,e),a=i>=2?`--porcelain=v${i}`:"--porcelain";return Ot({cwd:o,env:Object.assign({},process.env,{GIT_OPTIONAL_LOCKS:"0"})},"status",a,s)}static tag(e){return Ot({cwd:e},...["tag","-l"])}}Ht.shaRegex=/^[0-9a-f]{40}(\^[0-9]*?)??( -)?$/,Ht.shaStrictRegex=/^[0-9a-f]{40}$/,Ht.stagedUncommittedRegex=/^[0]{40}(\^[0-9]*?)??:$/,Ht.stagedUncommittedSha="0000000000000000000000000000000000000000:",Ht.uncommittedRegex=/^[0]{40}(\^[0-9]*?)??:??$/,Ht.uncommittedSha="0000000000000000000000000000000000000000";class jt{constructor(e,t){this.collapsableWhitespace=0,this.reset(e,t)}reset(e,t){this._item=e,void 0===t&&void 0!==this._options||(void 0===t&&(t={}),null==t.dateFormat&&(t.dateFormat="MMMM Do, YYYY h:mma"),null==t.tokenOptions&&(t.tokenOptions={}),this._options=t)}_padOrTruncate(e,t){void 0===t&&(t={truncateTo:void 0,padDirection:"left",collapseWhitespace:!1});let i=t.truncateTo;const s=w.width(e);if(void 0===i){if(0===this.collapsableWhitespace)return e;const i=this.collapsableWhitespace-s;return this.collapsableWhitespace=0,i<=0?e:void 0===t.truncateTo?e:w.padLeft(e,i)}i+=this.collapsableWhitespace,this.collapsableWhitespace=0;const o=i-s;return o>0?(t.collapseWhitespace&&(this.collapsableWhitespace=o),"left"===t.padDirection?w.padLeft(e,i):(t.collapseWhitespace&&(i-=o),w.padRight(e,i))):o<0?w.truncate(e,i):e}static fromTemplateCore(e,t,i,s){if(e instanceof jt)return w.interpolate(t,e);let o=void 0;return o=null==s||"string"==typeof s?{dateFormat:s,tokenOptions:w.getTokensFromTemplate(t).reduce((e,t)=>(e[t.key]=t.options,e),{})}:s,void 0===this._formatter?this._formatter=new e(i,o):this._formatter.reset(i,o),w.interpolate(t,this._formatter)}}jt._formatter=void 0;class Gt extends jt{get ago(){const e=this._item.fromNow();return this._padOrTruncate(e,this._options.tokenOptions.ago)}get author(){const e=this._item.author;return this._padOrTruncate(e,this._options.tokenOptions.author)}get authorAgo(){const e=`${this._item.author}, ${this._item.fromNow()}`;return this._padOrTruncate(e,this._options.tokenOptions.authorAgo)}get date(){const e=this._item.formatDate(this._options.dateFormat);return this._padOrTruncate(e,this._options.tokenOptions.date)}get id(){return this._item.isUncommitted&&!this._item.isStagedUncommitted?"00000000":this._item.shortSha}get message(){let e=this._item.isUncommitted?"Uncommitted change":this._item.message;return this._options.truncateMessageAtNewLine&&(e=this._item.getShortMessage()),this._padOrTruncate(e,this._options.tokenOptions.message)}get sha(){return this.id}static fromTemplate(e,t,i){return super.fromTemplateCore(this,e,t,i)}}class Vt extends jt{get directory(){const e=dt.getFormattedDirectory(this._item,!1,this._options.relativePath);return this._padOrTruncate(e,this._options.tokenOptions.file)}get file(){const e=Ue.basename(this._item.fileName);return this._padOrTruncate(e,this._options.tokenOptions.file)}get filePath(){const e=dt.getFormattedPath(this._item,void 0,this._options.relativePath);return this._padOrTruncate(e,this._options.tokenOptions.filePath)}get path(){const e=dt.getRelativePath(this._item,this._options.relativePath);return this._padOrTruncate(e,this._options.tokenOptions.file)}get working(){const e=this._item.commit;return void 0!==e&&e.isUncommitted?`${K.Pensil} ${K.Space}`:""}static fromTemplate(e,t,i){return super.fromTemplateCore(this,e,t,i)}}var Qt,Kt,qt,zt,Yt,Xt,Jt,Zt,ei,ti;(Kt=Qt||(Qt={})).Author="author",Kt.ChangedOccurrences="changed-occurrences",Kt.Changes="changes",Kt.Files="files",Kt.Message="message",Kt.Sha="sha";class ii extends N.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeRepositories=new N.EventEmitter,this._suspended=!1,this._repositoryTree=v.forPaths(),this._trackedCache=new Map,this._versionedUriCache=new Map,this._disposable=N.Disposable.from(N.window.onDidChangeWindowState(this.onWindowStateChanged,this),N.workspace.onDidChangeWorkspaceFolders(this.onWorkspaceFoldersChanged,this),ua.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(ua.initializingChangeEvent),this._repositoriesLoadingPromise=this.onWorkspaceFoldersChanged()}get onDidChangeRepositories(){return this._onDidChangeRepositories.event}dispose(){this._repositoryTree.forEach(e=>e.dispose()),this._trackedCache.clear(),this._versionedUriCache.clear(),this._disposable&&this._disposable.dispose()}get UseCaching(){return la.config.advanced.caching.enabled}onAnyRepositoryChanged(e){this._trackedCache.clear()}onConfigurationChanged(e){(ua.initializing(e)||ua.changed(e,ua.name("defaultDateStyle").value)||ua.changed(e,ua.name("defaultDateFormat").value))&&Ke.reset()}onWindowStateChanged(e){e.focused?this._repositoryTree.forEach(e=>e.resume()):this._repositoryTree.forEach(e=>e.suspend()),this._suspended=!e.focused}async onWorkspaceFoldersChanged(e){let t=!1;void 0===e&&(t=!0,e={added:N.workspace.workspaceFolders||[],removed:[]},ce.log(`Starting repository search in ${e.added.length} folders`));for(const t of e.added){if(t.uri.scheme!==V.File)continue;const e=await this.repositorySearch(t);for(const t of e)this._repositoryTree.set(t.path,t)}for(const t of e.removed){if(t.uri.scheme!==V.File)continue;const e=t.uri.fsPath,i=this._repositoryTree.findSuperstr(e),s=void 0!==i?[...u.map(i.entries(),([t,i])=>[t,Ue.join(e,i)])]:[],o=this._repositoryTree.get(e);void 0!==o&&s.push([o,e]);for(const[e,t]of s)this._repositoryTree.delete(t),e.dispose()}await this.updateContext(this._repositoryTree),t||setImmediate(()=>this.fireRepositoriesChanged())}async repositorySearch(e){const t=e.uri,i=ua.get(ua.name("advanced")("repositorySearchDepth").value,t);ce.log(`Searching for repositories (depth=${i}) in '${t.fsPath}' ...`);const o=process.hrtime(),a=[],r=this.onAnyRepositoryChanged.bind(this),n=await this.getRepoPathCore(t.fsPath,!0);if(void 0!==n&&(ce.log(`Repository found in '${n}'`),a.push(new ct(e,n,!0,r,this._suspended))),i<=0){const e=process.hrtime(o);return ce.log(`Searching for repositories (depth=${i}) in '${t.fsPath}' took ${1e3*e[0]+Math.floor(e[1]/1e6)} ms`),a}let h=Object.assign({},N.workspace.getConfiguration("files",t).get("exclude",{}),N.workspace.getConfiguration("search",t).get("exclude",{}));h=[...u.filterMap(s.entries(h),([e,t])=>{if(t)return e.startsWith("**/")?e.substring(3):e})].reduce((e,t)=>(e[t]=!0,e),Object.create(null));const c=await this.repositorySearchCore(t.fsPath,i,h);for(let t of c){if(t=Ue.dirname(t),w.normalizePath(t)===n)continue;const i=await this.getRepoPathCore(t,!0);void 0!==i&&(ce.log(`Repository found in '${i}'`),a.push(new ct(e,i,!1,r,this._suspended)))}const l=process.hrtime(o);return ce.log(`Searching for repositories (depth=${i}) in '${t.fsPath}' took ${1e3*l[0]+Math.floor(l[1]/1e6)} ms`),a}async repositorySearchCore(e,t,i,s=[]){return new Promise((o,a)=>{Ne.readdir(e,async(r,n)=>{if(null!=r)return void a(r);if(0===n.length)return void o(s);const h=[],c=n.map(t=>{const o=Ue.resolve(e,t);return new Promise((e,a)=>{Ne.stat(o,(a,r)=>{".git"===t?s.push(o):null==a&&!0!==i[t]&&null!=r&&r.isDirectory()&&h.push(o),e()})})});if(await Promise.all(c),t-- >0)for(const e of h)await this.repositorySearchCore(e,t,i,s);o(s)})})}async updateContext(e){const t=e.any();await J(j.Enabled,t);let i=!1;if(t)for(const t of e.values())if(i=await t.hasRemotes())break;if(await J(j.HasRemotes,i),!t){const e=N.workspace.createFileSystemWatcher("**/.git",!1,!0,!0),t=N.Disposable.from(e,e.onDidCreate(async e=>{const i=N.workspace.getWorkspaceFolder(e);if(void 0===i)return;const s=await this.repositorySearch(i);if(0!==s.length){t.dispose();for(const e of s)this._repositoryTree.set(e.path,e);await this.updateContext(this._repositoryTree),setImmediate(()=>this.fireRepositoriesChanged())}},this))}}fireRepositoriesChanged(){this._onDidChangeRepositories.fire()}checkoutFile(e,t){return t=t||e.sha,ce.log(`checkoutFile('${e.repoPath}', '${e.fsPath}', '${t}')`),Ht.checkout(e.repoPath,e.fsPath,t)}async fileExists(e,t){return await new Promise((i,s)=>Ne.exists(Ue.resolve(e,t),i))}async findNextCommit(e,t,i){let s=await this.getLogForFile(e,t,{maxCount:1,ref:i,renames:!0,reverse:!0}),o=s&&u.first(s.commits.values());if(o)return o;const a=await this.findNextFileName(e,t,i);return a&&(o=(s=await this.getLogForFile(e,a,{maxCount:1,ref:i,renames:!0,reverse:!0}))&&u.first(s.commits.values())),o}async findNextFileName(e,t,i){return[t,e]=Ht.splitPath(t,e),await this.fileExists(e,t)?t:await this.findNextFileNameCore(e,t,i)}async findNextFileNameCore(e,t,i){if(void 0===i&&void 0===(i=await this.getRecentShaForFile(e,t)))return;const s=await this.getLog(e,{maxCount:1,ref:i});if(void 0===s)return;const o=u.first(s.commits.values()).fileStatuses.find(e=>e.originalFileName===t);return void 0!==o?o.fileName:void 0}async findWorkingFileName(e,t,i){let s;if("string"==typeof e)s=e,void 0===t?(t=await this.getRepoPath(s,{ref:i}),[s,t]=Ht.splitPath(s,t)):s=w.normalizePath(Ue.relative(t,s));else{const i=e;if(t=i.repoPath,i.workingFileName&&await this.fileExists(t,i.workingFileName))return[i.workingFileName,t];s=i.fileName}for(;;){if(await this.fileExists(t,s))return[s,t];if(void 0===(s=await this.findNextFileNameCore(t,s)))return[void 0,void 0]}}async getActiveRepoPath(e){if(void 0===e){const e=this.getHighlanderRepoPath();if(void 0!==e)return e}if(void 0===(e=e||N.window.activeTextEditor))return;const t=await la.tracker.getOrAdd(e.document.uri);return void 0!==t?t.uri.repoPath:void 0}getHighlanderRepoPath(){const e=this._repositoryTree.highlander();if(void 0===e)return;const[t]=e;return t.path}async getBlameForFile(e){let t="blame";void 0!==e.sha&&(t+=`:${e.sha}`);const i=await la.tracker.getOrAdd(e);if(this.UseCaching){if(void 0!==i.state){const s=i.state.get(t);if(void 0!==s)return ce.log(`getBlameForFile[Cached(${t})]('${e.repoPath}', '${e.fsPath}', '${e.sha}')`),s.item}ce.log(`getBlameForFile[Not Cached(${t})]('${e.repoPath}', '${e.fsPath}', '${e.sha}')`),void 0===i.state&&(i.state=new de(i.key))}else ce.log(`getBlameForFile('${e.repoPath}', '${e.fsPath}', '${e.sha}')`);const s=this.getBlameForFileCore(e,i,t);return void 0!==i.state&&(ce.log(`Add blame cache for '${i.state.key}:${t}'`),i.state.set(t,{item:s})),s}async getBlameForFileCore(e,t,i){if(!await this.isTracked(e))return ce.log(`Skipping blame; '${e.fsPath}' is not tracked`),ii.emptyPromise;const[s,o]=Ht.splitPath(e.fsPath,e.repoPath,!1);try{const a=await Ht.blame(o,s,e.sha,{ignoreWhitespace:la.config.blame.ignoreWhitespace});return vt.parse(a,o,s)}catch(e){if(void 0!==t.state){const s=e&&e.toString();return ce.log(`Replace blame cache with empty promise for '${t.state.key}:${i}'`),t.state.set(i,{item:ii.emptyPromise,errorMessage:s}),t.setBlameFailure(),ii.emptyPromise}return}}async getBlameForFileContents(e,t){const i=`blame:${w.sha1(t)}`,s=await la.tracker.getOrAdd(e);if(this.UseCaching){if(void 0!==s.state){const t=s.state.get(i);if(void 0!==t)return ce.log(`getBlameForFileContents[Cached(${i})]('${e.repoPath}', '${e.fsPath}', '${e.sha}')`),t.item}ce.log(`getBlameForFileContents[Not Cached(${i})]('${e.repoPath}', '${e.fsPath}', '${e.sha}')`),void 0===s.state&&(s.state=new de(s.key))}else ce.log(`getBlameForFileContents('${e.repoPath}', '${e.fsPath}', '${e.sha}')`);const o=this.getBlameForFileContentsCore(e,t,s,i);return void 0!==s.state&&(ce.log(`Add blame cache for '${s.state.key}:${i}'`),s.state.set(i,{item:o})),o}async getBlameForFileContentsCore(e,t,i,s){if(!await this.isTracked(e))return ce.log(`Skipping blame; '${e.fsPath}' is not tracked`),ii.emptyPromise;const[o,a]=Ht.splitPath(e.fsPath,e.repoPath,!1);try{const r=await Ht.blame_contents(a,o,t,{correlationKey:`:${s}`,ignoreWhitespace:la.config.blame.ignoreWhitespace});return vt.parse(r,a,o)}catch(e){if(void 0!==i.state){const t=e&&e.toString();return ce.log(`Replace blame cache with empty promise for '${i.state.key}:${s}'`),i.state.set(s,{item:ii.emptyPromise,errorMessage:t}),i.setBlameFailure(),ii.emptyPromise}return}}async getBlameForLine(e,t,i={}){if(ce.log(`getBlameForLine('${e.repoPath}', '${e.fsPath}', '${e.sha}', ${t})`),!i.skipCache&&this.UseCaching){const i=await this.getBlameForFile(e);if(void 0===i)return;let s=i.lines[t];if(void 0===s){if(i.lines.length!==t)return;s=i.lines[t-1]}const o=i.commits.get(s.sha);if(void 0===o)return;return{author:Object.assign({},i.authors.get(o.author),{lineCount:o.lines.length}),commit:o,line:s}}const s=t+1,o=e.fsPath;try{const i=await Ht.blame(e.repoPath,o,e.sha,{ignoreWhitespace:la.config.blame.ignoreWhitespace,startLine:s,endLine:s}),a=vt.parse(i,e.repoPath,o);if(void 0===a)return;return{author:u.first(a.authors.values()),commit:u.first(a.commits.values()),line:a.lines[t]}}catch(e){return}}async getBlameForLineContents(e,t,i,s={}){if(ce.log(`getBlameForLineContents('${e.repoPath}', '${e.fsPath}', ${t})`),!s.skipCache&&this.UseCaching){const s=await this.getBlameForFileContents(e,i);if(void 0===s)return;let o=s.lines[t];if(void 0===o){if(s.lines.length!==t)return;o=s.lines[t-1]}const a=s.commits.get(o.sha);if(void 0===a)return;return{author:Object.assign({},s.authors.get(a.author),{lineCount:a.lines.length}),commit:a,line:o}}const o=t+1,a=e.fsPath;try{const s=await Ht.blame_contents(e.repoPath,a,i,{ignoreWhitespace:la.config.blame.ignoreWhitespace,startLine:o,endLine:o}),r=vt.parse(s,e.repoPath,a);if(void 0===r)return;return{author:u.first(r.authors.values()),commit:u.first(r.commits.values()),line:r.lines[t]}}catch(e){return}}async getBlameForRange(e,t){ce.log(`getBlameForRange('${e.repoPath}', '${e.fsPath}', '${e.sha}', [${t.start.line}, ${t.end.line}])`);const i=await this.getBlameForFile(e);if(void 0!==i)return this.getBlameForRangeSync(i,e,t)}getBlameForRangeSync(e,t,i){if(ce.log(`getBlameForRangeSync('${t.repoPath}', '${t.fsPath}', '${t.sha}', [${i.start.line}, ${i.end.line}])`),0===e.lines.length)return Object.assign({allLines:e.lines},e);if(0===i.start.line&&i.end.line===e.lines.length-1)return Object.assign({allLines:e.lines},e);const s=e.lines.slice(i.start.line,i.end.line+1),o=new Set(s.map(e=>e.sha)),a=new Map,r=new Map;for(const t of e.commits.values()){if(!o.has(t.sha))continue;const e=t.with({lines:t.lines.filter(e=>e.line>=i.start.line&&e.line<=i.end.line)});r.set(t.sha,e);let s=a.get(e.author);void 0===s&&(s={name:e.author,lineCount:0},a.set(s.name,s)),s.lineCount+=e.lines.length}return{authors:new Map([...a.entries()].sort((e,t)=>t[1].lineCount-e[1].lineCount)),commits:r,lines:s,allLines:e.lines}}async getBranch(e){if(void 0===e)return;ce.log(`getBranch('${e}')`);const t=await Ht.revparse_currentBranch(e);if(void 0===t)return;const i=t.split("\n");return new Ye(e,i[0],!0,i[1])}async getBranches(e){if(void 0===e)return[];ce.log(`getBranches('${e}')`);const t=await Ht.branch(e,{all:!0});if(""===t){const t=await this.getBranch(e);return void 0!==t?[t]:[]}return bt.parse(t,e)||[]}async getChangedFilesCount(e,t){ce.log(`getChangedFilesCount('${e}', '${t}')`);const i=await Ht.diff_shortstat(e,t);return et.parseShortStat(i)}async getConfig(e,t){return ce.log(`getConfig('${e}', '${t}')`),await Ht.config_get(e,t)}async getDiffForFile(e,t,i){void 0!==t&&void 0===i&&void 0!==e.sha&&(i=e.sha);let s="diff";void 0!==t&&(s+=`:${t}`),void 0!==i&&(s+=`:${i}`);const o=await la.tracker.getOrAdd(e);if(this.UseCaching){if(void 0!==o.state){const a=o.state.get(s);if(void 0!==a)return ce.log(`getDiffForFile[Cached(${s})]('${e.repoPath}', '${e.fsPath}', '${t}', '${i}')`),a.item}ce.log(`getDiffForFile[Not Cached(${s})]('${e.repoPath}', '${e.fsPath}', '${t}', '${i}')`),void 0===o.state&&(o.state=new de(o.key))}else ce.log(`getDiffForFile('${e.repoPath}', '${e.fsPath}', '${t}', '${i}')`);const a=this.getDiffForFileCore(e.repoPath,e.fsPath,t,i,{encoding:ii.getEncoding(e)},o,s);return void 0!==o.state&&(ce.log(`Add log cache for '${o.state.key}:${s}'`),o.state.set(s,{item:a})),a}async getDiffForFileCore(e,t,i,s,o,a,r){const[n,h]=Ht.splitPath(t,e,!1);try{const t=await Ht.diff(h,n,i,s,o);return et.parse(t)}catch(e){if(void 0!==a.state){const t=e&&e.toString();return ce.log(`Replace diff cache with empty promise for '${a.state.key}:${r}'`),a.state.set(r,{item:ii.emptyPromise,errorMessage:t}),ii.emptyPromise}return}}async getDiffForLine(e,t,i,s){ce.log(`getDiffForLine('${e.repoPath}', '${e.fsPath}', ${t}, '${i}', '${s}')`);try{const o=await this.getDiffForFile(e,i,s);if(void 0===o)return;const a=o.chunks.find(e=>e.currentPosition.start<=t&&e.currentPosition.end>=t);if(void 0===a)return;return a.lines[t-a.currentPosition.start+1]}catch(e){return}}async getDiffStatus(e,t,i,s={}){ce.log(`getDiffStatus('${e}', '${t}', '${i}', ${s.filter})`);try{const o=await Ht.diff_nameStatus(e,t,i,s);return et.parseNameStatus(o,e)}catch(e){return}}async getRecentLogCommitForFile(e,t){return this.getLogCommitForFile(e,t,void 0)}async getRecentShaForFile(e,t){return await Ht.log_recent(e,t)}async getLogCommit(e,t){ce.log(`getLogCommit('${e}', '${t}'`);const i=await this.getLog(e,{maxCount:2,ref:t});if(void 0!==i)return i.commits.get(t)}async getLogCommitForFile(e,t,i={}){ce.log(`getFileLogCommit('${e}', '${t}', '${i.ref}', ${i.firstIfNotFound})`);const s=await this.getLogForFile(e,t,{maxCount:2,ref:i.ref});if(void 0===s)return;const o=i.ref&&s.commits.get(i.ref);return void 0!==o||i.firstIfNotFound||!i.ref||Ht.isResolveRequired(i.ref)?o||u.first(s.commits.values()):void 0}async getLog(e,t={}){t=Object.assign({reverse:!1},t),ce.log(`getLog('${e}', '${t.ref}', ${t.maxCount}, ${t.reverse})`);const i=null==t.maxCount?la.config.advanced.maxListItems||0:t.maxCount;try{const s=await Ht.log(e,{maxCount:i,ref:t.ref,reverse:t.reverse}),o=St.parse(s,Ve.Branch,e,void 0,t.ref,i,t.reverse,void 0);if(void 0!==o){const i=Object.assign({},t);o.query=(t=>this.getLog(e,Object.assign({},i,{maxCount:t})))}return o}catch(e){return}}async getLogForSearch(e,t,i,s={}){ce.log(`getLogForSearch('${e}', '${t}', '${i}', ${s.maxCount})`);let o=null==s.maxCount?la.config.advanced.maxListItems||0:s.maxCount,a=void 0;switch(i){case Qt.Author:a=[`--author=${t}`];break;case Qt.ChangedOccurrences:a=[`-S${t}`,"--pickaxe-regex"];break;case Qt.Changes:a=[`-G${t}`];break;case Qt.Files:a=["--",`${t}`];break;case Qt.Message:a=[`--grep=${t}`];break;case Qt.Sha:a=[t],o=1}try{const r=await Ht.log_search(e,a,{maxCount:o}),n=St.parse(r,Ve.Branch,e,void 0,void 0,o,!1,void 0);if(void 0!==n){const o=Object.assign({},s);n.query=(s=>this.getLogForSearch(e,t,i,Object.assign({},o,{maxCount:s})))}return n}catch(e){return}}async getLogForFile(e,t,i={}){if(void 0!==e&&e===w.normalizePath(t))throw new Error(`File name cannot match the repository path; fileName=${t}`);void 0===(i=Object.assign({reverse:!1},i)).renames&&(i.renames=la.config.advanced.fileHistoryFollowsRenames);let s="log";void 0!==i.ref&&(s+=`:${i.ref}`),void 0!==i.maxCount&&(s+=`:n${i.maxCount}`),i.renames&&(s+=":follow");const o=await la.tracker.getOrAdd(new je(N.Uri.file(t),{repoPath:e,sha:i.ref}));if(this.UseCaching&&void 0===i.range&&!i.reverse){if(void 0!==o.state){const a=o.state.get(s);if(void 0!==a)return ce.log(`getLogForFile[Cached(${s})]('${e}', '${t}', '${i.ref}', ${i.maxCount}, undefined, ${i.renames}, ${i.reverse})`),a.item;if("log"!==s){const a=o.state.get("log");if(void 0!==a){if(void 0===i.ref)return ce.log(`getLogForFile[Cached(~${s})]('${e}', '${t}', '', ${i.maxCount}, undefined, ${i.renames}, ${i.reverse})`),a.item;ce.log(`getLogForFile[? Cache(${s})]('${e}', '${t}', '${i.ref}', ${i.maxCount}, undefined, ${i.renames}, ${i.reverse})`);const o=await a.item;if(void 0!==o&&o.commits.has(i.ref))return ce.log(`getLogForFile[Cached(${s})]('${e}', '${t}', '${i.ref}', ${i.maxCount}, undefined, ${i.renames}, ${i.reverse})`),a.item}}}ce.log(`getLogForFile[Not Cached(${s})]('${e}', '${t}', ${i.ref}, ${i.maxCount}, undefined, ${i.reverse})`),void 0===o.state&&(o.state=new de(o.key))}else ce.log(`getLogForFile('${e}', '${t}', ${i.ref}, ${i.maxCount}, ${i.range&&`[${i.range.start.line}, ${i.range.end.line}]`}, ${i.reverse})`);const a=this.getLogForFileCore(e,t,i,o,s);return void 0===o.state||void 0!==i.range||i.reverse||(ce.log(`Add log cache for '${o.state.key}:${s}'`),o.state.set(s,{item:a})),a}async getLogForFileCore(e,t,i,s,o){if(!await this.isTracked(t,e,{ref:i.ref}))return ce.log(`Skipping log; '${t}' is not tracked`),ii.emptyPromise;const[a,r]=Ht.splitPath(t,e,!1);try{const{range:n}=i,h=c.__rest(i,["range"]),l=null==i.maxCount?la.config.advanced.maxListItems||0:i.maxCount,d=await Ht.log_file(r,a,Object.assign({},h,{maxCount:l,startLine:n&&n.start.line+1,endLine:n&&n.end.line+1})),m=St.parse(d,Ve.File,r,a,h.ref,l,h.reverse,n);if(void 0!==m){const s=Object.assign({},i);m.query=(i=>this.getLogForFile(e,t,Object.assign({},s,{maxCount:i})))}return m}catch(e){if(void 0!==s.state&&void 0===i.range&&!i.reverse){const t=e&&e.toString();return ce.log(`Replace log cache with empty promise for '${s.state.key}:${o}'`),s.state.set(o,{item:ii.emptyPromise,errorMessage:t}),ii.emptyPromise}return}}async hasRemote(e){if(void 0===e)return!1;const t=await this.getRepository(e);return void 0!==t&&t.hasRemote()}async hasRemotes(e){if(void 0===e)return!1;const t=await this.getRepository(e);return void 0!==t&&t.hasRemotes()}async getMergeBase(e,t,i,s={}){try{const o=await Ht.merge_base(e,t,i,s);if(void 0===o)return;return o.split("\n")[0]}catch(e){return void ce.error(e,"GitService.getMergeBase")}}async getRemotes(e,t={}){if(void 0===e)return[];ce.log(`getRemotes('${e}')`);const i=await this.getRepository(e),s=void 0!==i?i.getRemotes():this.getRemotesCore(e);return t.includeAll?s:(await s).filter(e=>void 0!==e.provider)}async getRemotesCore(e,t){if(void 0===e)return[];ce.log(`getRemotesCore('${e}')`),t=t||Be.createMap(ua.get(ua.name("remotes").value,null));try{const i=await Ht.remote(e);return Ft.parse(i,e,Be.factory(t))}catch(e){return ce.error(e,"GitService.getRemotesCore"),[]}}async getRepoPath(e,t={}){if(void 0===e)return await this.getActiveRepoPath();if(e instanceof je)return e.repoPath;const i=await this.getRepository(e,Object.assign({},t,{skipCacheUpdate:!0}));if(void 0!==i)return i.path;if("string"!=typeof e){const t=await la.git.getVersionedUri(e);if(void 0!==t)return t.repoPath}const s=await this.getRepoPathCore("string"==typeof e?e:e.fsPath,!1);if(void 0===s)return;if(void 0!==this._repositoryTree.get(s))return s;const o=this._repositoryTree.findSubstr(s),a=void 0===o?N.workspace.getWorkspaceFolder(N.Uri.file(s)):o.folder;if(void 0!==a){const e=new ct(a,s,!1,this.onAnyRepositoryChanged.bind(this),this._suspended);this._repositoryTree.set(s,e),setImmediate(async()=>{await this.updateContext(this._repositoryTree),this.fireRepositoriesChanged()})}return s}async getRepoPathCore(e,t){try{return await Ht.revparse_toplevel(t?e:Ue.dirname(e))}catch(e){return void ce.error(e,"GitService.getRepoPathCore")}}async getRepositories(){return(await this.getRepositoryTree()).values()}async getRepositoryTree(){return void 0!==this._repositoriesLoadingPromise&&(await this._repositoriesLoadingPromise,this._repositoriesLoadingPromise=void 0),this._repositoryTree}async getRepository(e,t={}){const i=await this.getRepositoryTree();let s;if("string"==typeof e){const t=i.get(e);if(void 0!==t)return t;s=e}else if(e instanceof je){if(e.repoPath){const t=i.get(e.repoPath);if(void 0!==t)return t}s=e.fsPath}else s=e.fsPath;const o=i.findSubstr(s);if(void 0!==o&&await this.isTracked(s,o.path,t))return o}async getRepositoryCount(){return(await this.getRepositoryTree()).count()}async getStashList(e){if(void 0===e)return;ce.log(`getStashList('${e}')`);const t=await Ht.stash_list(e);return Pt.parse(t,e)}async getStatusForFile(e,t){ce.log(`getStatusForFile('${e}', '${t}')`);const i=Ht.validateVersion(2,11)?2:1,s=await Ht.status_file(e,t,i),o=Tt.parse(s,e,i);if(void 0!==o&&o.files.length)return o.files[0]}async getStatusForRepo(e){if(void 0===e)return;ce.log(`getStatusForRepo('${e}')`);const t=Ht.validateVersion(2,11)?2:1,i=await Ht.status(e,t);return Tt.parse(i,e,t)}async getTags(e){if(void 0===e)return[];ce.log(`getTags('${e}')`);const t=await Ht.tag(e);return Et.parse(t,e)||[]}async getVersionedFile(e,t,i){if(ce.log(`getVersionedFile('${e}', '${t}', '${i}')`),!i||Ht.isUncommitted(i)&&!Ht.isStagedUncommitted(i))return await this.fileExists(e,t)?t:void 0;const s=await Ht.getVersionedFile(e,t,i);return void 0!==s?(this._versionedUriCache.set(je.toKey(s),new je(N.Uri.file(t),{sha:i,repoPath:e,versionedPath:s})),s):void 0}getVersionedFileText(e,t,i){return ce.log(`getVersionedFileText('${e}', '${t}', ${i})`),Ht.show(e,t,i,{encoding:ii.getEncoding(e,t)})}getVersionedUri(e){return this._versionedUriCache.get(je.toKey(e))}isTrackable(e){let t;return(t="string"==typeof e?e:e.scheme)===V.File||t===V.Git||t===V.GitLensGit}async isTracked(e,t,i={}){if(i.ref===ii.deletedSha)return!1;let s,o,a=i.ref;if("string"==typeof e)[o,t]=Ht.splitPath(e,t),s=je.toKey(e);else{if(!this.isTrackable(e))return!1;o=e.fsPath,t=e.repoPath,a=e.sha,s=je.toKey(o)}void 0!==a&&(s+=`:${a}`),ce.log(`isTracked('${o}', '${t}', '${a}')`);let r=this._trackedCache.get(s);return void 0!==r?await r:(r=this.isTrackedCore(o,void 0===t?"":t,a),i.skipCacheUpdate?r:(this._trackedCache.set(s,r),r=await r,this._trackedCache.set(s,r),r))}async isTrackedCore(e,t,i){if(i===ii.deletedSha)return!1;try{let s=!!await Ht.ls_files(void 0===t?"":t,e);return s||void 0===i||(s=!!await Ht.ls_files(void 0===t?"":t,e,{ref:i}))||(s=!!await Ht.ls_files(void 0===t?"":t,e,{ref:`${i}^`})),s}catch(e){return ce.error(e,"GitService.isTrackedCore"),!1}}async getDiffTool(e){return await Ht.config_get("diff.guitool",e)||await Ht.config_get("diff.tool",e)}async openDiffTool(e,t,i,s){if(!s&&void 0===(s=await this.getDiffTool(e)))throw new Error("No diff tool found");return ce.log(`openDiffTool('${e}', '${t.fsPath}', ${i}, '${s}')`),Ht.difftool_fileDiff(e,t.fsPath,s,i)}async openDirectoryDiff(e,t,i,s){if(!s&&void 0===(s=await this.getDiffTool(e)))throw new Error("No diff tool found");return ce.log(`openDirectoryDiff('${e}', '${t}', '${i}', '${s}')`),Ht.difftool_dirDiff(e,s,t,i)}async resolveReference(e,t,i){return ii.isResolveRequired(t)?(ce.log(`resolveReference('${e}', '${t}', '${i&&i.toString()}')`),void 0===i?await Ht.revparse(e,t)||t:await Ht.log_resolve(e,w.normalizePath(Ue.relative(e,i.fsPath)),t)||t):t}stopWatchingFileSystem(){this._repositoryTree.forEach(e=>e.stopWatchingFileSystem())}stashApply(e,t,i=!1){return ce.log(`stashApply('${e}', '${t}', ${i})`),Ht.stash_apply(e,t,i)}stashDelete(e,t){return ce.log(`stashDelete('${e}', '${t}')`),Ht.stash_delete(e,t)}stashSave(e,t,i){if(ce.log(`stashSave('${e}', '${t}', ${i})`),void 0===i)return Ht.stash_save(e,t);const s=i.map(t=>Ht.splitPath(t.fsPath,e)[0]);return Ht.stash_push(e,s,t)}static getEncoding(e,t){const i="string"==typeof e?N.Uri.file(Ue.join(e,t)):e;return Ht.getEncoding(N.workspace.getConfiguration("files",i).get("encoding"))}static initialize(e){return Ht.getGitInfo(e)}static getGitPath(){return Ht.gitInfo().path}static getGitVersion(){return Ht.gitInfo().version}static isResolveRequired(e){return Ht.isResolveRequired(e)}static isSha(e){return Ht.isSha(e)}static isStagedUncommitted(e){return Ht.isStagedUncommitted(e)}static isUncommitted(e){return Ht.isUncommitted(e)}static shortenSha(e,t={}){if(void 0!==e)return t=Object.assign({deleted:"(deleted)",working:""},t),""===e?t.working:e===ii.deletedSha?t.deleted:Ht.isSha(e)||Ht.isStagedUncommitted(e)?Ht.shortenSha(e,t):e}static validateGitVersion(e,t){const[i,s]=this.getGitVersion().split(".");return parseInt(i,10)>=e&&parseInt(s,10)>=t}}ii.emptyPromise=Promise.resolve(void 0),ii.deletedSha="ffffffffffffffffffffffffffffffffffffffff",ii.stagedUncommittedSha=Ht.stagedUncommittedSha,ii.uncommittedSha=Ht.uncommittedSha,(zt=qt||(qt={})).ActiveEditorChanged="active-editor-changed",zt.AutoRefreshChanged="auto-refresh-changed",zt.Command="command",zt.ConfigurationChanged="configuration",zt.NodeCommand="node-command",zt.RepoChanged="repo-changed",zt.ViewChanged="view-changed",zt.VisibleEditorsChanged="visible-editors-changed",(Xt=Yt||(Yt={})).Branch="gitlens:branch",Xt.BranchWithTracking="gitlens:branch:tracking",Xt.Branches="gitlens:branches",Xt.BranchesWithRemotes="gitlens:branches:remotes",Xt.CurrentBranch="gitlens:branch:current",Xt.CurrentBranchWithTracking="gitlens:branch:current:tracking",Xt.RemoteBranch="gitlens:branch:remote",Xt.Commit="gitlens:commit",Xt.CommitOnCurrentBranch="gitlens:commit:current",Xt.CommitFile="gitlens:file:commit",Xt.Commits="gitlens:commits",Xt.ComparisonResults="gitlens:results:comparison",Xt.FileHistory="gitlens:history-file",Xt.Folder="gitlens:folder",Xt.History="gitlens:history",Xt.Message="gitlens:message",Xt.Pager="gitlens:pager",Xt.Remote="gitlens:remote",Xt.Remotes="gitlens:remotes",Xt.Repositories="gitlens:repositories",Xt.Repository="gitlens:repository",Xt.Results="gitlens:results",Xt.ResultsCommits="gitlens:results:commits",Xt.ResultsFiles="gitlens:results:files",Xt.SearchResults="gitlens:results:search",Xt.Stash="gitlens:stash",Xt.StashFile="gitlens:file:stash",Xt.Stashes="gitlens:stashes",Xt.Status="gitlens:status",Xt.StatusFile="gitlens:file:status",Xt.StatusFiles="gitlens:status:files",Xt.StatusFileCommits="gitlens:status:file-commits",Xt.StatusUpstream="gitlens:status:upstream",Xt.Tag="gitlens:tag",Xt.Tags="gitlens:tags";class si extends N.Disposable{constructor(e){super(()=>this.dispose()),this.uri=e,this.supportsPaging=!1}dispose(){void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0),this.resetChildren()}getCommand(){}refresh(){}resetChildren(){void 0!==this.children&&(this.children.forEach(e=>e.dispose()),this.children=void 0)}}class oi extends si{get repoPath(){return this.uri.repoPath}}class ai extends si{constructor(e){super(new je),this.message=e}getChildren(){return[]}getTreeItem(){const e=new N.TreeItem(this.message,N.TreeItemCollapsibleState.None);return e.contextValue=Yt.Message,e}}class ri extends si{constructor(e,t,i){super(new je),this.message=e,this.node=t,this.explorer=i,this.args={}}getChildren(){return[]}getTreeItem(){const e=new N.TreeItem(this.message,N.TreeItemCollapsibleState.None);return e.contextValue=Yt.Pager,e.command=this.getCommand(),e.iconPath={dark:la.context.asAbsolutePath("images/dark/icon-unfold.svg"),light:la.context.asAbsolutePath("images/light/icon-unfold.svg")},e}getCommand(){return{title:"Refresh",command:this.explorer.getQualifiedCommand("refreshNode"),arguments:[this.node,this.args]}}}class ni extends ri{constructor(e,t,i){super(`${e} ${K.Space}${K.Dash}${K.Space} this may take a while`,t,i),this.args={maxCount:0}}}class hi extends si{constructor(e,t,i,s,o){super(je.fromRepoPath(e)),this.repoPath=e,this.branchFolderName=t,this.relativePath=i,this.root=s,this.explorer=o}async getChildren(){if(void 0===this.root.descendants||void 0===this.root.children)return[];const e=[];for(const t of s.values(this.root.children))void 0!==t.value?e.push(t.value):e.push(new hi(this.repoPath,t.name,t.relativePath,t,this.explorer));return e}async getTreeItem(){const e=new N.TreeItem(this.label,N.TreeItemCollapsibleState.Collapsed);return e.contextValue=Yt.Folder,e.resourceUri=this.explorer.folderResourceUri,e}get label(){return this.branchFolderName}}(Zt=Jt||(Jt={}))[Zt.CommitLabel=1]="CommitLabel",Zt[Zt.FileLabel=2]="FileLabel",Zt[Zt.CommitIcon=4]="CommitIcon",Zt[Zt.StatusIcon=8]="StatusIcon",Zt[Zt.Gravatar=16]="Gravatar",Zt[Zt.File=10]="File";class ci extends si{constructor(e,t,i,s){super(je.fromFileStatus(e,t.repoPath,t.sha)),this.status=e,this.commit=t,this.explorer=i,this.displayAs=s,this.priority=!1,this.repoPath=t.repoPath}async getChildren(){return[]}async getTreeItem(){if(!this.commit.isFile){const e=this.commit.toFileCommit(this.status);if(void 0===e){const e=await la.git.getLogForFile(this.repoPath,this.status.fileName,{maxCount:2,ref:this.commit.sha});void 0!==e&&(this.commit=e.commits.get(this.commit.sha)||this.commit)}else this.commit=e}const e=new N.TreeItem(this.label,N.TreeItemCollapsibleState.None);if(e.contextValue=this.resourceType,(this.displayAs&Jt.CommitIcon)===Jt.CommitIcon)e.iconPath={dark:la.context.asAbsolutePath(Ue.join("images","dark","icon-commit.svg")),light:la.context.asAbsolutePath(Ue.join("images","light","icon-commit.svg"))};else if((this.displayAs&Jt.StatusIcon)===Jt.StatusIcon){const t=pt(this.status.status);e.iconPath={dark:la.context.asAbsolutePath(Ue.join("images","dark",t)),light:la.context.asAbsolutePath(Ue.join("images","light",t))}}else(this.displayAs&Jt.Gravatar)===Jt.Gravatar&&(e.iconPath=this.commit.getGravatarUri(la.config.defaultGravatarsStyle));return e.command=this.getCommand(),this._label=void 0,e}get folderName(){return void 0===this._folderName&&(this._folderName=Ue.dirname(this.uri.getRelativePath())),this._folderName}get label(){return void 0===this._label&&(this._label=this.displayAs&Jt.CommitLabel?Gt.fromTemplate(this.getCommitTemplate(),this.commit,{truncateMessageAtNewLine:!0,dataFormat:la.config.defaultDateFormat}):Vt.fromTemplate(this.getCommitFileTemplate(),this.status,{relativePath:this.relativePath})),this._label}get relativePath(){return this._relativePath}set relativePath(e){this._relativePath=e,this._label=void 0}get resourceType(){return Yt.CommitFile}getCommitTemplate(){return this.explorer.config.commitFormat}getCommitFileTemplate(){return this.explorer.config.commitFileFormat}getCommand(){return{title:"Compare File with Previous Revision",command:ei.DiffWithPrevious,arguments:[je.fromFileStatus(this.status,this.commit.repoPath),{commit:this.commit,line:0,showOptions:{preserveFocus:!0,preview:!0}}]}}}class li extends si{constructor(e,t,i,s,o){super(je.fromRepoPath(e)),this.repoPath=e,this.folderName=t,this.relativePath=i,this.root=s,this.explorer=o,this.priority=!0}async getChildren(){if(void 0===this.root.descendants||void 0===this.root.children)return[];let e;if(li.getFileNesting(this.explorer.config.files,this.root.descendants,void 0===this.relativePath)!==k.List){e=[];for(const t of s.values(this.root.children))void 0!==t.value?(t.value.relativePath=this.root.relativePath,e.push(t.value)):e.push(new li(this.repoPath,t.name,t.relativePath,t,this.explorer))}else this.root.descendants.forEach(e=>e.relativePath=this.root.relativePath),e=this.root.descendants;return e.sort((e,t)=>(e instanceof li?-1:1)-(t instanceof li?-1:1)||(e.priority?-1:1)-(t.priority?-1:1)||e.label.localeCompare(t.label)),e}async getTreeItem(){const e=new N.TreeItem(this.label,N.TreeItemCollapsibleState.Collapsed);return e.contextValue=Yt.Folder,e.resourceUri=this.explorer.folderResourceUri,e}get label(){return this.folderName}static getFileNesting(e,t,i){const s=e.layout||k.Auto;if(s===k.Auto){if(i||e.compact){const i=e.threshold||5;if(t.length<=i)return k.List}return k.Tree}return s}}class di extends oi{constructor(e,t,i){super(e.toGitUri()),this.commit=e,this.explorer=t,this.branch=i}get ref(){return this.commit.sha}async getChildren(){const e=this.commit;let t=[...u.map(e.fileStatuses,t=>new ci(t,e.toFileCommit(t),this.explorer,Jt.File))];if(this.explorer.config.files.layout!==k.List){const e=o.makeHierarchical(t,e=>e.uri.getRelativePath().split("/"),(...e)=>w.normalizePath(Ue.join(...e)),this.explorer.config.files.compact),i=new li(this.repoPath,"",void 0,e,this.explorer);t=await i.getChildren()}else t.sort((e,t)=>e.label.localeCompare(t.label));return t}getTreeItem(){const e=new N.TreeItem(Gt.fromTemplate(this.explorer.config.commitFormat,this.commit,{truncateMessageAtNewLine:!0,dataFormat:la.config.defaultDateFormat}),N.TreeItemCollapsibleState.Collapsed);return e.contextValue=void 0===this.branch||this.branch.current?Yt.CommitOnCurrentBranch:Yt.Commit,this.explorer.config.avatars?e.iconPath=this.commit.getGravatarUri(la.config.defaultGravatarsStyle):e.iconPath={dark:la.context.asAbsolutePath("images/dark/icon-commit.svg"),light:la.context.asAbsolutePath("images/light/icon-commit.svg")},e}getCommand(){return{title:"Compare File with Previous Revision",command:ei.DiffWithPrevious,arguments:[this.uri,{commit:this.commit,line:0,showOptions:{preserveFocus:!0,preview:!0}}]}}}class mi extends oi{constructor(e,t,i){super(t),this.branch=e,this.explorer=i,this.supportsPaging=!0}get current(){return this.branch.current}get label(){const e=this.branch.getName();return this.explorer.config.branches.layout===F.List?e:Ye.isValid(e)&&!this.current?this.branch.getBasename():e}get ref(){return this.branch.name}async getChildren(){const e=await la.git.getLog(this.uri.repoPath,{maxCount:this.maxCount,ref:this.branch.name});if(void 0===e)return[new ai("No commits yet")];const t=[...u.map(e.commits.values(),e=>new di(e,this.explorer,this.branch))];return e.truncated&&t.push(new ni("Show All Commits",this,this.explorer)),t}async getTreeItem(){let e=this.label;!this.branch.remote&&void 0!==this.branch.tracking&&this.explorer.config.showTrackingBranch&&(e+=` ${K.Space}${K.ArrowLeftRight}${K.Space} ${this.branch.tracking}`);const t=new N.TreeItem(`${this.branch.current?`${K.Check} ${K.Space}`:""}${e}`,N.TreeItemCollapsibleState.Collapsed);this.branch.remote?t.contextValue=Yt.RemoteBranch:this.branch.current?t.contextValue=this.branch.tracking?Yt.CurrentBranchWithTracking:Yt.CurrentBranch:t.contextValue=this.branch.tracking?Yt.BranchWithTracking:Yt.Branch;let i="";return this.branch.tracking&&(this.branch.state.ahead&&this.branch.state.behind?i="-yellow":this.branch.state.ahead?i="-green":this.branch.state.behind&&(i="-red")),t.iconPath={dark:la.context.asAbsolutePath(`images/dark/icon-branch${i}.svg`),light:la.context.asAbsolutePath(`images/light/icon-branch${i}.svg`)},t}}class ui extends si{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}async getChildren(){const e=await this.repo.getBranches();if(void 0===e)return[];e.sort((e,t)=>(e.current?-1:1)-(t.current?-1:1)||e.name.localeCompare(t.name));const t=[...u.filterMap(e,e=>e.remote?void 0:new mi(e,this.uri,this.explorer))];if(this.explorer.config.branches.layout===F.List)return t;const i=t.length>0&&t[0].current?t.splice(0,1)[0]:void 0,s=o.makeHierarchical(t,e=>e.branch.isValid()?e.branch.getName().split("/"):[e.branch.name],(...e)=>e.join("/"),this.explorer.config.files.compact),a=new hi(this.repo.path,"",void 0,s,this.explorer),r=await a.getChildren();return void 0!==i&&r.splice(0,0,i),r}async getTreeItem(){const e=new N.TreeItem("Branches",this.active?N.TreeItemCollapsibleState.Expanded:N.TreeItemCollapsibleState.Collapsed),t=await this.repo.getRemotes();return e.contextValue=void 0!==t&&t.length>0?Yt.BranchesWithRemotes:Yt.Branches,e.iconPath={dark:la.context.asAbsolutePath("images/dark/icon-branch.svg"),light:la.context.asAbsolutePath("images/light/icon-branch.svg")},e}}class gi extends si{constructor(e,t,i,s){super(t),this.remote=e,this.repo=i,this.explorer=s}async getChildren(){const e=await this.repo.getBranches();if(void 0===e)return[];e.sort((e,t)=>e.name.localeCompare(t.name));const t=[...u.filterMap(e,e=>e.remote&&e.name.startsWith(this.remote.name)?new mi(e,this.uri,this.explorer):void 0)];if(this.explorer.config.branches.layout===F.List)return t;const i=o.makeHierarchical(t,e=>e.branch.isValid()?e.branch.getName().split("/"):[e.branch.name],(...e)=>e.join("/"),this.explorer.config.files.compact),s=new hi(this.repo.path,"",void 0,i,this.explorer);return await s.getChildren()}getTreeItem(){const e=this.remote.types.find(e=>e.type===st.Fetch),t=this.remote.types.find(e=>e.type===st.Push);let i;i=e&&t?K.ArrowLeftRight:e?K.ArrowLeft:t?K.ArrowRight:K.Dash;const s=`${this.remote.name} ${K.Space}${i}${K.Space} ${void 0!==this.remote.provider?this.remote.provider.name:this.remote.domain} ${K.Space}${K.Dot}${K.Space} ${this.remote.path}`,o=new N.TreeItem(s,N.TreeItemCollapsibleState.Collapsed);return o.contextValue=Yt.Remote,void 0!==this.remote.provider?o.iconPath={dark:la.context.asAbsolutePath(`images/dark/icon-${this.remote.provider.icon}.svg`),light:la.context.asAbsolutePath(`images/light/icon-${this.remote.provider.icon}.svg`)}:o.iconPath={dark:la.context.asAbsolutePath("images/dark/icon-remote.svg"),light:la.context.asAbsolutePath("images/light/icon-remote.svg")},o}}class pi extends si{constructor(e,t,i){super(e),this.repo=t,this.explorer=i}async getChildren(){const e=await this.repo.getRemotes();return void 0===e||0===e.length?[new ai("No remotes configured")]:(e.sort((e,t)=>e.name.localeCompare(t.name)),[...u.map(e,e=>new gi(e,this.uri,this.repo,this.explorer))])}getTreeItem(){const e=new N.TreeItem("Remotes",N.TreeItemCollapsibleState.Collapsed);return e.contextValue=Yt.Remotes,e.iconPath={dark:la.context.asAbsolutePath("images/dark/icon-remote.svg"),light:la.context.asAbsolutePath("images/light/icon-remote.svg")},e}}class fi extends si{constructor(e,t,i,s){super(je.fromFileStatus(t,e,"HEAD")),this.repoPath=e,this.status=t,this.commits=i,this.explorer=s}async getChildren(){return this.commits.map(e=>new ci(this.status,e,this.explorer,Jt.CommitLabel|(this.explorer.config.avatars?Jt.Gravatar:Jt.CommitIcon)))}async getTreeItem(){const e=new N.TreeItem(this.label,N.TreeItemCollapsibleState.Collapsed);e.contextValue=Yt.StatusFileCommits;const t=pt(this.status.status);return e.iconPath={dark:la.context.asAbsolutePath(Ue.join("images","dark",t)),light:la.context.asAbsolutePath(Ue.join("images","light",t))},1===this.commits.length&&this.commits[0].isUncommitted&&(e.collapsibleState=N.TreeItemCollapsibleState.None,e.contextValue=Yt.StatusFile,e.command=this.getCommand()),this._label=void 0,e}get folderName(){return void 0===this._folderName&&(this._folderName=Ue.dirname(this.uri.getRelativePath())),this._folderName}get label(){return void 0===this._label&&(this._label=Vt.fromTemplate(this.explorer.config.statusFileFormat,Object.assign({},this.status,{commit:this.commit}),{relativePath:this.relativePath})),this._label}get commit(){return this.commits[0]}get priority(){return this.commit.isUncommitted}get relativePath(){return this._relativePath}set relativePath(e){this._relativePath=e,this._label=void 0}getCommand(){return{title:"Compare File with Previous Revision",command:ei.DiffWithPrevious,arguments:[je.fromFileStatus(this.status,this.repoPath),{commit:this.commit,line:0,showOptions:{preserveFocus:!0,preview:!0}}]}}}class vi extends si{constructor(e,t,i,s=!1){super(je.fromRepoPath(e.repoPath)),this.status=e,this.range=t,this.explorer=i,this.active=s,this.supportsPaging=!0,this.repoPath=e.repoPath}get id(){return`gitlens:repository(${this.status.repoPath})${this.active?":active":""}:status:files`}async getChildren(){let e=[];const t=this.repoPath;let i;void 0!==this.range&&void 0!==(i=await la.git.getLog(t,{maxCount:this.maxCount,ref:this.range}))&&(e=Array.from(u.flatMap(i.commits.values(),e=>e.fileStatuses.map(t=>Object.assign({},t,{commit:e}))))),0!==this.status.files.length&&this.includeWorkingTree&&e.splice(0,0,...u.flatMap(this.status.files,e=>{if(void 0!==e.workTreeStatus&&void 0!==e.indexStatus){const i=new Date;return i.setMilliseconds(i.getMilliseconds()-1),[Object.assign({},e,{status:e.status,commit:new it(Ve.File,t,ii.uncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,ii.stagedUncommittedSha,e.fileName)}),Object.assign({},e,{status:e.status,commit:new it(Ve.File,t,ii.stagedUncommittedSha,"You",void 0,i,"",e.fileName,[e],e.status,e.originalFileName,"HEAD",e.fileName)})]}return void 0!==e.indexStatus?[Object.assign({},e,{status:e.status,commit:new it(Ve.File,t,ii.stagedUncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,"HEAD",e.fileName)})]:[Object.assign({},e,{status:e.status,commit:new it(Ve.File,t,ii.uncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,"HEAD",e.fileName)})]})),e.sort((e,t)=>t.commit.date.getTime()-e.commit.date.getTime());const a=o.groupBy(e,e=>e.fileName);let r=[...u.map(s.values(a),e=>new fi(t,e[e.length-1],e.map(e=>e.commit),this.explorer))];if(this.explorer.config.files.layout!==k.List){const e=o.makeHierarchical(r,e=>e.uri.getRelativePath().split("/"),(...e)=>w.normalizePath(Ue.join(...e)),this.explorer.config.files.compact),i=new li(t,"",void 0,e,this.explorer);r=await i.getChildren()}else r.sort((e,t)=>(e.priority?-1:1)-(t.priority?-1:1)||e.label.localeCompare(t.label));return void 0!==i&&i.truncated&&r.push(new ni("Show All Changes",this,this.explorer)),r}async getTreeItem(){let e=void 0!==this.status.files&&this.includeWorkingTree?this.status.files.length:0;if(void 0!==this.status.upstream){const t=await la.git.getChangedFilesCount(this.repoPath,`${this.status.upstream}...`);void 0!==t&&(e+=t.files)}const t=`${e} file${e>1?"s":""} changed`,i=new N.TreeItem(t,N.TreeItemCollapsibleState.Collapsed);return i.id=this.id,i.contextValue=Yt.StatusFiles,i.iconPath={dark:la.context.asAbsolutePath("images/dark/icon-diff.svg"),light:la.context.asAbsolutePath("images/light/icon-diff.svg")},i}get includeWorkingTree(){return this.explorer.config.includeWorkingTree}}class wi extends si{constructor(e,t,i,s=!1){super(je.fromRepoPath(e.repoPath)),this.status=e,this.direction=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.status.repoPath})${this.active?":active":""}:status:upstream`}async getChildren(){const e="ahead"===this.direction?`${this.status.upstream}..${this.status.branch}`:`${this.status.branch}..${this.status.upstream}`;let t=await la.git.getLog(this.uri.repoPath,{maxCount:0,ref:e});if(void 0===t)return[];if("ahead"!==this.direction)return[...u.map(t.commits.values(),e=>new di(e,this.explorer))];const i=Array.from(t.commits.values()),s=i[i.length-1];return void 0===s.previousSha&&void 0!==(t=await la.git.getLog(this.uri.repoPath,{maxCount:2,ref:s.sha}))&&(i[i.length-1]=u.first(t.commits.values())),[...u.map(i,e=>new di(e,this.explorer))]}async getTreeItem(){const e="ahead"===this.direction?`${this.status.state.ahead} commit${this.status.state.ahead>1?"s":""} (ahead of ${this.status.upstream})`:`${this.status.state.behind} commit${this.status.state.behind>1?"s":""} (behind ${this.status.upstream})`,t=new N.TreeItem(e,N.TreeItemCollapsibleState.Collapsed);return t.id=this.id,t.contextValue=Yt.StatusUpstream,t.iconPath={dark:la.context.asAbsolutePath(`images/dark/icon-${"ahead"===this.direction?"upload":"download"}.svg`),light:la.context.asAbsolutePath(`images/light/icon-${"ahead"===this.direction?"upload":"download"}.svg`)},t}}class Ci extends si{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}:status`}async getChildren(){this.resetChildren();const e=await this.repo.getStatus();if(void 0===e)return[];if(this.children=[],e.state.behind&&this.children.push(new wi(e,"behind",this.explorer,this.active)),e.state.ahead&&this.children.push(new wi(e,"ahead",this.explorer,this.active)),e.state.ahead||0!==e.files.length&&this.includeWorkingTree){const t=e.upstream?`${e.upstream}..${e.branch}`:void 0;this.children.push(new vi(e,t,this.explorer,this.active))}return this.children}async getTreeItem(){void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0);const e=await this.repo.getStatus();if(void 0===e)return new N.TreeItem("No repo status");this.explorer.autoRefresh&&this.includeWorkingTree&&(this.disposable=N.Disposable.from(this.explorer.onDidChangeAutoRefresh(this.onAutoRefreshChanged,this),this.repo.onDidChangeFileSystem(this.onFileSystemChanged,this),{dispose:()=>this.repo.stopWatchingFileSystem()}),this.repo.startWatchingFileSystem());let t=!1;const i=0!==e.files.length&&this.includeWorkingTree;let s,o="",a="";e.upstream?e.state.ahead||e.state.behind?(o=`${e.branch}${i?" has uncommitted changes and":""} is not up-to-date with ${e.upstream}`,t=!0,e.state.ahead&&e.state.behind?a="-yellow":e.state.ahead?a="-green":e.state.behind&&(a="-red")):o=`${e.branch}${i?" has uncommitted changes and":""} is up-to-date with ${e.upstream}`:o=`${e.branch} ${i?"has uncommitted changes":this.includeWorkingTree?"has no changes":"has nothing to commit"}`,s=t||i?this.active?N.TreeItemCollapsibleState.Expanded:N.TreeItemCollapsibleState.Collapsed:N.TreeItemCollapsibleState.None;const r=new N.TreeItem(o,s);return r.id=this.id,r.contextValue=Yt.Status,r.iconPath={dark:la.context.asAbsolutePath(`images/dark/icon-repo${a}.svg`),light:la.context.asAbsolutePath(`images/light/icon-repo${a}.svg`)},r}get includeWorkingTree(){return this.explorer.config.includeWorkingTree}onAutoRefreshChanged(){void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0)}async onFileSystemChanged(e){this.explorer.refreshNode(this)}}class bi extends ci{constructor(e,t,i){super(e,t,i,Jt.File)}get resourceType(){return Yt.StashFile}getCommitTemplate(){return this.explorer.config.stashFormat}getCommitFileTemplate(){return this.explorer.config.stashFileFormat}}class yi extends oi{constructor(e,t){super(e.toGitUri()),this.commit=e,this.explorer=t}get ref(){return this.commit.sha}async getChildren(){const e=this.commit.fileStatuses,t=await la.git.getLog(this.commit.repoPath,{maxCount:1,ref:`${this.commit.stashName}^3`});if(void 0!==t){const i=u.first(t.commits.values());void 0!==i&&0!==i.fileStatuses.length&&(i.fileStatuses.forEach(e=>e.status="?"),e.splice(e.length,0,...i.fileStatuses))}const i=e.map(e=>new bi(e,this.commit.toFileCommit(e),this.explorer));return i.sort((e,t)=>e.label.localeCompare(t.label)),i}getTreeItem(){const e=new N.TreeItem(Gt.fromTemplate(this.explorer.config.stashFormat,this.commit,{truncateMessageAtNewLine:!0,dataFormat:la.config.defaultDateFormat}),N.TreeItemCollapsibleState.Collapsed);return e.contextValue=Yt.Stash,e}}class xi extends si{constructor(e,t,i){super(e),this.repo=t,this.explorer=i}async getChildren(){const e=await this.repo.getStashList();return void 0===e?[new ai("No stashed changes")]:[...u.map(e.commits.values(),e=>new yi(e,this.explorer))]}getTreeItem(){const e=new N.TreeItem("Stashes",N.TreeItemCollapsibleState.Collapsed);return e.contextValue=Yt.Stashes,e.iconPath={dark:la.context.asAbsolutePath("images/dark/icon-stash.svg"),light:la.context.asAbsolutePath("images/light/icon-stash.svg")},e}}class Si extends oi{constructor(e,t,i){super(t),this.tag=e,this.explorer=i,this.supportsPaging=!0}get ref(){return this.tag.name}async getChildren(){const e=await la.git.getLog(this.uri.repoPath,{maxCount:this.maxCount,ref:this.tag.name});if(void 0===e)return[new ai("No commits yet")];const t=[...u.map(e.commits.values(),e=>new di(e,this.explorer))];return e.truncated&&t.push(new ni("Show All Commits",this,this.explorer)),t}async getTreeItem(){const e=new N.TreeItem(this.tag.name,N.TreeItemCollapsibleState.Collapsed);return e.contextValue=Yt.Tag,e}}class $i extends si{constructor(e,t,i){super(e),this.repo=t,this.explorer=i}async getChildren(){const e=await this.repo.getTags();return 0===e.length?[new ai("No tags yet")]:(e.sort((e,t)=>e.name.localeCompare(t.name)),[...e.map(e=>new Si(e,this.uri,this.explorer))])}async getTreeItem(){const e=new N.TreeItem("Tags",N.TreeItemCollapsibleState.Collapsed);return e.contextValue=Yt.Tags,e.iconPath={dark:la.context.asAbsolutePath("images/dark/icon-tag.svg"),light:la.context.asAbsolutePath("images/light/icon-tag.svg")},e}}class Di extends si{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}`}async getChildren(){return this.resetChildren(),this.updateSubscription(),this.children=[new Ci(this.uri,this.repo,this.explorer,this.active),new ui(this.uri,this.repo,this.explorer,this.active),new pi(this.uri,this.repo,this.explorer),new xi(this.uri,this.repo,this.explorer),new $i(this.uri,this.repo,this.explorer)],this.children}getTreeItem(){this.updateSubscription();const e=this.active?`Active Repository ${w.pad(K.Dash,1,1)} ${this.repo.formattedName||this.uri.repoPath}`:`${this.repo.formattedName||this.uri.repoPath}`,t=new N.TreeItem(e,this.active?N.TreeItemCollapsibleState.Expanded:N.TreeItemCollapsibleState.Collapsed);return t.id=this.id,t.contextValue=Yt.Repository,t}updateSubscription(){this.explorer.autoRefresh?this.disposable=this.disposable||N.Disposable.from(this.explorer.onDidChangeAutoRefresh(this.onAutoRefreshChanged,this),this.repo.onDidChange(this.onRepoChanged,this)):void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0)}onAutoRefreshChanged(){this.updateSubscription()}onRepoChanged(e){if(ce.log(`RepositoryNode.onRepoChanged(${e.changes.join()}); triggering node refresh`),void 0===this.children||e.changed(ot.Repository)||e.changed(ot.Config))this.explorer.refreshNode(this);else{if(e.changed(ot.Stashes)){const e=this.children.find(e=>e instanceof xi);void 0!==e&&this.explorer.refreshNode(e)}if(e.changed(ot.Remotes)){const e=this.children.find(e=>e instanceof pi);void 0!==e&&this.explorer.refreshNode(e)}if(e.changed(ot.Tags)){const e=this.children.find(e=>e instanceof $i);void 0!==e&&this.explorer.refreshNode(e)}}}}class Fi extends si{constructor(e){super(void 0),this.explorer=e,la.context.subscriptions.push(N.window.onDidChangeActiveTextEditor(m.debounce(this.onActiveEditorChanged,500),this)),this.onActiveEditorChanged(N.window.activeTextEditor)}dispose(){super.dispose(),void 0!==this._repositoryNode&&(this._repositoryNode.dispose(),this._repositoryNode=void 0)}get id(){return"gitlens:repository:active"}async onActiveEditorChanged(e){if(void 0!==e&&!ee(e))return;let t=!1;try{const i=await la.git.getActiveRepoPath(e);if(void 0===i)return void(void 0!==this._repositoryNode&&(t=!0,this._repositoryNode.dispose(),this._repositoryNode=void 0));if(void 0!==this._repositoryNode&&this._repositoryNode.repo.path===i)return;const s=await la.git.getRepository(i);if(void 0===s)return void(void 0!==this._repositoryNode&&(t=!0,this._repositoryNode.dispose(),this._repositoryNode=void 0));t=!0,void 0!==this._repositoryNode&&this._repositoryNode.dispose(),this._repositoryNode=new Di(je.fromRepoPath(s.path),s,this.explorer,!0)}finally{t&&this.explorer.refreshNode(this)}}async getChildren(){return void 0!==this._repositoryNode?this._repositoryNode.getChildren():[]}getTreeItem(){const e=void 0!==this._repositoryNode?this._repositoryNode.getTreeItem():new N.TreeItem("No active repository",N.TreeItemCollapsibleState.None);return e.id=this.id,e}}class ki extends si{constructor(e,t,i=Yt.Results){super(e.toGitUri()),this.commit=e,this.explorer=t,this.contextValue=i}async getChildren(){const e=await new di(this.commit,this.explorer).getChildren();return e.splice(0,0,new ai(Gt.fromTemplate("${message}",this.commit,{truncateMessageAtNewLine:!1}))),e}async getTreeItem(){const e=Gt.fromTemplate(`Commit \${sha} ${w.pad(K.Dash,1,1)} \${authorAgo}`,this.commit,la.config.defaultDateFormat),t=new N.TreeItem(e,N.TreeItemCollapsibleState.Expanded);return t.contextValue=this.contextValue,t}}class Pi extends si{constructor(e,t,i,s,o=Yt.ResultsCommits){super(je.fromRepoPath(e)),this.repoPath=e,this.labelFn=t,this.logFn=i,this.explorer=s,this.contextValue=o,this.supportsPaging=!0}async getChildren(){const e=await this.getLog();if(void 0===e)return[];const t=[...u.map(e.commits.values(),e=>new di(e,this.explorer))];return e.truncated&&t.push(new ni("Show All Results",this,this.explorer)),t}async getTreeItem(){const e=await this.getLog(),t=new N.TreeItem(await this.getLabel(),e&&e.count>0?N.TreeItemCollapsibleState.Expanded:N.TreeItemCollapsibleState.None);return t.contextValue=this.contextValue,t}refresh(){this._cache=void 0}async ensureCache(){if(void 0===this._cache){const e=await this.logFn(this.maxCount);this._cache={label:await this.labelFn(e),log:e}}return this._cache}async getLabel(){return(await this.ensureCache()).label}async getLog(){return(await this.ensureCache()).log}}class _i extends si{constructor(e,t,i,s,o){super(je.fromFileStatus(t,e)),this.repoPath=e,this.status=t,this.ref1=i,this.ref2=s,this.explorer=o}getChildren(){return[]}getTreeItem(){const e=new N.TreeItem(this.label,N.TreeItemCollapsibleState.None);e.contextValue=Yt.StatusFile;const t=pt(this.status.status);return e.iconPath={dark:la.context.asAbsolutePath(Ue.join("images","dark",t)),light:la.context.asAbsolutePath(Ue.join("images","light",t))},e.command=this.getCommand(),e}get folderName(){return void 0===this._folderName&&(this._folderName=Ue.dirname(this.uri.getRelativePath())),this._folderName}get label(){return void 0===this._label&&(this._label=Vt.fromTemplate(this.explorer.config.statusFileFormat,this.status,{relativePath:this.relativePath})),this._label}get relativePath(){return this._relativePath}set relativePath(e){this._relativePath=e,this._label=void 0}get priority(){return!1}getCommand(){return{title:"Open Changes",command:ei.DiffWith,arguments:[this.uri,{lhs:{sha:this.ref1,uri:this.uri},rhs:{sha:this.ref2,uri:"R"===this.status.status?je.fromFileStatus(this.status,this.uri.repoPath,this.ref2,!0):this.uri},repoPath:this.uri.repoPath,line:0,showOptions:{preserveFocus:!0,preview:!0}}]}}}class Ri extends si{constructor(e,t,i,s,o,a){super(je.fromRepoPath(e)),this.repoPath=e,this.ref1=t,this.ref2=i,this.labelFn=s,this.diffFn=o,this.explorer=a,this.supportsPaging=!0}async getChildren(){const e=await this.getDiff();if(void 0===e)return[];let t=[...u.map(e,e=>new _i(this.repoPath,e,this.ref1,this.ref2,this.explorer))];if(this.explorer.config.files.layout!==k.List){const e=o.makeHierarchical(t,e=>e.uri.getRelativePath().split("/"),(...e)=>w.normalizePath(Ue.join(...e)),this.explorer.config.files.compact),i=new li(this.repoPath,"",void 0,e,this.explorer);t=await i.getChildren()}else t.sort((e,t)=>(e.priority?-1:1)-(t.priority?-1:1)||e.label.localeCompare(t.label));return t}async getTreeItem(){const e=await this.getDiff(),t=new N.TreeItem(await this.getLabel(),e&&e.length>0?N.TreeItemCollapsibleState.Expanded:N.TreeItemCollapsibleState.None);return t.contextValue=Yt.ResultsFiles,t}refresh(){this._cache=void 0}async ensureCache(){if(void 0===this._cache){const e=await this.diffFn();this._cache={label:this.labelFn(e),diff:e}}return this._cache}async getLabel(){return(await this.ensureCache()).label}async getDiff(){return(await this.ensureCache()).diff}}class Ti extends si{constructor(e,t,i,s){super(je.fromRepoPath(e)),this.repoPath=e,this.ref1=t,this.ref2=i,this.explorer=s}async getChildren(){return this.resetChildren(),this.children=[new Pi(this.uri.repoPath,async e=>{const t=void 0!==e?e.count:0,i=void 0!==e&&e.truncated;return 1===t?"1 commit":`${0===t?"No":`${t}${i?"+":""}`} commits`},e=>la.git.getLog(this.uri.repoPath,{maxCount:e,ref:`${this.ref1.ref}...${this.ref2.ref||"HEAD"}`}),this.explorer),new Ri(this.uri.repoPath,this.ref1.ref,this.ref2.ref,e=>{const t=void 0!==e?e.length:0;return 1===t?"1 file changed":`${0===t?"No":t} files changed`},()=>la.git.getDiffStatus(this.uri.repoPath,this.ref1.ref,this.ref2.ref),this.explorer)],this.children}async getTreeItem(){let e="";if(await la.git.getRepositoryCount()>1){const t=await la.git.getRepository(this.uri.repoPath);e=` ${w.pad(K.Dash,1,1)} ${t&&t.formattedName||this.uri.repoPath}`}const t=new N.TreeItem(`Comparing ${this.ref1.label||ii.shortenSha(this.ref1.ref,{working:"Working Tree"})} to ${this.ref2.label||ii.shortenSha(this.ref2.ref,{working:"Working Tree"})}${e}`,N.TreeItemCollapsibleState.Expanded);return t.contextValue=Yt.ComparisonResults,t}}class Ei extends si{constructor(e,t,i){super(e),this.repo=t,this.explorer=i}async getChildren(){this.updateSubscription();const e=[],t=Jt.CommitLabel|(this.explorer.config.avatars?Jt.Gravatar:Jt.StatusIcon),i=await la.git.getStatusForFile(this.uri.repoPath,this.uri.fsPath);if(void 0!==i&&(void 0!==i.indexStatus||void 0!==i.workTreeStatus)){let s,o;void 0!==i.workTreeStatus?(s=ii.uncommittedSha,void 0!==i.indexStatus?o=ii.stagedUncommittedSha:"?"!==i.workTreeStatus&&(o="HEAD")):(s=ii.stagedUncommittedSha,o="HEAD");const a=new it(Ve.File,this.uri.repoPath,s,"You",void 0,new Date,"",i.fileName,[i],i.status,i.originalFileName,o,i.originalFileName||i.fileName);e.push(new ci(i,a,this.explorer,t))}const s=await la.git.getLogForFile(this.uri.repoPath,this.uri.fsPath,{ref:this.uri.sha});return void 0!==s&&e.push(...u.map(s.commits.values(),e=>new ci(e.fileStatuses[0],e,this.explorer,t))),0===e.length?[new ai("No file history")]:e}getTreeItem(){this.updateSubscription();const e=new N.TreeItem(`${this.uri.getFormattedPath()}`,N.TreeItemCollapsibleState.Expanded);return e.contextValue=Yt.FileHistory,e.iconPath={dark:la.context.asAbsolutePath("images/dark/icon-history.svg"),light:la.context.asAbsolutePath("images/light/icon-history.svg")},e}updateSubscription(){this.explorer.autoRefresh?this.disposable=this.disposable||N.Disposable.from(this.explorer.onDidChangeAutoRefresh(this.onAutoRefreshChanged,this),this.repo.onDidChange(this.onRepoChanged,this)):void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0)}onAutoRefreshChanged(){this.updateSubscription()}onRepoChanged(e){e.changed(ot.Repository)&&(ce.log(`RepositoryNode.onRepoChanged(${e.changes.join()}); triggering node refresh`),this.explorer.refreshNode(this))}}class Bi extends si{constructor(e,t,i){super(e),this.repo=t,this.explorer=i}async getChildren(){return this.resetChildren(),this.children=[new Ei(this.uri,this.repo,this.explorer)],this.children}getTreeItem(){const e=new N.TreeItem(`${this.uri.getFormattedPath()}`,N.TreeItemCollapsibleState.Expanded);return e.contextValue=Yt.History,e.iconPath={dark:la.context.asAbsolutePath("images/dark/icon-history.svg"),light:la.context.asAbsolutePath("images/light/icon-history.svg")},e}}class Ai extends si{constructor(e,t){super(void 0),this.repositories=e,this.explorer=t}async getChildren(){return this.resetChildren(),this.children=this.repositories.sort((e,t)=>e.index-t.index).map(e=>new Di(je.fromRepoPath(e.path),e,this.explorer)),this.children.length>1&&this.children.splice(0,0,new Fi(this.explorer)),this.children}getTreeItem(){const e=new N.TreeItem("Repositories",N.TreeItemCollapsibleState.Expanded);return e.contextValue=Yt.Repositories,e}}function Ni(e,t){return e instanceof N.Uri?e:void 0!==t&&void 0!==t.document?t.document.uri:void 0}function Ui(e){return"view"===e.type&&e.node.branch&&e.node.branch instanceof Ye}function Li(e){return"view"===e.type&&e.node.commit&&e.node.commit instanceof qe}function Oi(e){return"view"===e.type&&e.node.remote&&e.node.remote instanceof nt}function Ii(e){return void 0!==e&&void 0!==e.id&&(void 0!==e.handle||void 0!==e.label||void 0!==e.resourceStates)}function Mi(e){return void 0!==e&&void 0!==e.resourceUri}(ti=ei||(ei={})).ClearFileAnnotations="gitlens.clearFileAnnotations",ti.CloseUnchangedFiles="gitlens.closeUnchangedFiles",ti.ComputingFileAnnotations="gitlens.computingFileAnnotations",ti.CopyMessageToClipboard="gitlens.copyMessageToClipboard",ti.CopyShaToClipboard="gitlens.copyShaToClipboard",ti.DiffDirectory="gitlens.diffDirectory",ti.DiffHeadWithBranch="gitlens.diffHeadWithBranch",ti.DiffWorkingWithBranch="gitlens.diffWorkingWithBranch",ti.ExternalDiffAll="gitlens.externalDiffAll",ti.DiffWith="gitlens.diffWith",ti.DiffWithBranch="gitlens.diffWithBranch",ti.DiffWithNext="gitlens.diffWithNext",ti.DiffWithPrevious="gitlens.diffWithPrevious",ti.DiffLineWithPrevious="gitlens.diffLineWithPrevious",ti.DiffWithRevision="gitlens.diffWithRevision",ti.DiffWithWorking="gitlens.diffWithWorking",ti.DiffLineWithWorking="gitlens.diffLineWithWorking",ti.ExternalDiff="gitlens.externalDiff",ti.ExplorersOpenDirectoryDiff="gitlens.explorers.openDirectoryDiff",ti.ExplorersOpenDirectoryDiffWithWorking="gitlens.explorers.openDirectoryDiffWithWorking",ti.OpenChangedFiles="gitlens.openChangedFiles",ti.OpenBranchesInRemote="gitlens.openBranchesInRemote",ti.OpenBranchInRemote="gitlens.openBranchInRemote",ti.OpenCommitInRemote="gitlens.openCommitInRemote",ti.OpenFileInRemote="gitlens.openFileInRemote",ti.OpenFileRevision="gitlens.openFileRevision",ti.OpenInRemote="gitlens.openInRemote",ti.OpenRepoInRemote="gitlens.openRepoInRemote",ti.OpenWorkingFile="gitlens.openWorkingFile",ti.ResetSuppressedWarnings="gitlens.resetSuppressedWarnings",ti.ShowCommitSearch="gitlens.showCommitSearch",ti.ShowFileBlame="gitlens.showFileBlame",ti.ShowLastQuickPick="gitlens.showLastQuickPick",ti.ShowLineBlame="gitlens.showLineBlame",ti.ShowQuickCommitDetails="gitlens.showQuickCommitDetails",ti.ShowQuickCommitFileDetails="gitlens.showQuickCommitFileDetails",ti.ShowQuickFileHistory="gitlens.showQuickFileHistory",ti.ShowQuickBranchHistory="gitlens.showQuickBranchHistory",ti.ShowQuickCurrentBranchHistory="gitlens.showQuickRepoHistory",ti.ShowQuickRepoStatus="gitlens.showQuickRepoStatus",ti.ShowQuickStashList="gitlens.showQuickStashList",ti.ShowSettingsPage="gitlens.showSettingsPage",ti.ShowWelcomePage="gitlens.showWelcomePage",ti.StashApply="gitlens.stashApply",ti.StashDelete="gitlens.stashDelete",ti.StashSave="gitlens.stashSave",ti.ToggleCodeLens="gitlens.toggleCodeLens",ti.ToggleFileBlame="gitlens.toggleFileBlame",ti.ToggleFileHeatmap="gitlens.toggleFileHeatmap",ti.ToggleFileRecentChanges="gitlens.toggleFileRecentChanges",ti.ToggleLineBlame="gitlens.toggleLineBlame";class Wi extends N.Disposable{constructor(e){if(super(()=>this.dispose()),this.contextParsingOptions={editor:!1,uri:!1},"string"==typeof e)return void(this._disposable=N.commands.registerCommand(e,(...t)=>this._execute(e,...t),this));const t=e.map(e=>N.commands.registerCommand(e,(...t)=>this._execute(e,...t),this));this._disposable=N.Disposable.from(...t)}static getMarkdownCommandArgsCore(e,t){return`command:${e}?${encodeURIComponent(JSON.stringify(t))}`}dispose(){this._disposable&&this._disposable.dispose()}async preExecute(e,...t){return this.execute(...t)}_execute(e,...t){const[i,s]=Wi.parseContext(e,this.contextParsingOptions,...t);return this.preExecute(i,...s)}static parseContext(e,t,...i){let s=void 0,o=i[0];if(t.editor&&(void 0===o||function(e){return void 0!==e&&void 0!==e.id&&(void 0!==e.edit||void 0!==e.document)}(o))&&(s=o,o=(i=i.slice(1))[0]),t.uri&&(void 0===o||o instanceof N.Uri)){const[t,...o]=i;return[{command:e,type:"uri",editor:s,uri:t},o]}if(o instanceof si){const[t,...s]=i;return[{command:e,type:"view",node:t,uri:t.uri},s]}if(Mi(o)){const t=[];let s=0;for(const e of i){if(!Mi(e))break;s++,t.push(e)}return[{command:e,type:"scm-states",scmResourceStates:t,uri:t[0].resourceUri},i.slice(s)]}if(Ii(o)){const t=[];let s=0;for(const e of i){if(!Ii(e))break;s++,t.push(e)}return[{command:e,type:"scm-groups",scmResourceGroups:t},i.slice(s)]}return[{command:e,type:"unknown",editor:s},i]}}class Hi extends Wi{constructor(e){super(e),this.contextParsingOptions={editor:!0,uri:!0}}async preExecute(e,...t){return this.execute(e.editor,e.uri,...t)}_execute(e,...t){return super._execute(e,N.window.activeTextEditor,...t)}}let ji=void 0;class Gi extends Hi{constructor(e){super(e)}_execute(e,...t){return ji={command:e,args:t},super._execute(e,...t)}}class Vi extends N.Disposable{constructor(e){super(()=>this.dispose()),Array.isArray(e)||(e=[e]);const t=[];for(const i of e)t.push(N.commands.registerTextEditorCommand(i,(e,t,...s)=>this.executeCore(i,e,t,...s),this));this._disposable=N.Disposable.from(...t)}dispose(){this._disposable&&this._disposable.dispose()}executeCore(e,t,i,...s){return this.execute(t,i,...s)}}async function Qi(e,t={}){const{rethrow:i}=t,s=c.__rest(t,["rethrow"]);try{e instanceof je&&(e=e.fileUri({noSha:!0}));const t=await N.workspace.openTextDocument(e);return N.window.showTextDocument(t,Object.assign({preserveFocus:!1,preview:!0,viewColumn:N.ViewColumn.Active},s))}catch(e){if(i)throw e;return void ce.error(e,"openEditor")}}class Ki extends Vi{constructor(){super([ei.ClearFileAnnotations,ei.ComputingFileAnnotations])}async execute(e,t,i){if(void 0!==e){if(void 0!==i&&!oe.equals(i,e.document.uri)){const t=N.window.visibleTextEditors.find(e=>oe.equals(i,e.document.uri));void 0!==t&&(e=t)}try{return la.annotations.clear(e)}catch(e){return ce.error(e,"ClearFileAnnotationsCommand"),N.window.showErrorMessage("Unable to clear file annotations. See output channel for more details")}}}}class qi extends N.Disposable{constructor(){super(()=>this.dispose());const e=m.debounce(e=>this._resolver&&this._resolver(e),50);this._disposable=N.window.onDidChangeActiveTextEditor(e)}dispose(){this._disposable&&this._disposable.dispose()}async awaitClose(e=500){return this.close(),this.wait(e)}async awaitNext(e=500){return this.next(),this.wait(e)}async close(){return N.commands.executeCommand(W.CloseActiveEditor)}async next(){return N.commands.executeCommand(W.NextEditor)}async wait(e=500){const t=await new Promise((t,i)=>{let s;this._resolver=(e=>{s&&(clearTimeout(s),s=0,t(e))}),s=setTimeout(()=>{t(N.window.activeTextEditor),s=0},e)});return this._resolver=void 0,t}}var zi,Yi;(Yi=zi||(zi={})).CommitHasNoPreviousCommitWarning="suppressCommitHasNoPreviousCommitWarning",Yi.CommitNotFoundWarning="suppressCommitNotFoundWarning",Yi.FileNotUnderSourceControlWarning="suppressFileNotUnderSourceControlWarning",Yi.GitVersionWarning="suppressGitVersionWarning",Yi.LineUncommittedWarning="suppressLineUncommittedWarning",Yi.NoRepositoryWarning="suppressNoRepositoryWarning",Yi.ResultsExplorerNotice="suppressResultsExplorerNotice";class Xi{static showCommitHasNoPreviousCommitWarningMessage(e){return void 0===e?Xi.showMessage("info","Commit has no previous commit",zi.CommitHasNoPreviousCommitWarning):Xi.showMessage("info",`Commit ${e.shortSha} (${e.author}, ${e.formattedDate}) has no previous commit`,zi.CommitHasNoPreviousCommitWarning)}static showCommitNotFoundWarningMessage(e){return Xi.showMessage("warn",`${e}. The commit could not be found`,zi.CommitNotFoundWarning)}static showFileNotUnderSourceControlWarningMessage(e){return Xi.showMessage("warn",`${e}. The file is probably not under source control`,zi.FileNotUnderSourceControlWarning)}static showLineUncommittedWarningMessage(e){return Xi.showMessage("warn",`${e}. The line has uncommitted changes`,zi.LineUncommittedWarning)}static showNoRepositoryWarningMessage(e){return Xi.showMessage("warn",`${e}. No repository could be found`,zi.NoRepositoryWarning)}static showResultExplorerInfoMessage(){return Xi.showMessage("info",'If you can\'t find your results, click on "GITLENS RESULTS" at the bottom of the Explorer view',zi.ResultsExplorerNotice,null)}static showUnsupportedGitVersionErrorMessage(e){return Xi.showMessage("error",`GitLens requires a newer version of Git (>= 2.2.0) than is currently installed (${e}). Please install a more recent version of Git`,zi.GitVersionWarning)}static async showMessage(e,t,i,s="Don't Show Again",...o){if(ce.log(`ShowMessage(${e}, '${t}', ${i}, ${s})`),ua.get(ua.name("advanced")("messages")(i).value))return void ce.log(`ShowMessage(${e}, '${t}', ${i}, ${s}) skipped`);null!==s&&o.push(s);let a=void 0;switch(e){case"info":a=await N.window.showInformationMessage(t,...o);break;case"warn":a=await N.window.showWarningMessage(t,...o);break;case"error":a=await N.window.showErrorMessage(t,...o)}if(null===s||a===s){ce.log(`ShowMessage(${e}, '${t}', ${i}, ${s}) don't show again requested`);const o=ua.name("advanced")("messages").value,r=ua.get(o);if(r[i]=!0,await ua.update(o,r,N.ConfigurationTarget.Global),a===s)return}return ce.log(`ShowMessage(${e}, '${t}', ${i}, ${s}) returned ${a}`),a}}class Ji extends Hi{constructor(){super(ei.CloseUnchangedFiles)}async execute(e,t,i={}){t=Ni(t,e);try{if(void 0===i.uris){i=Object.assign({},i);const e=await la.git.getRepoPath(t);if(!e)return Xi.showNoRepositoryWarningMessage("Unable to close unchanged files");const s=await la.git.getStatusForRepo(e);if(void 0===s)return N.window.showWarningMessage("Unable to close unchanged files");i.uris=s.files.map(e=>e.uri)}if(0===i.uris.length)return N.commands.executeCommand(W.CloseAllEditors);const s=new qi;let o=0,a=void 0,r=N.window.activeTextEditor;for(;;){if(void 0!==r){if(se.equals(a,r,{useId:!0,usePosition:!0}))break;if(void 0!==r.document&&(r.document.isDirty||i.uris.some(e=>oe.equals(e,r.document&&r.document.uri)))){const e=a;if(a=r,r=await s.awaitNext(500),se.equals(e,r,{useId:!0,usePosition:!0}))break;continue}}if(a=r,r=await s.awaitClose(500),void 0===a&&void 0===r){if(++o>=4)break}else o=0}return void s.dispose()}catch(e){return ce.error(e,"CloseUnchangedFilesCommand"),N.window.showErrorMessage("Unable to close unchanged files. See output channel for more details")}}}class Zi extends Hi{constructor(){super(ei.CopyMessageToClipboard)}async preExecute(e,t={}){return Li(e)?((t=Object.assign({},t)).sha=e.node.commit.sha,this.execute(e.editor,e.node.commit.uri,t)):this.execute(e.editor,e.uri,t)}async execute(e,t,s={}){t=Ni(t,e);const o=await Promise.resolve().then(function(){var e=i(12);return"object"==typeof e&&e&&e.__esModule?e:Object.assign({},"object"==typeof e&&e,{default:e})});try{if(s=Object.assign({},s),void 0===t){const t=await la.git.getActiveRepoPath(e);if(!t)return;const i=await la.git.getLog(t,{maxCount:1});if(!i)return;return s.message=u.first(i.commits.values()).message,void o.copy(s.message)}const i=await je.fromUri(t);if(void 0===s.message){if(void 0===s.sha){const t=e&&e.selection.active.line||0;if(t<0)return;try{const o=e&&e.document&&e.document.isDirty?await la.git.getBlameForLineContents(i,t,e.document.getText()):await la.git.getBlameForLine(i,t);if(!o)return;if(o.commit.isUncommitted)return;s.sha=o.commit.sha,i.repoPath||(i.repoPath=o.commit.repoPath)}catch(e){return ce.error(e,"CopyMessageToClipboardCommand",`getBlameForLine(${t})`),N.window.showErrorMessage("Unable to copy message. See output channel for more details")}}const t=await la.git.getLogCommit(i.repoPath,s.sha);if(void 0===t)return;s.message=t.message}return void o.copy(s.message,e=>{if(e){if(e.message.includes("xclip"))return void N.window.showErrorMessage("Unable to copy message, xclip is not installed. You can install it via `sudo apt-get install xclip`");ce.error(e,"CopyMessageToClipboardCommand"),N.window.showErrorMessage("Unable to copy message. See output channel for more details")}})}catch(e){return ce.error(e,"CopyMessageToClipboardCommand"),N.window.showErrorMessage("Unable to copy message. See output channel for more details")}}}class es extends Hi{constructor(){super(ei.CopyShaToClipboard)}async preExecute(e,t={}){return Li(e)?((t=Object.assign({},t)).sha=e.node.commit.sha,this.execute(e.editor,e.node.commit.uri,t)):this.execute(e.editor,e.uri,t)}async execute(e,t,s={}){t=Ni(t,e);const o=await Promise.resolve().then(function(){var e=i(12);return"object"==typeof e&&e&&e.__esModule?e:Object.assign({},"object"==typeof e&&e,{default:e})});try{if(s=Object.assign({},s),void 0===t){const t=await la.git.getActiveRepoPath(e);if(!t)return;const i=await la.git.getLog(t,{maxCount:1});if(!i)return;return s.sha=u.first(i.commits.values()).sha,void o.copy(s.sha)}const i=await je.fromUri(t);if(void 0===s.sha){const t=e&&e.selection.active.line||0;if(t<0)return;try{const o=e&&e.document&&e.document.isDirty?await la.git.getBlameForLineContents(i,t,e.document.getText()):await la.git.getBlameForLine(i,t);if(void 0===o)return;s.sha=o.commit.sha}catch(e){return ce.error(e,"CopyShaToClipboardCommand",`getBlameForLine(${t})`),N.window.showErrorMessage("Unable to copy commit id. See output channel for more details")}}return void o.copy(s.sha,e=>{if(e){if(e.message.includes("xclip"))return void N.window.showErrorMessage("Unable to copy commit id, xclip is not installed. You can install it via `sudo apt-get install xclip`");ce.error(e,"CopyShaToClipboardCommand"),N.window.showErrorMessage("Unable to copy commit id. See output channel for more details")}})}catch(e){return ce.error(e,"CopyShaToClipboardCommand"),N.window.showErrorMessage("Unable to copy commit id. See output channel for more details")}}}function ts(){return!ua.get(ua.name("advanced")("quickPick")("closeOnFocusOut").value)}function is(e,t){const i=new N.CancellationTokenSource;return async function(e,t,i){const s=i&&await la.keyboard.beginScope(i);try{await N.window.showQuickPick(function(e){return new Promise((t,i)=>{const s=e.token.onCancellationRequested(()=>{s.dispose(),t([])})})}(t),{placeHolder:e,ignoreFocusOut:ts()},t.token)}catch(e){}finally{t.cancel(),s&&s.dispose()}}(e,i,t),i}class ss{constructor(e,t,i){void 0===t?(this.command=void 0,this.args=i):"string"==typeof t?(this.command=t,this.args=i):(this.command=t[0],this.args=t.slice(1)),Object.assign(this,e)}execute(){return void 0===this.command?Promise.resolve(void 0):N.commands.executeCommand(this.command,...this.args||[])}onDidPressKey(e){return this.execute()}}class os extends ss{constructor(e){super({label:e,description:""})}}class as extends ss{constructor(e,t){super({label:"",description:""},e,t)}}class rs extends ss{constructor(e,t){super(t,void 0,void 0),this.uri=e}async execute(e){return Qi(this.uri,e)}onDidPressKey(e){return this.execute({preserveFocus:!0,preview:!1})}}class ns extends ss{constructor(e,t){super(t,void 0,void 0),this.uris=e}async execute(e={preserveFocus:!1,preview:!1}){for(const t of this.uris)await Qi(t,e)}async onDidPressKey(e){return this.execute({preserveFocus:!0,preview:!1})}}class hs{constructor(e){this.commit=e;const t=e.getShortMessage(`${K.Space}$(ellipsis)`);e.isStash?(this.label=t,this.description="",this.detail=`${K.Space} ${e.stashName||e.shortSha} ${w.pad(K.Dot,1,1)} ${e.formattedDate} ${w.pad(K.Dot,1,1)} ${e.getDiffStatus()}`):(this.label=t,this.description=`${w.pad("$(git-commit)",1,1)} ${e.shortSha}`,this.detail=`${K.Space} ${e.author}, ${e.formattedDate}${e.isFile?"":` ${w.pad(K.Dot,1,1)} ${e.getDiffStatus()}`}`)}}class cs extends ss{constructor(e,t={label:"Show in Results",description:`${w.pad(K.Dash,2,2)} displays commit in the GitLens Results view`}){super(t,void 0,void 0),this.commit=e}async execute(e={preserveFocus:!1,preview:!1}){la.resultsExplorer.showCommitInResults(this.commit)}}class ls extends ss{constructor(e,t,i={label:"Show in Results",description:`${w.pad(K.Dash,2,2)} displays commits in the GitLens Results view`}){super(i,void 0,void 0),this.results=e,this.resultsLabel=t}async execute(e={preserveFocus:!1,preview:!1}){la.resultsExplorer.showCommitsInResults(this.results,this.resultsLabel)}}class ds extends ls{constructor(e,t,i={label:"Show in Results",description:`${w.pad(K.Dash,2,2)} displays results in the GitLens Results view`}){super(e,{label:t},i),this.results=e,this.search=t}}class ms extends ss{constructor(e,t,i,s={label:"Show Branches and Tags",description:`${w.pad(K.Dash,2,2)} displays branches and tags`}){super(s,void 0,void 0),this.repoPath=e,this.placeHolder=t,this.goBackCommand=i}async execute(e={preserveFocus:!1,preview:!1}){const t=Cs.showProgress(this.placeHolder);try{const[e,i]=await Promise.all([la.git.getBranches(this.repoPath),la.git.getTags(this.repoPath)]);if(t.token.isCancellationRequested)return;return Cs.show(e,i,this.placeHolder,{progressCancellation:t,goBackCommand:this.goBackCommand})}finally{t.dispose()}}}const us=Object.create(null),gs=["left","right",",",".","escape"],ps=[];class fs extends N.Disposable{constructor(e){super(()=>this.dispose()),this.mapping=e;for(const t in e)e[t]=e[t]||us}async dispose(){const e=ps.indexOf(this.mapping);ce.log("KeyboardScope.dispose",ps.length,e),e===ps.length-1?(ps.pop(),await this.updateKeyCommandsContext(ps[ps.length-1])):ps.splice(e,1)}async begin(){return ps.push(this.mapping),await this.updateKeyCommandsContext(this.mapping),this}async clearKeyCommand(e){const t=ps[ps.length-1];t===this.mapping&&t[e]&&(ce.log("KeyboardScope.clearKeyCommand",ps.length,e),t[e]=void 0,await J(`${j.Key}:${e}`,!1))}async setKeyCommand(e,t){const i=ps[ps.length-1];i===this.mapping&&(ce.log("KeyboardScope.setKeyCommand",ps.length,e,!!i[e]),i[e]?i[e]=t:(i[e]=t,await J(`${j.Key}:${e}`,!0)))}async updateKeyCommandsContext(e){const t=[];for(const i of gs)t.push(J(`${j.Key}:${i}`,!(!e||!e[i])));await Promise.all(t)}}class vs extends N.Disposable{constructor(){super(()=>this.dispose());const e=gs.map(e=>N.commands.registerCommand(`${U}.key.${e}`,()=>this.execute(e),this));this._disposable=N.Disposable.from(...e)}dispose(){this._disposable&&this._disposable.dispose()}async beginScope(e){return ce.log("Keyboard.beginScope",ps.length),await new fs(e?Object.assign(Object.create(null),e):Object.create(null)).begin()}async execute(e){if(ps.length)try{let t=ps[ps.length-1][e];if("function"==typeof t&&(t=await t()),!t||"function"!=typeof t.onDidPressKey)return;return ce.log("Keyboard.execute",e),await t.onDidPressKey(e)}catch(e){return void ce.error(e,"Keyboard.execute")}}}class ws{constructor(e){this.branchOrTag=e,e instanceof Ye?(this.label=`${e.current?`$(check)${K.Space}`:K.Space.repeat(4)} ${e.name}`,this.description=e.remote?`${K.Space.repeat(2)} remote branch`:""):(this.label=`${K.Space.repeat(4)} ${e.name}`,this.description=`${K.Space.repeat(2)} tag`)}get name(){return this.branchOrTag.name}get remote(){return this.branchOrTag instanceof Ye&&this.branchOrTag.remote}}class Cs{static showProgress(e){return is(e,{left:us,",":us,".":us})}static async show(e,t,i,s={}){const o=[...e.filter(e=>!e.remote).map(e=>new ws(e)),...t.map(e=>new ws(e)),...e.filter(e=>e.remote).map(e=>new ws(e))];if(void 0!==s.goBackCommand&&o.splice(0,0,s.goBackCommand),void 0!==s.progressCancellation&&s.progressCancellation.token.isCancellationRequested)return;const a=await la.keyboard.beginScope({left:s.goBackCommand||us});s.progressCancellation&&s.progressCancellation.cancel();const r=await N.window.showQuickPick(o,{placeHolder:i,ignoreFocusOut:ts()});return await a.dispose(),r}}class bs{constructor(e){this.branch=e,this.label=`${e.current?`$(check)${K.Space}`:K.Space.repeat(4)} ${e.name}`,this.description=e.remote?`${K.Space.repeat(2)} remote branch`:""}}class ys{static async show(e,t,i={}){const s=e.map(e=>new bs(e));return void 0!==i.goBackCommand&&s.splice(0,0,i.goBackCommand),await N.window.showQuickPick(s,{placeHolder:t,ignoreFocusOut:ts()})}}class xs extends ss{constructor(e,t){super({label:`$(link-external) Open ${ve(t)} in ${e.provider.name}`,description:`${w.pad(K.Dash,2,3)} $(repo) ${e.provider.path}`},void 0,void 0),this.remote=e,this.resource=t}async execute(){return this.remote.provider.open(this.resource)}}class Ss extends ss{constructor(e,t,i){const s=ve(t);let o="";switch(t.type){case pe.Branch:o=`$(git-branch) ${t.branch}`;break;case pe.Branches:o="$(git-branch) Branches";break;case pe.Commit:o=`$(git-commit) ${ii.shortenSha(t.sha)}`;break;case pe.File:o=`$(file-text) ${Ue.basename(t.fileName)}`;break;case pe.Repo:o="$(repo) Repository";break;case pe.Revision:if(void 0!==t.commit&&t.commit instanceof it)"D"===t.commit.status?(t.sha=t.commit.previousSha,o=`$(file-text) ${Ue.basename(t.fileName)} in ${K.Space}$(git-commit) ${t.commit.previousShortSha} (deleted in ${K.Space}$(git-commit) ${t.commit.shortSha})`):(t.sha=t.commit.sha,o=`$(file-text) ${Ue.basename(t.fileName)} in ${K.Space}$(git-commit) ${t.commit.shortSha}`);else{const e=void 0===t.sha?"":ii.shortenSha(t.sha);o=`$(file-text) ${Ue.basename(t.fileName)}${e?` in ${K.Space}$(git-commit) ${e}`:""}`}}const a=e[0];1!==e.length?super({label:`$(link-external) Open ${s} in ${e.every(e=>void 0!==e.provider&&e.provider.name===a.provider.name)?a.provider.name:"Remote"}${K.Ellipsis}`,description:`${w.pad(K.Dash,2,3)} ${o}`},ei.OpenInRemote,[void 0,{remotes:e,resource:t,goBackCommand:i}]):super({label:`$(link-external) Open ${s} in ${a.provider.name}`,description:`${w.pad(K.Dash,2,3)} $(repo) ${a.provider.path} ${w.pad(K.Dot,1,1)} ${o}`},ei.OpenInRemote,[void 0,{remotes:e,resource:t,goBackCommand:i}])}}class $s{static async show(e,t,i,s){const o=e.map(e=>new xs(e,i));s&&o.splice(0,0,s);const a=await N.window.showQuickPick(o,{placeHolder:t,ignoreFocusOut:ts()});if(void 0!==a)return a}}class Ds{static showProgress(e){return is(`${e} history ${K.Dash} search by commit message, filename, or commit id`,{left:us,",":us,".":us})}static async show(e,t,i,s,o,a){const r=Array.from(u.map(e.commits.values(),e=>new hs(e))),n=new ss({label:`go back ${K.ArrowBack}`,description:`${w.pad(K.Dash,2,3)} to ${K.Space}$(git-branch) ${i} history`},ei.ShowQuickBranchHistory,[t,{branch:i,log:e,maxCount:e.maxCount,goBackCommand:o}]),h=await la.git.getRemotes(t&&t.repoPath||e.repoPath);h.length&&r.splice(0,0,new Ss(h,{type:"branch",branch:i},n)),r.splice(0,0,new ss({label:"$(search) Show Commit Search",description:`${w.pad(K.Dash,2,3)} search for commits by message, author, files, or commit id`},ei.ShowCommitSearch,[je.fromRepoPath(e.repoPath),{goBackCommand:n}]));let c=void 0;if((e.truncated||e.sha)&&(e.truncated&&r.splice(0,0,new ss({label:"$(sync) Show All Commits",description:`${w.pad(K.Dash,2,3)} this may take a while`},ei.ShowQuickBranchHistory,[je.fromRepoPath(e.repoPath),{branch:i,maxCount:0,goBackCommand:o}])),a&&r.splice(0,0,a),e.truncated)){const s=new ss({label:"$(arrow-right) Show Next Commits",description:`${w.pad(K.Dash,2,3)} shows ${e.maxCount} newer commits`},ei.ShowQuickBranchHistory,[t,{branch:i,maxCount:e.maxCount,nextPageCommand:a}]),n=u.last(e.commits.values());null!=n&&(c=new ss({label:"$(arrow-left) Show Previous Commits",description:`${w.pad(K.Dash,2,3)} shows ${e.maxCount} older commits`},ei.ShowQuickBranchHistory,[new je(t||n.uri,n),{branch:i,maxCount:e.maxCount,goBackCommand:o,nextPageCommand:s}]),r.splice(0,0,c))}if(o&&r.splice(0,0,o),s.token.isCancellationRequested)return;const l=await la.keyboard.beginScope({left:o,",":c,".":a});s.cancel();const d=await N.window.showQuickPick(r,{matchOnDescription:!0,matchOnDetail:!0,placeHolder:`${i} history ${K.Dash} search by commit message, filename, or commit id`,ignoreFocusOut:ts()});return await l.dispose(),d}}class Fs extends ss{constructor(e,t){super(t||{label:"$(git-pull-request) Apply Changes",description:`${w.pad(K.Dash,2,3)} $(file-text) ${Ue.basename(e.fileName)} in ${K.Space}$(git-commit) ${e.shortSha}`},void 0,void 0),this.commit=e}async execute(){const e=this.commit.toGitUri();return await la.git.checkoutFile(e),Qi(e,{preserveFocus:!0,preview:!1})}}class ks extends rs{constructor(e,t){super(N.Uri.file(Ue.resolve(e.repoPath,e.fileName)),t||{label:"$(file-symlink-file) Open File",description:`${w.pad(K.Dash,2,3)} ${Ue.basename(e.fileName)}`})}}class Ps extends rs{constructor(e,t){let i,s;"D"===e.status?(s=je.toRevisionUri(e.previousFileSha,e.previousUri.fsPath,e.repoPath),i=`${w.pad(K.Dash,2,3)} ${Ue.basename(e.fileName)} in ${K.Space}$(git-commit) ${e.previousShortSha} (deleted in ${K.Space}$(git-commit) ${e.shortSha})`):(s=je.toRevisionUri(e.sha,e.uri.fsPath,e.repoPath),i=`${w.pad(K.Dash,2,3)} ${Ue.basename(e.fileName)} in ${K.Space}$(git-commit) ${e.shortSha}`),super(s,t||{label:"$(file-symlink-file) Open Revision",description:i})}}class _s{static async show(e,t,i,s,o){const a=[],r=e.isStash,n=e.workingFileName&&Ue.basename(e.workingFileName)||Ue.basename(e.fileName),h=e.isUncommitted;if(h){const t=await la.git.getRecentLogCommitForFile(void 0,e.uri.fsPath);if(void 0===t)return;e=t}await e.resolvePreviousFileSha(),r&&a.push(new Fs(e)),e.previousFileShortSha&&a.push(new ss({label:"$(git-compare) Open Changes",description:`${w.pad(K.Dash,2,3)} $(git-commit) ${e.previousFileShortSha} ${K.Space} $(git-compare) ${K.Space} $(git-commit) ${e.shortSha}`},ei.DiffWithPrevious,[e.uri,{commit:e}])),e.workingFileName&&a.push(new ss({label:"$(git-compare) Open Changes with Working Tree",description:`${w.pad(K.Dash,2,3)} $(git-commit) ${e.shortSha} ${K.Space} $(git-compare) ${K.Space} $(file-text) ${n}`},ei.DiffWithWorking,[N.Uri.file(Ue.resolve(e.repoPath,e.workingFileName)),{commit:e}])),e.workingFileName&&"D"!==e.status&&a.push(new ks(e)),a.push(new Ps(e));const c=await la.git.getRemotes(e.repoPath);if(c.length){if(e.workingFileName&&"D"!==e.status){const t=await la.git.getBranch(e.repoPath);a.push(new Ss(c,{type:"file",fileName:e.workingFileName,branch:t.name},s))}r||a.push(new Ss(c,{type:"revision",fileName:e.fileName,commit:e},s))}r||(a.push(new Fs(e)),a.push(new ss({label:"$(clippy) Copy Commit ID to Clipboard",description:`${w.pad(K.Dash,2,3)} ${e.shortSha}`},ei.CopyShaToClipboard,[t,{sha:e.sha}])),a.push(new ss({label:"$(clippy) Copy Commit Message to Clipboard",description:`${w.pad(K.Dash,2,3)} ${e.getShortMessage(`${K.Space}$(ellipsis)`)}`},ei.CopyMessageToClipboard,[t,{message:e.message,sha:e.sha}]))),e.workingFileName&&a.push(new ss({label:"$(history) Show File History",description:`${w.pad(K.Dash,2,3)} of ${Ue.basename(e.fileName)}`},ei.ShowQuickFileHistory,[N.Uri.file(Ue.resolve(e.repoPath,e.workingFileName)),{fileLog:o,goBackCommand:s}])),r||(a.push(new ss({label:`$(history) Show ${e.workingFileName?"Previous ":""}File History`,description:`${w.pad(K.Dash,2,3)} of ${Ue.basename(e.fileName)} ${w.pad(K.Dot,1,1)} from ${K.Space}$(git-commit) ${e.shortSha}`},ei.ShowQuickFileHistory,[e.toGitUri(),{goBackCommand:s}])),a.push(new ss({label:"$(git-commit) Show Commit Details",description:`${w.pad(K.Dash,2,3)} $(git-commit) ${e.shortSha}`},ei.ShowQuickCommitDetails,[e.toGitUri(),{commit:e,sha:e.sha,goBackCommand:s}]))),i&&a.splice(0,0,i);let l=void 0,d=void 0;r||(void 0===o||o.truncated||void 0!==o.sha?(l=(async()=>{let s=o,a=s&&s.commits.get(e.sha);if(void 0===a||void 0===a.previousSha){if(void 0===(s=await la.git.getLogForFile(e.repoPath,t.fsPath,{maxCount:la.config.advanced.maxListItems,ref:e.sha,renames:!0})))return us;void 0===(a=s&&s.commits.get(e.sha))&&e.isMerge&&(a=u.first(s.commits.values())),a&&(a.nextSha=e.nextSha,a.nextFileName=e.nextFileName)}return void 0===a||void 0===a.previousSha?us:new as(ei.ShowQuickCommitFileDetails,[a.previousUri,{fileLog:s,sha:a.previousSha,goBackCommand:i}])}),d=(async()=>{let s=o,a=s&&s.commits.get(e.sha);if(void 0===a||void 0===a.nextSha){s=void 0,a=void 0;const i=await la.git.findNextCommit(e.repoPath,t.fsPath,e.sha);void 0!==i&&i.sha!==e.sha&&((a=e).nextSha=i.sha,a.nextFileName=i.originalFileName||i.fileName)}return void 0===a||void 0===a.nextSha?us:new as(ei.ShowQuickCommitFileDetails,[a.nextUri,{fileLog:s,sha:a.nextSha,goBackCommand:i}])})):(l=void 0===e.previousSha?void 0:new as(ei.ShowQuickCommitFileDetails,[e.previousUri,{fileLog:o,sha:e.previousSha,goBackCommand:i}]),d=void 0===e.nextSha?void 0:new as(ei.ShowQuickCommitFileDetails,[e.nextUri,{fileLog:o,sha:e.nextSha,goBackCommand:i}])));const m=await la.keyboard.beginScope({left:i,",":l,".":d}),g=await N.window.showQuickPick(a,{matchOnDescription:!0,placeHolder:`${e.getFormattedPath()} ${w.pad(K.Dot,1,1)} ${h?`Uncommitted ${K.ArrowRightHollow} `:""}${e.shortSha} ${w.pad(K.Dot,1,1)} ${e.author}, ${e.formattedDate} ${w.pad(K.Dot,1,1)} ${e.getShortMessage(`${K.Space}$(ellipsis)`)}`,ignoreFocusOut:ts(),onDidSelectItem:e=>{m.setKeyCommand("right",e)}});return await m.dispose(),g}}class Rs extends rs{constructor(e,t){const i=ut(t.status),s=dt.getFormattedDirectory(t,!0);super(je.toRevisionUri(e.sha,t,e.repoPath),{label:`${w.pad(i,4,2)} ${Ue.basename(t.fileName)}`,description:s}),this.commit=e.toFileCommit(t),this.status=t.status}get sha(){return this.commit.sha}onDidPressKey(e){return void 0===this.commit.previousSha?super.onDidPressKey(e):N.commands.executeCommand(ei.DiffWithPrevious,this.commit.toGitUri(),{commit:this.commit,showOptions:{preserveFocus:!0,preview:!1}})}}class Ts extends ns{constructor(e,t=!1,i){const s=e.repoPath;super(o.filterMap(e.fileStatuses,e=>je.fromFileStatus(e,s)),i||{label:"$(file-symlink-file) Open Files",description:""})}}class Es extends ns{constructor(e,t){super(o.filterMap(e.fileStatuses,t=>je.toRevisionUri("D"===t.status?e.previousFileSha:e.sha,t,e.repoPath)),t||{label:"$(file-symlink-file) Open Revisions",description:`${w.pad(K.Dash,2,3)} in ${K.Space}$(git-commit) ${e.shortSha}`})}}class Bs{static async show(e,t,i,s,o){await e.resolvePreviousFileSha();const a=e.fileStatuses.map(t=>new Rs(e,t)),r=e.isStash;let n=0;if(r)a.splice(n++,0,new ss({label:"$(git-pull-request) Apply Stashed Changes",description:`${w.pad(K.Dash,2,3)} ${e.getShortMessage(`${K.Space}$(ellipsis)`)}`},ei.StashApply,[{confirm:!0,deleteAfter:!1,stashItem:e,goBackCommand:s}])),a.splice(n++,0,new ss({label:"$(x) Delete Stashed Changes",description:`${w.pad(K.Dash,2,3)} ${e.getShortMessage(`${K.Space}$(ellipsis)`)}`},ei.StashDelete,[{confirm:!0,stashItem:e,goBackCommand:s}])),a.splice(n++,0,new cs(e));else{a.splice(n++,0,new cs(e));const t=await la.git.getRemotes(e.repoPath);t.length&&a.splice(n++,0,new Ss(t,{type:"commit",sha:e.sha},s))}a.splice(n++,0,new Ts(e)),a.splice(n++,0,new Es(e)),a.splice(n++,0,new ss({label:"$(git-compare) Open Directory Compare with Previous Revision",description:`${w.pad(K.Dash,2,3)} $(git-commit) ${e.previousFileShortSha} ${K.Space} $(git-compare) ${K.Space} $(git-commit) ${e.shortSha}`},ei.DiffDirectory,[e.uri,{ref1:e.previousFileSha,ref2:e.sha}])),a.splice(n++,0,new ss({label:"$(git-compare) Open Directory Compare with Working Tree",description:`${w.pad(K.Dash,2,3)} $(git-commit) ${e.shortSha} ${K.Space} $(git-compare) ${K.Space} $(file-directory) Working Tree`},ei.DiffDirectory,[t,{ref1:e.sha}])),r||a.splice(n++,0,new ss({label:"$(clippy) Copy Commit ID to Clipboard",description:`${w.pad(K.Dash,2,3)} ${e.shortSha}`},ei.CopyShaToClipboard,[t,{sha:e.sha}])),a.splice(n++,0,new ss({label:"$(clippy) Copy Commit Message to Clipboard",description:`${w.pad(K.Dash,2,3)} ${e.getShortMessage(`${K.Space}$(ellipsis)`)}`},ei.CopyMessageToClipboard,[t,{message:e.message,sha:e.sha}])),a.splice(n++,0,new ss({label:"Changed Files",description:e.getDiffStatus()},ei.ShowQuickCommitDetails,[t,{commit:e,repoLog:o,sha:e.sha,goBackCommand:i}])),i&&a.splice(0,0,i);let h=void 0,c=void 0;r||(void 0===o||o.truncated||void 0!==o.sha?(h=(async()=>{let t=o,s=t&&t.commits.get(e.sha);return void 0!==s&&void 0!==s.previousSha||(s=(t=await la.git.getLog(e.repoPath,{maxCount:la.config.advanced.maxListItems,ref:e.sha}))&&t.commits.get(e.sha))&&(s.nextSha=e.nextSha),void 0===s||void 0===s.previousSha?us:new as(ei.ShowQuickCommitDetails,[s.previousUri,{repoLog:t,sha:s.previousSha,goBackCommand:i}])}),c=(async()=>{let t=o,s=t&&t.commits.get(e.sha);if(void 0===s||void 0===s.nextSha){t=void 0,s=void 0;const i=await la.git.getLog(e.repoPath,{maxCount:1,reverse:!0,ref:e.sha}),o=i&&u.first(i.commits.values());void 0!==o&&o.sha!==e.sha&&((s=e).nextSha=o.sha)}return void 0===s||void 0===s.nextSha?us:new as(ei.ShowQuickCommitDetails,[s.nextUri,{repoLog:t,sha:s.nextSha,goBackCommand:i}])})):(h=void 0===e.previousSha?void 0:new as(ei.ShowQuickCommitDetails,[e.previousUri,{repoLog:o,sha:e.previousSha,goBackCommand:i}]),c=void 0===e.nextSha?void 0:new as(ei.ShowQuickCommitDetails,[e.nextUri,{repoLog:o,sha:e.nextSha,goBackCommand:i}])));const l=await la.keyboard.beginScope({left:i,",":h,".":c}),d=await N.window.showQuickPick(a,{matchOnDescription:!0,matchOnDetail:!0,placeHolder:`${e.shortSha} ${w.pad(K.Dot,1,1)} ${e.author?`${e.author}, `:""}${e.formattedDate} ${w.pad(K.Dot,1,1)} ${e.getShortMessage(`${K.Space}$(ellipsis)`)}`,ignoreFocusOut:ts(),onDidSelectItem:e=>{l.setKeyCommand("right",e),"function"==typeof e.onDidSelect&&e.onDidSelect()}});return await l.dispose(),d}}class As{static showProgress(e){return is(e,{left:us,",":us,".":us})}static async show(e,t,i,s){const o=e&&[...u.map(e.commits.values(),e=>new hs(e))]||[new os("No results found")];if(void 0!==s.showInResultsExplorerCommand&&o.splice(0,0,s.showInResultsExplorerCommand),void 0!==s.showAllCommand&&o.splice(0,0,s.showAllCommand),void 0!==s.goBackCommand&&o.splice(0,0,s.goBackCommand),i.token.isCancellationRequested)return;const a=await la.keyboard.beginScope({left:s.goBackCommand});i.cancel();const r=await N.window.showQuickPick(o,{matchOnDescription:!0,placeHolder:t,ignoreFocusOut:ts()});return await a.dispose(),r}}class Ns{static showProgress(e){return is(e,{left:us,",":us,".":us})}static async show(e,t,i,s={}){s=Object.assign({pickerOnly:!1},s);const o=Array.from(u.map(e.commits.values(),e=>new hs(e)));let a=0;if(s.pickerOnly&&(a++,o.splice(0,0,new ms(e.repoPath,i,s.currentCommand))),void 0!==s.showInResultsExplorerCommand&&(a++,o.splice(0,0,s.showInResultsExplorerCommand)),e.truncated||e.sha){if(void 0!==s.showAllCommand)a++,o.splice(0,0,s.showAllCommand);else if(!s.pickerOnly){const[i]=await la.git.findWorkingFileName(Ue.relative(e.repoPath,t.fsPath),e.repoPath);i&&(a++,o.splice(0,0,new ss({label:"$(history) Show File History",description:`${w.pad(K.Dash,2,3)} of ${Ue.basename(i)}`},ei.ShowQuickFileHistory,[N.Uri.file(Ue.resolve(e.repoPath,i)),{goBackCommand:new ss({label:`go back ${K.ArrowBack}`,description:`${w.pad(K.Dash,2,3)} to history of ${K.Space}$(file-text) ${Ue.basename(t.fsPath)}${t.sha?` from ${K.Space}$(git-commit) ${t.shortSha}`:""}`},ei.ShowQuickFileHistory,[t,{log:e,maxCount:e.maxCount,range:e.range,goBackCommand:s.goBackCommand}])}])))}void 0!==s.nextPageCommand&&(a++,o.splice(0,0,s.nextPageCommand)),void 0!==s.previousPageCommand&&(a++,o.splice(0,0,s.previousPageCommand))}if(!s.pickerOnly){const i=await la.git.getBranch(t.repoPath),r=new ss({label:`go back ${K.ArrowBack}`,description:`${w.pad(K.Dash,2,3)} to history of ${K.Space}$(file-text) ${Ue.basename(t.fsPath)}${t.sha?` from ${K.Space}$(git-commit) ${t.shortSha}`:""}`},ei.ShowQuickFileHistory,[t,{log:e,maxCount:e.maxCount,range:e.range}]);void 0===s.goBackCommand&&o.splice(a++,0,new ss({label:"$(history) Show Branch History",description:`${w.pad(K.Dash,2,3)} shows  ${K.Space}$(git-branch) ${i.name} history`},ei.ShowQuickCurrentBranchHistory,[void 0,{goBackCommand:r}]));const n=await la.git.getRemotes(t.repoPath);if(n.length){const e=void 0!==t.sha?{type:"revision",branch:i.name,fileName:t.getRelativePath(),sha:t.sha}:{type:"file",branch:i.name,fileName:t.getRelativePath()};o.splice(a++,0,new Ss(n,e,r))}s.goBackCommand&&o.splice(0,0,s.goBackCommand)}if(void 0!==s.progressCancellation&&s.progressCancellation.token.isCancellationRequested)return;const r=await la.keyboard.beginScope({left:s.goBackCommand,",":s.previousPageCommand,".":s.nextPageCommand});s.progressCancellation&&s.progressCancellation.cancel();const n=await N.window.showQuickPick(o,{matchOnDescription:!0,matchOnDetail:!0,placeHolder:i,ignoreFocusOut:ts()});return await r.dispose(),n}}class Us{constructor(e){this.repository=e,this.label=e.name,this.description=e.path}get repoPath(){return this.repository.path}}class Ls{static async show(e,t){const i=[...u.map(await la.git.getRepositories(),e=>new Us(e))];return void 0!==t&&i.splice(0,0,t),await N.window.showQuickPick(i,{placeHolder:e,ignoreFocusOut:ts()})}}class Os extends rs{constructor(e,t,i){const s=e.getOcticon(),o=e.getFormattedDirectory(!0);super(e.uri,i||{label:`${e.staged?"$(check)":K.Space.repeat(3)}${w.pad(s,2,2)} ${Ue.basename(e.fileName)}`,description:o}),this.status=e,void 0!==e.indexStatus?this.commit=new it(Ve.File,e.repoPath,ii.stagedUncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,"HEAD",e.fileName):this.commit=new it(Ve.File,e.repoPath,ii.uncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,void 0!==t?ii.stagedUncommittedSha:"HEAD",e.fileName)}onDidPressKey(e){return N.commands.executeCommand(ei.DiffWithPrevious,je.fromFileStatus(this.status,this.status.repoPath),{commit:this.commit,line:0,showOptions:{preserveFocus:!0,preview:!1}})}}class Is extends ss{constructor(e,t){const i=e.map(e=>e.uri);super(t||{label:"$(file-symlink-file) Open Changed Files",description:""},ei.OpenChangedFiles,[void 0,{uris:i}])}}class Ms{static computeStatus(e){let t=0,i=0,s=0,o=0,a=0,r=0;const n=[],h=[];for(const c of e){switch(c.indexStatus){case"A":case"?":t++,n.push(c);break;case"D":a++;break;case void 0:break;default:s++,n.push(c)}switch(c.workTreeStatus){case"A":case"?":i++,h.push(c);break;case"D":r++;break;case void 0:break;default:o++,h.push(c)}}const c=t+s+a,l=i+o+r;return{staged:c,stagedStatus:c>0?`+${t} ~${s} -${a}`:"",stagedAddsAndChanges:n,unstaged:l,unstagedStatus:l>0?`+${i} ~${o} -${r}`:"",unstagedAddsAndChanges:h}}static async show(e,t){const i=[...u.flatMap(e.files,e=>void 0!==e.workTreeStatus&&void 0!==e.indexStatus?[new Os(e.with({indexStatus:null}),e.indexStatus),new Os(e.with({workTreeStatus:null}))]:[new Os(e)])];i.sort((e,t)=>(e.status.staged?-1:1)-(t.status.staged?-1:1)||e.status.fileName.localeCompare(t.status.fileName));const s=new ss({label:`go back ${K.ArrowBack}`,description:`${w.pad(K.Dash,2,3)} to ${K.Space}$(git-branch) ${e.branch} status`},ei.ShowQuickRepoStatus,[void 0,{goBackCommand:t}]),o=this.computeStatus(e.files);if(o.staged>0){let s=0;const a=o.unstaged>0?e.files.findIndex(e=>!e.staged):-1;a>-1&&(i.splice(a,0,new ss({label:"Unstaged Files",description:o.unstagedStatus},ei.ShowQuickRepoStatus,[void 0,{goBackCommand:t}])),i.splice(a,0,new Is(o.stagedAddsAndChanges,{label:`${K.Space.repeat(4)} $(file-symlink-file) Open Staged Files`,description:""})),i.push(new Is(o.unstagedAddsAndChanges,{label:`${K.Space.repeat(4)} $(file-symlink-file) Open Unstaged Files`,description:""}))),i.splice(s++,0,new ss({label:"Staged Files",description:o.stagedStatus},ei.ShowQuickRepoStatus,[void 0,{goBackCommand:t}]))}else e.files.some(e=>!e.staged)&&i.splice(0,0,new ss({label:"Unstaged Files",description:o.unstagedStatus},ei.ShowQuickRepoStatus,[void 0,{goBackCommand:t}]));e.files.length?(i.push(new Is(o.stagedAddsAndChanges.concat(o.unstagedAddsAndChanges))),i.push(new ss({label:"$(x) Close Unchanged Files",description:""},ei.CloseUnchangedFiles))):i.push(new ss({label:"No changes in the working tree",description:""},ei.ShowQuickRepoStatus,[void 0,{goBackCommand:t}])),i.splice(0,0,new ss({label:"$(inbox) Show Stashed Changes",description:`${w.pad(K.Dash,2,3)} shows stashed changes in the repository`},ei.ShowQuickStashList,[je.fromRepoPath(e.repoPath),{goBackCommand:s}])),e.upstream&&e.state.ahead&&i.splice(0,0,new ss({label:`$(cloud-upload)${K.Space} ${e.state.ahead} Commit${e.state.ahead>1?"s":""} ahead of ${K.Space}$(git-branch) ${e.upstream}`,description:`${w.pad(K.Dash,2,3)} shows commits in ${K.Space}$(git-branch) ${e.branch} but not ${K.Space}$(git-branch) ${e.upstream}`},ei.ShowQuickBranchHistory,[je.fromRepoPath(e.repoPath,`${e.upstream}..${e.branch}`),{branch:e.branch,maxCount:0,goBackCommand:s}])),e.upstream&&e.state.behind&&i.splice(0,0,new ss({label:`$(cloud-download)${K.Space} ${e.state.behind} Commit${e.state.behind>1?"s":""} behind ${K.Space}$(git-branch) ${e.upstream}`,description:`${w.pad(K.Dash,2,3)} shows commits in ${K.Space}$(git-branch) ${e.upstream} but not ${K.Space}$(git-branch) ${e.branch}${e.sha?` (since ${K.Space}$(git-commit) ${ii.shortenSha(e.sha)})`:""}`},ei.ShowQuickBranchHistory,[je.fromRepoPath(e.repoPath,`${e.branch}..${e.upstream}`),{branch:e.upstream,maxCount:0,goBackCommand:s}])),!e.upstream||e.state.ahead||e.state.behind||i.splice(0,0,new ss({label:`$(git-branch) ${e.branch} is up-to-date with ${K.Space}$(git-branch) ${e.upstream}`,description:""},ei.ShowQuickRepoStatus,[void 0,{goBackCommand:t}])),t&&i.splice(0,0,t);const a=await la.keyboard.beginScope({left:t}),r=await N.window.showQuickPick(i,{matchOnDescription:!0,placeHolder:`status of ${e.branch}${e.upstream?` ${w.pad(K.ArrowLeftRight,1,1)} ${e.upstream}`:""}`,ignoreFocusOut:ts(),onDidSelectItem:e=>{a.setKeyCommand("right",e)}});return await a.dispose(),r}}class Ws{static showProgress(e){return is("apply"===e?`Apply stashed changes to your working tree${K.Ellipsis}`:`stashed changes ${K.Dash} search by message, filename, or commit id`,{left:us,",":us,".":us})}static async show(e,t,i,s,o){const a=e&&Array.from(u.map(e.commits.values(),e=>new hs(e)))||[];if("list"===t&&a.splice(0,0,new ss({label:"$(plus) Stash Changes",description:`${w.pad(K.Dash,2,3)} stashes all changes`},ei.StashSave,[{goBackCommand:o}])),s&&a.splice(0,0,s),i.token.isCancellationRequested)return;const r=await la.keyboard.beginScope({left:s});i.cancel();const n=await N.window.showQuickPick(a,{matchOnDescription:!0,placeHolder:"apply"===t?`Apply stashed changes to your working tree${K.Ellipsis}`:`stashed changes ${K.Dash} search by message, filename, or commit id`,ignoreFocusOut:ts()});return await r.dispose(),n}}class Hs extends Hi{constructor(){super([ei.DiffHeadWithBranch,ei.DiffWorkingWithBranch])}async preExecute(e,t={}){switch(e.command){case ei.DiffHeadWithBranch:t.ref2="HEAD";break;case ei.DiffWorkingWithBranch:t.ref2=""}return this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(void 0===i.ref2)return;let s;t=Ni(t,e);try{const o=await la.git.getRepoPath(t);if(!o)return Xi.showNoRepositoryWarningMessage("Unable to open branch compare");if(!i.ref1){let e;switch(i.ref2){case"":e=`Compare Working Tree to ${K.Ellipsis}`;break;case"HEAD":e=`Compare Index (HEAD) to ${K.Ellipsis}`;break;default:e=`Compare ${i.ref2} to ${K.Ellipsis}`}s=Cs.showProgress(e);const[t,a]=await Promise.all([la.git.getBranches(o),la.git.getTags(o)]);if(s.token.isCancellationRequested)return;const r=await Cs.show(t,a,e,{progressCancellation:s});if(void 0===r)return;if(r instanceof ss)return r.execute();if(i.ref1=r.name,void 0===i.ref1)return}return void la.resultsExplorer.showComparisonInResults(o,i.ref1,i.ref2)}catch(e){return ce.error(e,"DiffBranchWithBranchCommand"),N.window.showErrorMessage("Unable to open branch compare. See output channel for more details")}finally{s&&s.dispose()}}}class js extends Hi{constructor(){super([ei.DiffDirectory,ei.ExternalDiffAll,ei.ExplorersOpenDirectoryDiff,ei.ExplorersOpenDirectoryDiffWithWorking])}async preExecute(e,t={}){switch(e.command){case ei.ExternalDiffAll:t.ref1="HEAD",t.ref2=void 0;break;case ei.ExplorersOpenDirectoryDiff:"view"===e.type&&e.node instanceof Ti&&(t.ref1=e.node.ref1.ref,t.ref2=e.node.ref2.ref);break;case ei.ExplorersOpenDirectoryDiffWithWorking:(function(e){return"view"===e.type&&e.node instanceof oi})(e)&&(t.ref1=e.node.ref,t.ref2=void 0)}return this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){let s;t=Ni(t,e);try{const o=await la.git.getRepoPath(t);if(!o)return Xi.showNoRepositoryWarningMessage("Unable to open directory compare");if(!i.ref1){i=Object.assign({},i);const e=`Compare Working Tree to ${K.Ellipsis}`;s=Cs.showProgress(e);const[t,a]=await Promise.all([la.git.getBranches(o),la.git.getTags(o)]);if(s.token.isCancellationRequested)return;const r=await Cs.show(t,a,e,{progressCancellation:s});if(void 0===r)return;if(r instanceof ss)return r.execute();if(i.ref1=r.name,void 0===i.ref1)return}return void la.git.openDirectoryDiff(o,i.ref1,i.ref2)}catch(e){if("No diff tool found"===(e&&e.toString())){if(!await N.window.showWarningMessage("Unable to open directory compare because there is no Git diff tool configured","View Git Docs"))return;return N.commands.executeCommand(W.Open,N.Uri.parse("https://git-scm.com/docs/git-config#git-config-difftool"))}return ce.error(e,"DiffDirectoryCommand"),N.window.showErrorMessage("Unable to open directory compare. See output channel for more details")}finally{s&&s.dispose()}}}class Gs extends Hi{constructor(){super(ei.DiffLineWithPrevious)}async execute(e,t,i={}){if(void 0===(t=Ni(t,e)))return;const s=await je.fromUri(t);if(void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line),void 0===i.commit||ii.isUncommitted(i.commit.sha)){const t=i.line;if(t<0)return;try{const o=e&&e.document&&e.document.isDirty?await la.git.getBlameForLineContents(s,t,e.document.getText()):await la.git.getBlameForLine(s,t);if(void 0===o)return Xi.showFileNotUnderSourceControlWarningMessage("Unable to open compare");if(i.commit=o.commit,i.commit.isUncommitted){const e=await la.git.getStatusForFile(s.repoPath,s.fsPath);void 0!==e&&void 0!==e.indexStatus&&(i.commit=i.commit.with({sha:ii.stagedUncommittedSha}))}}catch(e){return ce.error(e,"DiffLineWithPreviousCommand",`getBlameForLine(${t})`),N.window.showErrorMessage("Unable to open compare. See output channel for more details")}}const o={repoPath:i.commit.repoPath,lhs:{sha:void 0!==i.commit.previousSha?i.commit.previousSha:ii.deletedSha,uri:i.commit.previousUri},rhs:{sha:i.commit.sha,uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return N.commands.executeCommand(ei.DiffWith,o)}}class Vs extends Hi{constructor(){super(ei.DiffLineWithWorking)}async execute(e,t,i={}){if(void 0===(t=Ni(t,e)))return;const s=await je.fromUri(t);if(void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line),void 0===i.commit||ii.isUncommitted(i.commit.sha)){const t=i.line;if(t<0)return;try{const o=e&&e.document&&e.document.isDirty?await la.git.getBlameForLineContents(s,t,e.document.getText()):await la.git.getBlameForLine(s,t);if(void 0===o)return Xi.showFileNotUnderSourceControlWarningMessage("Unable to open compare");if(i.commit=o.commit,i.commit.isUncommitted){const e=await la.git.getStatusForFile(s.repoPath,s.fsPath);i.commit=i.commit.with({sha:void 0!==e&&void 0!==e.indexStatus?ii.stagedUncommittedSha:i.commit.previousSha,fileName:i.commit.previousFileName,originalFileName:null,previousSha:null,previousFileName:null}),i.line=o.line.line+1}}catch(e){return ce.error(e,"DiffLineWithWorkingCommand",`getBlameForLine(${t})`),N.window.showErrorMessage("Unable to open compare. See output channel for more details")}}const o={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:"",uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return N.commands.executeCommand(ei.DiffWith,o)}}class Qs extends Hi{static getMarkdownCommandArgs(e,t){let i;if(e instanceof qe){const s=e;i=void 0===t?s.isUncommitted?{repoPath:s.repoPath,lhs:{sha:"HEAD",uri:s.uri},rhs:{sha:"",uri:s.uri}}:{repoPath:s.repoPath,lhs:{sha:void 0!==s.previousSha?s.previousSha:ii.deletedSha,uri:s.previousUri},rhs:{sha:s.sha,uri:s.uri}}:{repoPath:s.repoPath,lhs:{sha:s.sha,uri:s.uri},rhs:{sha:t.sha,uri:t.uri}}}else i=e;return super.getMarkdownCommandArgsCore(ei.DiffWith,i)}constructor(){super(ei.DiffWith)}async execute(e,t,i={}){if(void 0!==(i=Object.assign({},i,{lhs:Object.assign({},i.lhs),rhs:Object.assign({},i.rhs),showOptions:Object.assign({},i.showOptions)})).repoPath&&void 0!==i.lhs&&void 0!==i.rhs)try{ii.isResolveRequired(i.lhs.sha)&&(i.lhs.sha=await la.git.resolveReference(i.repoPath,i.lhs.sha,i.lhs.uri)),ii.isResolveRequired(i.rhs.sha)&&(i.rhs.sha=await la.git.resolveReference(i.repoPath,i.rhs.sha,i.rhs.uri));const[t,s]=await Promise.all([la.git.getVersionedFile(i.repoPath,i.lhs.uri.fsPath,i.lhs.sha),la.git.getVersionedFile(i.repoPath,i.rhs.uri.fsPath,i.rhs.sha)]);let o="";void 0===s?o=ii.isUncommitted(i.rhs.sha)?" (deleted)":"deleted in ":void 0!==t&&i.lhs.sha!==ii.deletedSha||(o="added in ");let a="";if(void 0===t&&""===i.rhs.sha&&(void 0!==s?(a="not in ",o=""):a="deleted in "),void 0===i.lhs.title&&i.lhs.sha!==ii.deletedSha&&(void 0!==t||""!==a)){const e=ii.shortenSha(i.lhs.sha)||"";i.lhs.title=`${Ue.basename(i.lhs.uri.fsPath)}${""!==e?` (${a}${e})`:""}`}if(void 0===i.rhs.title&&i.rhs.sha!==ii.deletedSha){const e=ii.shortenSha(i.rhs.sha,{uncommitted:"working tree"})||"";i.rhs.title=`${Ue.basename(i.rhs.uri.fsPath)}${""!==e?` (${o}${e})`:o}`}const r=void 0!==i.lhs.title&&void 0!==i.rhs.title?`${i.lhs.title} ${K.ArrowLeftRight} ${i.rhs.title}`:i.lhs.title||i.rhs.title;return void 0===i.showOptions&&(i.showOptions={}),void 0===i.showOptions.viewColumn&&(i.showOptions.viewColumn=N.ViewColumn.Active),void 0!==i.line&&0!==i.line&&(i.showOptions.selection=new N.Range(i.line,0,i.line,0)),await N.commands.executeCommand(W.Diff,void 0===t?je.toRevisionUri(ii.deletedSha,i.lhs.uri.fsPath,i.repoPath):N.Uri.file(t),void 0===s?je.toRevisionUri(ii.deletedSha,i.rhs.uri.fsPath,i.repoPath):N.Uri.file(s),r,i.showOptions)}catch(e){return ce.error(e,"DiffWithCommand","getVersionedFile"),N.window.showErrorMessage("Unable to open compare. See output channel for more details")}}}class Ks extends Hi{constructor(){super(ei.DiffWithBranch)}async execute(e,t,i={}){if(void 0===(t=Ni(t,e)))return;void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line);const s=await je.fromUri(t);if(!s.repoPath)return Xi.showNoRepositoryWarningMessage("Unable to open file compare");const o=`Compare ${Ue.basename(s.fsPath)} with ${K.Ellipsis}`,a=Cs.showProgress(o);try{const[e,t]=await Promise.all([la.git.getBranches(s.repoPath),la.git.getTags(s.repoPath)]);if(a.token.isCancellationRequested)return;const r=await Cs.show(e,t,o,{progressCancellation:a,goBackCommand:i.goBackCommand});if(void 0===r)return;if(r instanceof ss)return r.execute();const n=r.name;if(void 0===n)return;let h,c;const l=await la.git.getDiffStatus(s.repoPath,"HEAD",n,{filter:"R"});if(void 0!==l){const e=w.normalizePath(Ue.relative(s.repoPath,s.fsPath)),t=l.find(t=>t.fileName===e);void 0!==t&&void 0!==t.originalFileName&&(h=N.Uri.file(Ue.join(s.repoPath,t.originalFileName)),c=`${Ue.basename(t.originalFileName)} (${n})`)}const d={repoPath:s.repoPath,lhs:{sha:r.remote?`remotes/${n}`:n,uri:h||s,title:c||`${Ue.basename(s.fsPath)} (${n})`},rhs:{sha:"",uri:s},line:i.line,showOptions:i.showOptions};return N.commands.executeCommand(ei.DiffWith,d)}finally{a.dispose()}}}class qs extends Hi{constructor(){super(ei.DiffWithNext)}async execute(e,t,i={}){if(void 0===(t=Ni(t,e)))return;void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line);const s=await je.fromUri(t);let o;if(void 0===i.commit||!(i.commit instanceof it)||void 0!==i.range)try{const a=void 0===i.commit?s.sha:i.commit.sha;if(ii.isStagedUncommitted(a))return N.commands.executeCommand(ei.DiffWithWorking,t);const r=await la.git.getLogForFile(s.repoPath,s.fsPath,{maxCount:void 0!==a?void 0:2,range:i.range,renames:!0});if(void 0===r)return Xi.showFileNotUnderSourceControlWarningMessage("Unable to open compare");if(i.commit=a&&r.commits.get(a)||u.first(r.commits.values()),void 0===s.sha&&void 0!==(o=await la.git.getStatusForFile(s.repoPath,s.fsPath)))return N.commands.executeCommand(ei.DiffWithWorking,t)}catch(e){return ce.error(e,"DiffWithNextCommand",`getLogForFile(${s.repoPath}, ${s.fsPath})`),N.window.showErrorMessage("Unable to open compare. See output channel for more details")}if(void 0===i.commit.nextSha){if(void 0!==(o=o||await la.git.getStatusForFile(s.repoPath,s.fsPath))&&"M"===o.indexStatus){const e={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:ii.stagedUncommittedSha,uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return N.commands.executeCommand(ei.DiffWith,e)}return N.commands.executeCommand(ei.DiffWithWorking,t)}const a={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:i.commit.nextSha,uri:i.commit.nextUri},line:i.line,showOptions:i.showOptions};return N.commands.executeCommand(ei.DiffWith,a)}}class zs extends Hi{constructor(){super(ei.DiffWithPrevious)}async execute(e,t,i={}){if(void 0===(t=Ni(t,e)))return;if(void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line),void 0===i.commit||!i.commit.isFile){const e=await je.fromUri(t);try{let s=void 0===i.commit?e.sha:i.commit.sha;if(s===ii.deletedSha)return Xi.showCommitHasNoPreviousCommitWarningMessage();let o=!1;ii.isStagedUncommitted(s)&&(e.sha=s=void 0,o=!0);const a=await la.git.getLogForFile(e.repoPath,e.fsPath,{maxCount:2,ref:s,renames:!0});if(void 0===a)return Xi.showFileNotUnderSourceControlWarningMessage("Unable to open compare");if(i.commit=s&&a.commits.get(s)||u.first(a.commits.values()),void 0===e.sha){const s=await la.git.getStatusForFile(e.repoPath,e.fsPath);if(void 0!==s){if(o){const e={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:ii.stagedUncommittedSha,uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return N.commands.executeCommand(ei.DiffWith,e)}if(void 0!==s.indexStatus){const e={repoPath:i.commit.repoPath,lhs:{sha:ii.stagedUncommittedSha,uri:i.commit.uri},rhs:{sha:"",uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return N.commands.executeCommand(ei.DiffWith,e)}return N.commands.executeCommand(ei.DiffWithWorking,t,{commit:i.commit,showOptions:i.showOptions})}}}catch(t){return ce.error(t,"DiffWithPreviousCommand",`getLogForFile(${e.repoPath}, ${e.fsPath})`),N.window.showErrorMessage("Unable to open compare. See output channel for more details")}}const s={repoPath:i.commit.repoPath,lhs:{sha:void 0!==i.commit.previousSha?i.commit.previousSha:ii.deletedSha,uri:i.commit.previousUri},rhs:{sha:i.commit.sha,uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return N.commands.executeCommand(ei.DiffWith,s)}}class Ys extends Hi{constructor(){super(ei.DiffWithRevision)}async execute(e,t,i={}){if(void 0===(t=Ni(t,e)))return;void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line);const s=await je.fromUri(t),o=`Compare ${s.getFormattedPath()}${s.sha?` ${w.pad(K.Dot,1,1)} ${s.shortSha}`:""} with ${K.Ellipsis}`,a=Ns.showProgress(o);try{const r=await la.git.getLogForFile(s.repoPath,s.fsPath,{maxCount:i.maxCount,ref:s.sha});if(void 0===r)return Xi.showFileNotUnderSourceControlWarningMessage("Unable to open history compare");if(a.token.isCancellationRequested)return;let n=void 0;if(r.truncated){const e=new ss({label:"$(arrow-right) Show Next Commits",description:`${w.pad(K.Dash,2,3)} shows ${r.maxCount} newer commits`},ei.DiffWithRevision,[t,Object.assign({},i)]),s=u.last(r.commits.values());null!=s&&(n=new ss({label:"$(arrow-left) Show Previous Commits",description:`${w.pad(K.Dash,2,3)} shows ${r.maxCount} older commits`},ei.DiffWithRevision,[new je(t,s),Object.assign({},i,{nextPageCommand:e})]))}const h=await Ns.show(r,s,o,{pickerOnly:!0,progressCancellation:a,currentCommand:new ss({label:`go back ${K.ArrowBack}`,description:`${w.pad(K.Dash,2,3)} to history of ${K.Space}$(file-text) ${s.getFormattedPath()}${s.sha?` from ${K.Space}$(git-commit) ${s.shortSha}`:""}`},ei.DiffWithRevision,[t,Object.assign({},i)]),nextPageCommand:i.nextPageCommand,previousPageCommand:n,showAllCommand:void 0!==r&&r.truncated?new ss({label:"$(sync) Show All Commits",description:`${w.pad(K.Dash,2,3)} this may take a while`},ei.DiffWithRevision,[t,Object.assign({},i,{maxCount:0})]):void 0});if(void 0===h)return;let c;if(h instanceof ms){const e=await h.execute();if(void 0===e)return;if(e instanceof ss)return e.execute();c=e.name}else{if(h instanceof ss)return h.execute();c=h.commit.sha}const l={repoPath:s.repoPath,lhs:{sha:c,uri:s},rhs:{sha:"",uri:s},line:i.line,showOptions:i.showOptions};return await N.commands.executeCommand(ei.DiffWith,l)}catch(e){return ce.error(e,"DiffWithRevisionCommand"),N.window.showErrorMessage("Unable to open compare. See output channel for more details")}finally{a.dispose()}}}class Xs extends Hi{constructor(){super(ei.DiffWithWorking)}async execute(e,t,i={}){if(void 0===(t=Ni(t,e)))return;const s=await je.fromUri(t);if(void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line),void 0===i.commit||ii.isUncommitted(i.commit.sha)){if(void 0===s.sha)return N.window.showInformationMessage("File matches the working tree");if(ii.isStagedUncommitted(s.sha)){s.sha=void 0;const e=await la.git.getStatusForFile(s.repoPath,s.fsPath);if(void 0!==e&&void 0!==e.indexStatus){const e={repoPath:s.repoPath,lhs:{sha:ii.stagedUncommittedSha,uri:s.fileUri()},rhs:{sha:"",uri:s.fileUri()},line:i.line,showOptions:i.showOptions};return N.commands.executeCommand(ei.DiffWith,e)}}try{if(i.commit=await la.git.getLogCommitForFile(s.repoPath,s.fsPath,{ref:s.sha,firstIfNotFound:!0}),void 0===i.commit)return Xi.showFileNotUnderSourceControlWarningMessage("Unable to open compare")}catch(e){return ce.error(e,"DiffWithWorkingCommand",`getLogCommit(${s.repoPath}, ${s.fsPath}, ${s.sha})`),N.window.showErrorMessage("Unable to open compare. See output channel for more details")}}const[o]=await la.git.findWorkingFileName(s.fsPath,s.repoPath);if(void 0===o)return;const a={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:"",uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return N.commands.executeCommand(ei.DiffWith,a)}}var Js,Zs,eo,to;(Zs=Js||(Js={}))[Zs.INDEX_MODIFIED=0]="INDEX_MODIFIED",Zs[Zs.INDEX_ADDED=1]="INDEX_ADDED",Zs[Zs.INDEX_DELETED=2]="INDEX_DELETED",Zs[Zs.INDEX_RENAMED=3]="INDEX_RENAMED",Zs[Zs.INDEX_COPIED=4]="INDEX_COPIED",Zs[Zs.MODIFIED=5]="MODIFIED",Zs[Zs.DELETED=6]="DELETED",Zs[Zs.UNTRACKED=7]="UNTRACKED",Zs[Zs.IGNORED=8]="IGNORED",Zs[Zs.ADDED_BY_US=9]="ADDED_BY_US",Zs[Zs.ADDED_BY_THEM=10]="ADDED_BY_THEM",Zs[Zs.DELETED_BY_US=11]="DELETED_BY_US",Zs[Zs.DELETED_BY_THEM=12]="DELETED_BY_THEM",Zs[Zs.BOTH_ADDED=13]="BOTH_ADDED",Zs[Zs.BOTH_DELETED=14]="BOTH_DELETED",Zs[Zs.BOTH_MODIFIED=15]="BOTH_MODIFIED",(to=eo||(eo={}))[to.Merge=0]="Merge",to[to.Index=1]="Index",to[to.WorkingTree=2]="WorkingTree";class io{constructor(e,t){this.uri=e,this.staged=t}}class so extends Wi{constructor(){super(ei.ExternalDiff)}async preExecute(e,t={}){return"scm-states"===e.type?((t=Object.assign({},t)).files=e.scmResourceStates.map(e=>new io(e.resourceUri,e.resourceGroupType===eo.Index)),this.execute(t)):"scm-groups"===e.type?((t=Object.assign({},t)).files=o.filterMap(e.scmResourceGroups[0].resourceStates,e=>this.isModified(e)?new io(e.resourceUri,e.resourceGroupType===eo.Index):void 0),this.execute(t)):this.execute(t)}isModified(e){const t=e.type;return t===Js.BOTH_MODIFIED||t===Js.INDEX_MODIFIED||t===Js.MODIFIED}async execute(e={}){try{const t=await la.git.getRepoPath(void 0);if(!t)return Xi.showNoRepositoryWarningMessage("Unable to open external file compare");const i=await la.git.getDiffTool(t);if(void 0===i){if(!await N.window.showWarningMessage("Unable to open external file compare because there is no Git diff tool configured","View Git Docs"))return;return N.commands.executeCommand(W.Open,N.Uri.parse("https://git-scm.com/docs/git-config#git-config-difftool"))}if(void 0===e.files){const i=await la.git.getStatusForRepo(t);if(void 0===i)return N.window.showWarningMessage("Unable to open external file compare");e.files=[];for(const t of i.files)"M"===t.indexStatus&&e.files.push(new io(t.uri,!0)),"M"===t.workTreeStatus&&e.files.push(new io(t.uri,!1))}for(const s of e.files)la.git.openDiffTool(t,s.uri,s.staged,i);return}catch(e){return ce.error(e,"ExternalDiffCommand"),N.window.showErrorMessage("Unable to open external file compare. See output channel for more details")}}}class oo extends Hi{constructor(){super(ei.OpenChangedFiles)}async execute(e,t,i={}){t=Ni(t,e);try{if(void 0===i.uris){i=Object.assign({},i);const e=await la.git.getRepoPath(t);if(!e)return Xi.showNoRepositoryWarningMessage("Unable to open changed files");const s=await la.git.getStatusForRepo(e);if(void 0===s)return N.window.showWarningMessage("Unable to open changed files");i.uris=o.filterMap(s.files,e=>"D"!==e.status?e.uri:void 0)}for(const e of i.uris)await Qi(e,{preserveFocus:!0,preview:!1});return}catch(e){return ce.error(e,"OpenChangedFilesCommand"),N.window.showErrorMessage("Unable to open changed files. See output channel for more details")}}}class ao extends Hi{constructor(){super(ei.OpenBranchesInRemote)}async preExecute(e,t={}){return Oi(e)&&((t=Object.assign({},t)).remote=e.node.remote.name),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){const s=(t=Ni(t,e))&&await je.fromUri(t),o=void 0===s?la.git.getHighlanderRepoPath():s.repoPath;if(o)try{const s=await la.git.getRemotes(o);return N.commands.executeCommand(ei.OpenInRemote,t,{resource:{type:"branches"},remote:i.remote,remotes:s})}catch(e){return ce.error(e,"OpenBranchesInRemoteCommand"),N.window.showErrorMessage("Unable to open branches in remote provider. See output channel for more details")}}}class ro extends Hi{constructor(){super(ei.OpenBranchInRemote)}async preExecute(e,t={}){return Ui(e)&&((t=Object.assign({},t)).branch=e.node.branch.name,t.remote=e.node.branch.getRemote()),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){const s=(t=Ni(t,e))&&await je.fromUri(t),o=void 0===s?la.git.getHighlanderRepoPath():s.repoPath;if(o)try{if(void 0===i.branch){i=Object.assign({},i);const e=await la.git.getBranches(o),t=await ys.show(e,`Show history for branch${K.Ellipsis}`);if(void 0===t)return;if(t instanceof ss)return;if(i.branch=t.branch.name,void 0===i.branch)return}const s=await la.git.getRemotes(o);return N.commands.executeCommand(ei.OpenInRemote,t,{resource:{type:"branch",branch:i.branch},remote:i.remote,remotes:s})}catch(e){return ce.error(e,"OpenBranchInRemoteCommandArgs"),N.window.showErrorMessage("Unable to open branch in remote provider. See output channel for more details")}}}class no extends Hi{static getMarkdownCommandArgs(e){const t="string"==typeof e?{sha:e}:e;return super.getMarkdownCommandArgsCore(ei.OpenCommitInRemote,t)}constructor(){super(ei.OpenCommitInRemote)}async preExecute(e,t={}){return Li(e)?((t=Object.assign({},t)).sha=e.node.commit.sha,this.execute(e.editor,e.node.commit.uri,t)):this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(void 0===(t=Ni(t,e)))return;const s=await je.fromUri(t);if(s.repoPath)try{if(void 0===i.sha){const t=void 0===e?0:e.selection.active.line;if(t<0)return;const o=e&&e.document&&e.document.isDirty?await la.git.getBlameForLineContents(s,t,e.document.getText()):await la.git.getBlameForLine(s,t);if(void 0===o)return Xi.showFileNotUnderSourceControlWarningMessage("Unable to open commit in remote provider");let a=o.commit;a.isUncommitted&&(a=a.with({sha:a.previousSha,fileName:a.previousFileName,previousSha:null,previousFileName:null})),i.sha=a.sha}const o=await la.git.getRemotes(s.repoPath);return N.commands.executeCommand(ei.OpenInRemote,t,{resource:{type:"commit",sha:i.sha},remotes:o})}catch(e){return ce.error(e,"OpenCommitInRemoteCommand"),N.window.showErrorMessage("Unable to open commit in remote provider. See output channel for more details")}}}class ho extends Hi{constructor(){super(ei.OpenFileInRemote)}async preExecute(e,t={range:!0}){return Li(e)?((t=Object.assign({},t)).range=!1,Ui(e)&&(t.branch=void 0!==e.node.branch?e.node.branch.name:void 0),this.execute(e.editor,e.node.commit.uri,t)):this.execute(e.editor,e.uri,t)}async execute(e,t,i={range:!0}){if(void 0===(t=Ni(t,e)))return;const s=await je.fromUri(t);if(s.repoPath){if(void 0===i.branch){const e=await la.git.getBranch(s.repoPath);void 0!==e&&(i.branch=e.name)}try{const o=await la.git.getRemotes(s.repoPath),a=i.range&&void 0!==e?new N.Range(e.selection.start.with({line:e.selection.start.line+1}),e.selection.end.with({line:e.selection.end.line+1})):void 0;return N.commands.executeCommand(ei.OpenInRemote,t,{resource:{type:void 0===s.sha?"file":"revision",branch:i.branch,fileName:s.getRelativePath(),range:a,sha:s.sha},remotes:o})}catch(e){return ce.error(e,"OpenFileInRemoteCommand"),N.window.showErrorMessage("Unable to open file in remote provider. See output channel for more details")}}}}class co extends Hi{static getMarkdownCommandArgs(e,t,i){let s;return s=e instanceof N.Uri?{uri:e,line:i,annotationType:t}:e,super.getMarkdownCommandArgsCore(ei.OpenFileRevision,s)}constructor(){super(ei.OpenFileRevision)}async execute(e,t,i={}){let s;void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line);try{if(void 0===i.uri){if(void 0===(t=Ni(t,e)))return;const o=await je.fromUri(t),a=`Open ${o.getFormattedPath()}${o.sha?` ${w.pad(K.Dot,1,1)} ${o.shortSha}`:""} in revision ${K.Ellipsis}`;s=Ns.showProgress(a);const r=await la.git.getLogForFile(o.repoPath,o.fsPath,{maxCount:i.maxCount,ref:o.sha});if(void 0===r)return Xi.showFileNotUnderSourceControlWarningMessage("Unable to open history compare");if(s.token.isCancellationRequested)return;let n=void 0;if(r.truncated){const e=new ss({label:"$(arrow-right) Show Next Commits",description:`${w.pad(K.Dash,2,3)} shows ${r.maxCount} newer commits`},ei.OpenFileRevision,[t,Object.assign({},i)]),s=u.last(r.commits.values());null!=s&&(n=new ss({label:"$(arrow-left) Show Previous Commits",description:`${w.pad(K.Dash,2,3)} shows ${r.maxCount} older commits`},ei.OpenFileRevision,[new je(t,s),Object.assign({},i,{nextPageCommand:e})]))}const h=await Ns.show(r,o,a,{pickerOnly:!0,progressCancellation:s,currentCommand:new ss({label:`go back ${K.ArrowBack}`,description:`${w.pad(K.Dash,2,3)} to history of ${K.Space}$(file-text) ${o.getFormattedPath()}${o.sha?` from ${K.Space}$(git-commit) ${o.shortSha}`:""}`},ei.OpenFileRevision,[t,Object.assign({},i)]),nextPageCommand:i.nextPageCommand,previousPageCommand:n,showAllCommand:void 0!==r&&r.truncated?new ss({label:"$(sync) Show All Commits",description:`${w.pad(K.Dash,2,3)} this may take a while`},ei.OpenFileRevision,[t,Object.assign({},i,{maxCount:0})]):void 0});if(void 0===h)return;if(h instanceof ms){const e=await h.execute();if(void 0===e)return;if(e instanceof ss)return e.execute();i.uri=je.toRevisionUri(e.name,o.fsPath,o.repoPath)}else{if(h instanceof ss)return h.execute();i.uri=je.toRevisionUri(h.commit.sha,h.commit.uri.fsPath,h.commit.repoPath)}}void 0!==i.line&&0!==i.line&&(void 0===i.showOptions&&(i.showOptions={}),i.showOptions.selection=new N.Range(i.line,0,i.line,0));const o=await Qi(i.uri,Object.assign({},i.showOptions,{rethrow:!0}));return void 0===i.annotationType?o:la.annotations.showAnnotations(o,i.annotationType,i.line)}catch(e){return ce.error(e,"OpenFileRevisionCommand"),N.window.showErrorMessage("Unable to open file revision. See output channel for more details")}finally{s&&s.dispose()}}}class lo extends Hi{constructor(){super(ei.OpenInRemote)}async execute(e,t,i={}){if(void 0!==(i=Object.assign({},i)).remotes&&void 0!==i.resource){if(void 0!==i.remote){const e=i.remotes.filter(e=>e.name===i.remote);e.length>0&&(i.remotes=e)}try{if(1===i.remotes.length)return this.ensureRemoteBranchName(i),new xs(i.remotes[0],i.resource).execute();let t="";switch(i.resource.type){case pe.Branch:this.ensureRemoteBranchName(i),t=`open ${i.resource.branch} branch in${K.Ellipsis}`;break;case pe.Commit:t=`open commit ${ii.shortenSha(i.resource.sha)} in${K.Ellipsis}`;break;case pe.File:t=`open ${i.resource.fileName} in${K.Ellipsis}`;break;case pe.Revision:if(void 0!==i.resource.commit&&i.resource.commit instanceof it)"D"===i.resource.commit.status?(i.resource.sha=i.resource.commit.previousSha,t=`open ${i.resource.fileName} ${w.pad(K.Dot,1,1)} ${i.resource.commit.previousShortSha} in${K.Ellipsis}`):(i.resource.sha=i.resource.commit.sha,t=`open ${i.resource.fileName} ${w.pad(K.Dot,1,1)} ${i.resource.commit.shortSha} in${K.Ellipsis}`);else{const e=void 0===i.resource.sha?"":ii.shortenSha(i.resource.sha),s=e?` ${w.pad(K.Dot,1,1)} ${e}`:"";t=`open ${i.resource.fileName}${s} in${K.Ellipsis}`}}if(1===i.remotes.length)return new xs(i.remotes[0],i.resource).execute();const s=await $s.show(i.remotes,t,i.resource,i.goBackCommand);if(void 0===s)return;return s.execute()}catch(e){return ce.error(e,"OpenInRemoteCommand"),N.window.showErrorMessage("Unable to open in remote provider. See output channel for more details")}}}ensureRemoteBranchName(e){if(void 0===e.remotes||void 0===e.resource||"branch"!==e.resource.type)return;const t=e.resource.branch.indexOf("/");if(t>=0){const i=e.resource.branch.substring(0,t),s=e.remotes.find(e=>e.name===i);void 0!==s&&(e.resource.branch=e.resource.branch.substring(t+1),e.remotes=[s])}}}class mo extends Hi{constructor(){super(ei.OpenRepoInRemote)}async preExecute(e,t={}){return Oi(e)&&((t=Object.assign({},t)).remote=e.node.remote.name),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){const s=(t=Ni(t,e))&&await je.fromUri(t),o=void 0===s?la.git.getHighlanderRepoPath():s.repoPath;if(o)try{const s=await la.git.getRemotes(o);return N.commands.executeCommand(ei.OpenInRemote,t,{resource:{type:"repo"},remote:i.remote,remotes:s})}catch(e){return ce.error(e,"OpenRepoInRemoteCommand"),N.window.showErrorMessage("Unable to open repository in remote provider. See output channel for more details")}}}class uo extends Hi{constructor(){super(ei.OpenWorkingFile)}async execute(e,t,i={}){void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line);try{if(void 0===i.uri){if(void 0===(t=Ni(t,e)))return;if(i.uri=await je.fromUri(t),i.uri instanceof je&&i.uri.sha){const[e,t]=await la.git.findWorkingFileName(i.uri.fsPath,i.uri.repoPath);void 0!==e&&void 0!==t&&(i.uri=new je(N.Uri.file(Ue.resolve(t,e)),t))}}void 0!==i.line&&0!==i.line&&(void 0===i.showOptions&&(i.showOptions={}),i.showOptions.selection=new N.Range(i.line,0,i.line,0));const s=await Qi(i.uri,Object.assign({},i.showOptions,{rethrow:!0}));return void 0===i.annotationType?s:la.annotations.showAnnotations(s,i.annotationType,i.line)}catch(e){return ce.error(e,"OpenWorkingFileCommand"),N.window.showErrorMessage("Unable to open working file. See output channel for more details")}}}class go extends Wi{constructor(){super(ei.ResetSuppressedWarnings)}async execute(){await ua.update(ua.name("advanced")("messages").value,void 0,N.ConfigurationTarget.Global)}}const po=/^([@~=:#])/,fo=new Map([["@",Qt.Author],["~",Qt.Changes],["=",Qt.ChangedOccurrences],[":",Qt.Files],["#",Qt.Sha]]);class vo extends Gi{constructor(){super(ei.ShowCommitSearch)}async execute(e,t,i={}){const s=void 0===(t=Ni(t,e))?void 0:await je.fromUri(t);let o=void 0===s?la.git.getHighlanderRepoPath():s.repoPath;if(!o){const e=await Ls.show(`Search for commits in which repository${K.Ellipsis}`,i.goBackCommand);if(e instanceof ss)return e.execute();if(void 0===e)return void 0===i.goBackCommand?void 0:i.goBackCommand.execute();o=e.repoPath}i=Object.assign({},i);const a=Object.assign({},i);if(!i.search||null==i.searchBy){try{if(!i.search&&void 0!==e&&void 0!==s){const t=await la.git.getBlameForLine(s,e.selection.active.line);void 0===t||t.commit.isUncommitted||(i.search=`#${t.commit.shortSha}`)}}catch(e){ce.error(e,"ShowCommitSearchCommand","search prefetch failed")}if(i.search=await N.window.showInputBox({value:i.search,prompt:"Please enter a search string",placeHolder:"search by message, author (@<pattern>), files (:<pattern>), commit id (#<sha>), changes (~<pattern>), or changed occurrences (=<string>)"}),void 0===i.search)return void 0===i.goBackCommand?void 0:i.goBackCommand.execute();a.search=i.search;const t=po.exec(i.search);t&&t[1]?(i.searchBy=fo.get(t[1]),i.search=i.search.substring(" "===i.search[1]?2:1)):ii.isSha(i.search)?i.searchBy=Qt.Sha:i.searchBy=Qt.Message}void 0===i.searchBy&&(i.searchBy=Qt.Message);let r=void 0;switch(i.searchBy){case Qt.Author:r=`commits with an author matching '${i.search}'`;break;case Qt.Changes:r=`commits with changes matching '${i.search}'`;break;case Qt.ChangedOccurrences:r=`commits with changed occurrences matching '${i.search}'`;break;case Qt.Files:r=`commits with files matching '${i.search}'`;break;case Qt.Message:r=`commits with a message matching '${i.search}'`;break;case Qt.Sha:r=`commits with an id matching '${i.search}'`}const n=As.showProgress(r);try{const s=await la.git.getLogForSearch(o,i.search,i.searchBy,{maxCount:i.maxCount});if(n.token.isCancellationRequested)return;const h=i.goBackCommand||new ss({label:`go back ${K.ArrowBack}`,description:`${w.pad(K.Dash,2,3)} to commit search`},ei.ShowCommitSearch,[t,a]),c=await As.show(s,r,n,{goBackCommand:h,showAllCommand:void 0!==s&&s.truncated?new ss({label:"$(sync) Show All Commits",description:`${w.pad(K.Dash,2,3)} this may take a while`},ei.ShowCommitSearch,[t,Object.assign({},i,{maxCount:0,goBackCommand:h})]):void 0,showInResultsExplorerCommand:void 0!==s?new ds(s,r):void 0});if(void 0===c)return;return c instanceof ss?c.execute():N.commands.executeCommand(ei.ShowQuickCommitDetails,c.commit.toGitUri(),{sha:c.commit.sha,commit:c.commit,goBackCommand:new ss({label:`go back ${K.ArrowBack}`,description:`${w.pad(K.Dash,2,2)} to search for ${r}`},ei.ShowCommitSearch,[t,i])})}catch(e){return ce.error(e,"ShowCommitSearchCommand"),N.window.showErrorMessage("Unable to find commits. See output channel for more details")}finally{n.dispose()}}}class wo extends Vi{constructor(){super(ei.ShowFileBlame)}async execute(e,t,i,s={}){if(void 0!==e)try{return void 0===s.type&&(s=Object.assign({},s,{type:P.Blame})),la.annotations.showAnnotations(e,s.type,void 0!==s.sha?s.sha:e.selection.active.line)}catch(e){return ce.error(e,"ShowFileBlameCommand"),N.window.showErrorMessage("Unable to show file blame annotations. See output channel for more details")}}}class Co extends Wi{constructor(){super(ei.ShowLastQuickPick)}async execute(){const e=ji;if(void 0!==e)try{return N.commands.executeCommand(e.command,...e.args)}catch(e){return ce.error(e,"ShowLastQuickPickCommand"),N.window.showErrorMessage("Unable to show last quick pick. See output channel for more details")}}}class bo extends Hi{constructor(){super(ei.ShowLineBlame)}async execute(e,t){try{return la.lineAnnotations.showAnnotations(e)}catch(e){return ce.error(e,"ShowLineBlameCommand"),N.window.showErrorMessage("Unable to show line blame annotations. See output channel for more details")}}}class yo extends Gi{constructor(){super(ei.ShowQuickBranchHistory)}async execute(e,t,i={}){const s=(t=Ni(t,e))&&await je.fromUri(t);let o=void 0===(i=Object.assign({},i)).branch?void 0:Ds.showProgress(i.branch);try{const a=void 0===s?la.git.getHighlanderRepoPath():s.repoPath;if(!a)return Xi.showNoRepositoryWarningMessage("Unable to show branch history");if(void 0===i.branch){const e=await la.git.getBranches(a),t=await ys.show(e,`Show history for branch${K.Ellipsis}`);if(void 0===t)return;if(t instanceof ss)return t.execute();if(i.branch=t.branch.name,void 0===i.branch)return;o=Ds.showProgress(i.branch)}if(void 0===i.log&&(i.log=await la.git.getLog(a,{maxCount:i.maxCount,ref:s&&s.sha||i.branch}),void 0===i.log))return N.window.showWarningMessage("Unable to show branch history");if(void 0!==o&&o.token.isCancellationRequested)return;const r=await Ds.show(i.log,s,i.branch,o,i.goBackCommand,i.nextPageCommand);if(void 0===r)return;if(r instanceof ss)return r.execute();const n=new ss({label:`go back ${K.ArrowBack}`,description:`${w.pad(K.Dash,2,3)} to ${K.Space}$(git-branch) ${i.branch} history`},ei.ShowQuickBranchHistory,[t,Object.assign({},i)]);return N.commands.executeCommand(ei.ShowQuickCommitDetails,r.commit.toGitUri(),{sha:r.commit.sha,commit:r.commit,repoLog:i.log,goBackCommand:n})}catch(e){return ce.error(e,"ShowQuickBranchHistoryCommand"),N.window.showErrorMessage("Unable to show branch history. See output channel for more details")}finally{o&&o.dispose()}}}class xo extends Gi{static getMarkdownCommandArgs(e){const t="string"==typeof e?{sha:e}:e;return super.getMarkdownCommandArgsCore(ei.ShowQuickCommitDetails,t)}constructor(){super(ei.ShowQuickCommitDetails)}async preExecute(e,t={}){return"view"===e.type&&((t=Object.assign({},t)).sha=e.node.uri.sha,Li(e)&&(t.commit=e.node.commit)),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(void 0===(t=Ni(t,e)))return;const s=await je.fromUri(t);let o=s.repoPath,a=Ue.relative(o||"",s.fsPath);if(void 0===(i=Object.assign({},i)).sha){if(void 0===e)return;const t=e.selection.active.line;if(t<0)return;try{const r=await la.git.getBlameForLine(s,t);if(void 0===r)return Xi.showFileNotUnderSourceControlWarningMessage("Unable to show commit details");if(r.commit.isUncommitted)return Xi.showLineUncommittedWarningMessage("Unable to show commit details");i.sha=r.commit.sha,o=r.commit.repoPath,a=r.commit.fileName,i.commit=r.commit}catch(e){return ce.error(e,"ShowQuickCommitDetailsCommand",`getBlameForLine(${t})`),N.window.showErrorMessage("Unable to show commit details. See output channel for more details")}}try{if((void 0===i.commit||i.commit.isFile)&&(void 0!==i.repoLog&&(i.commit=i.repoLog.commits.get(i.sha),void 0===i.commit&&(i.repoLog=void 0)),void 0===i.repoLog)){const e=await la.git.getLog(o,{maxCount:2,ref:i.sha});if(void 0===e)return Xi.showCommitNotFoundWarningMessage("Unable to show commit details");i.commit=e.commits.get(i.sha)}if(void 0===i.commit)return Xi.showCommitNotFoundWarningMessage("Unable to show commit details");void 0===i.commit.workingFileName&&(i.commit.workingFileName=a),void 0===i.goBackCommand&&(i.goBackCommand=new ss({label:`go back ${K.ArrowBack}`,description:`${w.pad(K.Dash,2,3)} to branch history`},ei.ShowQuickCurrentBranchHistory,[i.commit.toGitUri()]));const s=new ss({label:`go back ${K.ArrowBack}`,description:`${w.pad(K.Dash,2,3)} to details of ${K.Space}$(git-commit) ${i.commit.shortSha}`},ei.ShowQuickCommitDetails,[i.commit.toGitUri(),i]),r=await Bs.show(i.commit,t,i.goBackCommand,s,i.repoLog);if(void 0===r)return;return r instanceof Rs?N.commands.executeCommand(ei.ShowQuickCommitFileDetails,r.commit.toGitUri(),{commit:r.commit,sha:r.sha,goBackCommand:s}):r.execute()}catch(e){return ce.error(e,"ShowQuickCommitDetailsCommand"),N.window.showErrorMessage("Unable to show commit details. See output channel for more details")}}}class So extends Gi{static getMarkdownCommandArgs(e){const t="string"==typeof e?{sha:e}:e;return super.getMarkdownCommandArgsCore(ei.ShowQuickCommitFileDetails,t)}constructor(){super(ei.ShowQuickCommitFileDetails)}async preExecute(e,t={}){return"view"===e.type&&((t=Object.assign({},t)).sha=e.node.uri.sha,Li(e)&&(t.commit=e.node.commit)),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(void 0===(t=Ni(t,e)))return;let s=i.commit&&i.commit.workingFileName;const o=await je.fromUri(t);if(void 0===(i=Object.assign({},i)).sha){if(void 0===e)return;const t=e.selection.active.line;if(t<0)return;try{const a=await la.git.getBlameForLine(o,t);if(void 0===a)return Xi.showFileNotUnderSourceControlWarningMessage("Unable to show commit file details");if(a.commit.isUncommitted)return Xi.showLineUncommittedWarningMessage("Unable to show commit file details");i.sha=a.commit.sha,i.commit=a.commit,s=Ue.relative(i.commit.repoPath,o.fsPath)}catch(e){return ce.error(e,"ShowQuickCommitFileDetailsCommand",`getBlameForLine(${t})`),N.window.showErrorMessage("Unable to show commit file details. See output channel for more details")}}try{if((void 0===i.commit||!i.commit.isFile)&&(void 0!==i.commit&&(s=void 0),void 0!==i.fileLog&&(i.commit=i.fileLog.commits.get(i.sha),void 0===i.commit&&(i.fileLog=void 0)),void 0===i.fileLog&&(i.commit=await la.git.getLogCommitForFile(void 0===i.commit?o.repoPath:i.commit.repoPath,o.fsPath,{ref:i.sha}),void 0===i.commit)))return Xi.showCommitNotFoundWarningMessage("Unable to show commit file details");if(void 0===i.commit)return Xi.showCommitNotFoundWarningMessage("Unable to show commit file details");i.commit.workingFileName=s,[i.commit.workingFileName]=await la.git.findWorkingFileName(i.commit);const a=ii.shortenSha(i.sha);void 0===i.goBackCommand&&(i.goBackCommand=new ss({label:`go back ${K.ArrowBack}`,description:`${w.pad(K.Dash,2,3)} to details of ${K.Space}$(git-commit) ${a}`},ei.ShowQuickCommitDetails,[i.commit.toGitUri(),{commit:i.commit,sha:i.sha}]));const r=new ss({label:`go back ${K.ArrowBack}`,description:`${w.pad(K.Dash,2,3)} to details of ${K.Space}$(file-text) ${Ue.basename(i.commit.fileName)} in ${K.Space}$(git-commit) ${a}`},ei.ShowQuickCommitFileDetails,[i.commit.toGitUri(),i]),n=await _s.show(i.commit,t,i.goBackCommand,r,i.fileLog);if(void 0===n)return;return n instanceof ss?n.execute():void 0}catch(e){return ce.error(e,"ShowQuickCommitFileDetailsCommand"),N.window.showErrorMessage("Unable to show commit file details. See output channel for more details")}}}class $o extends Gi{constructor(){super(ei.ShowQuickCurrentBranchHistory)}async execute(e,t,i={}){t=Ni(t,e);try{const s=await la.git.getRepoPath(t);if(!s)return Xi.showNoRepositoryWarningMessage("Unable to show branch history");const o=await la.git.getBranch(s);if(void 0===o)return;return N.commands.executeCommand(ei.ShowQuickBranchHistory,t,{branch:o.name,goBackCommand:i.goBackCommand})}catch(e){return ce.error(e,"ShowQuickCurrentBranchHistoryCommand"),N.window.showErrorMessage("Unable to show branch history. See output channel for more details")}}}class Do extends Gi{constructor(){super(ei.ShowQuickFileHistory)}async execute(e,t,i={}){if(void 0===(t=Ni(t,e)))return N.commands.executeCommand(ei.ShowQuickCurrentBranchHistory);const s=await je.fromUri(t);i=Object.assign({},i);const o=`${s.getFormattedPath()}${s.sha?` ${w.pad(K.Dot,1,1)} ${s.shortSha}`:""}`,a=Ns.showProgress(o);try{if(void 0===i.log&&(i.log=await la.git.getLogForFile(s.repoPath,s.fsPath,{maxCount:i.maxCount,range:i.range,ref:s.sha}),void 0===i.log))return Xi.showFileNotUnderSourceControlWarningMessage("Unable to show file history");if(a.token.isCancellationRequested)return;let r=void 0;if(i.log.truncated){const e=new ss({label:"$(arrow-right) Show Next Commits",description:`${w.pad(K.Dash,2,3)} shows ${i.log.maxCount} newer commits`},ei.ShowQuickFileHistory,[s,Object.assign({},i,{log:void 0})]),o=u.last(i.log.commits.values());null!=o&&(r=new ss({label:"$(arrow-left) Show Previous Commits",description:`${w.pad(K.Dash,2,3)} shows ${i.log.maxCount} older commits`},ei.ShowQuickFileHistory,[new je(t,o),Object.assign({},i,{log:void 0,nextPageCommand:e})]))}const n=await Ns.show(i.log,s,o,{progressCancellation:a,goBackCommand:i.goBackCommand,nextPageCommand:i.nextPageCommand,previousPageCommand:r,showAllCommand:void 0!==i.log&&i.log.truncated?new ss({label:"$(sync) Show All Commits",description:`${w.pad(K.Dash,2,3)} this may take a while`},ei.ShowQuickFileHistory,[t,Object.assign({},i,{log:void 0,maxCount:0})]):void 0,showInResultsExplorerCommand:void 0!==i.log?new ls(i.log,{label:o,resultsType:{singular:"commit",plural:"commits"}}):void 0});if(void 0===n)return;if(n instanceof ss)return n.execute();const h=new ss({label:`go back ${K.ArrowBack}`,description:`${w.pad(K.Dash,2,3)} to history of ${K.Space}$(file-text) ${Ue.basename(n.commit.fileName)}${s.sha?` from ${K.Space}$(git-commit) ${s.shortSha}`:""}`},ei.ShowQuickFileHistory,[t,i]);return N.commands.executeCommand(ei.ShowQuickCommitFileDetails,n.commit.toGitUri(),{commit:n.commit,fileLog:i.log,sha:n.commit.sha,goBackCommand:h})}catch(e){return ce.error(e,"ShowQuickFileHistoryCommand"),N.window.showErrorMessage("Unable to show file history. See output channel for more details")}finally{a.dispose()}}}class Fo extends Gi{constructor(){super(ei.ShowQuickRepoStatus)}async execute(e,t,i={}){t=Ni(t,e);try{const s=await la.git.getRepoPath(t);if(!s)return Xi.showNoRepositoryWarningMessage("Unable to show repository status");const o=await la.git.getStatusForRepo(s);if(void 0===o)return N.window.showWarningMessage("Unable to show repository status");const a=await Ms.show(o,i.goBackCommand);if(void 0===a)return;return a instanceof ss?a.execute():void 0}catch(e){return ce.error(e,"ShowQuickRepoStatusCommand"),N.window.showErrorMessage("Unable to show repository status. See output channel for more details")}}}class ko extends Gi{constructor(){super(ei.ShowQuickStashList)}async execute(e,t,i={}){t=Ni(t,e);const s=Ws.showProgress("list");try{const o=await la.git.getRepoPath(t);if(!o)return Xi.showNoRepositoryWarningMessage("Unable to show stashed changes");const a=await la.git.getStashList(o);if(void 0===a)return N.window.showWarningMessage("Unable to show stashed changes");if(s.token.isCancellationRequested)return;const r=new ss({label:`go back ${K.ArrowBack}`,description:`${w.pad(K.Dash,2,3)} to stashed changes`},ei.ShowQuickStashList,[t,{goBackCommand:i.goBackCommand}]),n=await Ws.show(a,"list",s,i.goBackCommand,r);if(void 0===n)return;return n instanceof ss?n.execute():N.commands.executeCommand(ei.ShowQuickCommitDetails,n.commit.toGitUri(),{commit:n.commit,sha:n.commit.sha,goBackCommand:r})}catch(e){return ce.error(e,"ShowQuickStashListCommand"),N.window.showErrorMessage("Unable to show stashed changes. See output channel for more details")}finally{s.dispose()}}}class Po extends Wi{constructor(){super(ei.StashApply)}async preExecute(e,t={confirm:!0,deleteAfter:!1}){return Li(e)?((t=Object.assign({},t)).stashItem=e.node.commit,this.execute(t)):this.execute(t)}async execute(e={confirm:!0,deleteAfter:!1}){if(void 0===(e=Object.assign({},e)).stashItem||void 0===e.stashItem.stashName){let t,i=await la.git.getActiveRepoPath();if(!i){const s=await Ls.show(`Apply stashed changes from which repository${K.Ellipsis}`,e.goBackCommand);if(s instanceof ss)return s.execute();if(void 0===s)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute();t=new ss({label:`go back ${K.ArrowBack}`,description:`${w.pad(K.Dash,2,3)} to pick another repository`},ei.StashApply,[e]),i=s.repoPath}const s=Ws.showProgress("apply");try{const o=await la.git.getStashList(i);if(void 0===o)return N.window.showInformationMessage("There are no stashed changes");if(s.token.isCancellationRequested)return;const a=new ss({label:`go back ${K.ArrowBack}`,description:`${w.pad(K.Dash,2,3)} to apply stashed changes`},ei.StashApply,[e]),r=await Ws.show(o,"apply",s,t||e.goBackCommand,a);if(r instanceof ss)return r.execute();if(void 0===r)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute();e.goBackCommand=a,e.stashItem=r.commit}finally{s.dispose()}}try{if(e.confirm){const t=e.stashItem.message.length>80?`${e.stashItem.message.substring(0,80)}${K.Ellipsis}`:e.stashItem.message,i=await N.window.showWarningMessage(`Apply stashed changes '${t}' to your working tree?`,{title:"Yes, delete after applying"},{title:"Yes"},{title:"No",isCloseAffordance:!0});if(void 0===i||"No"===i.title)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute();e.deleteAfter="Yes"!==i.title}return await la.git.stashApply(e.stashItem.repoPath,e.stashItem.stashName,e.deleteAfter)}catch(e){return ce.error(e,"StashApplyCommand"),e.message.includes("Your local changes to the following files would be overwritten by merge")?N.window.showWarningMessage("Unable to apply stash. Your working tree changes would be overwritten."):e.message.includes("Auto-merging")&&e.message.includes("CONFLICT")?N.window.showInformationMessage("Stash applied with conflicts"):N.window.showErrorMessage("Unable to apply stash. See output channel for more details")}}}class _o extends Wi{constructor(){super(ei.StashDelete)}async preExecute(e,t={confirm:!0}){return Li(e)?((t=Object.assign({},t)).stashItem=e.node.commit,this.execute(t)):this.execute(t)}async execute(e={confirm:!0}){if(void 0!==(e=Object.assign({},e)).stashItem&&void 0!==e.stashItem.stashName&&void 0!==e.stashItem.repoPath){void 0===e.confirm&&(e.confirm=!0);try{if(e.confirm){const t=e.stashItem.message.length>80?`${e.stashItem.message.substring(0,80)}${K.Ellipsis}`:e.stashItem.message,i=await N.window.showWarningMessage(`Delete stashed changes '${t}'?`,{title:"Yes"},{title:"No",isCloseAffordance:!0});if(void 0===i||"Yes"!==i.title)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute()}return await la.git.stashDelete(e.stashItem.repoPath,e.stashItem.stashName)}catch(e){return ce.error(e,"StashDeleteCommand"),N.window.showErrorMessage("Unable to delete stash. See output channel for more details")}}}}class Ro extends Wi{constructor(){super(ei.StashSave)}async preExecute(e,t={}){return"scm-states"===e.type?((t=Object.assign({},t)).uris=e.scmResourceStates.map(e=>e.resourceUri),this.execute(t)):"scm-groups"===e.type?((t=Object.assign({},t)).uris=e.scmResourceGroups.reduce((e,t)=>e.concat(t.resourceStates.map(e=>e.resourceUri)),[]),this.execute(t)):this.execute(t)}async execute(e={}){let t=await la.git.getHighlanderRepoPath();if(!t){const i=await Ls.show(`Stash changes for which repository${K.Ellipsis}`,e.goBackCommand);if(i instanceof ss)return i.execute();if(void 0===i)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute();t=i.repoPath}try{return null==e.message&&((e=Object.assign({},e)).message=await N.window.showInputBox({prompt:"Please provide a stash message",placeHolder:"Stash message"}),void 0===e.message)?void 0===e.goBackCommand?void 0:e.goBackCommand.execute():await la.git.stashSave(t,e.message,e.uris)}catch(e){return ce.error(e,"StashSaveCommand"),N.window.showErrorMessage("Unable to save stash. See output channel for more details")}}}class To extends Wi{constructor(){super(ei.ToggleCodeLens)}execute(){return la.codeLens.toggleCodeLens()}}class Eo extends Hi{constructor(){super(ei.ToggleFileBlame)}async execute(e,t,i={}){if(void 0!==e&&void 0!==t&&!oe.equals(t,e.document.uri)){const i=N.window.visibleTextEditors.find(e=>oe.equals(t,e.document.uri));void 0!==i&&(e=i)}try{return void 0===i.type&&(i=Object.assign({},i,{type:P.Blame})),la.annotations.toggleAnnotations(e,i.type,void 0!==i.sha?i.sha:e&&e.selection.active.line)}catch(e){return ce.error(e,"ToggleFileBlameCommand"),N.window.showErrorMessage(`Unable to toggle file ${i.type} annotations. See output channel for more details`)}}}class Bo extends Hi{constructor(){super(ei.ToggleFileHeatmap)}async execute(e,t){N.commands.executeCommand(ei.ToggleFileBlame,t,{type:P.Heatmap})}}class Ao extends Hi{constructor(){super(ei.ToggleFileRecentChanges)}async execute(e,t){N.commands.executeCommand(ei.ToggleFileBlame,t,{type:P.RecentChanges})}}class No extends Hi{constructor(){super(ei.ToggleLineBlame)}async execute(e,t){try{return la.lineAnnotations.toggleAnnotations(e)}catch(e){return ce.error(e,"ToggleLineBlameCommand"),N.window.showErrorMessage("Unable to toggle line blame annotations. See output channel for more details")}}}const Uo=/[`\>\#\*\_\-\+\.]/g;class Lo{static applyHeatmap(e,t,i){const s=this.getHeatmapColor(i,t);e.renderOptions.before.borderColor=s}static getHeatmapColor(e,t){const i=h.dateDaysFromNow(t,e);return i<=2?"#ffeca7":i<=7?"#ffdd8c":i<=14?"#ffdd7c":i<=30?"#fba447":i<=60?"#f68736":i<=90?"#f37636":i<=180?"#ca6632":i<=365?"#c0513f":i<=730?"#a2503a":"#793738"}static getHoverCommandBar(e,t,i,s=0){let o=`[\`${K.DoubleArrowLeft}\`](${Qs.getMarkdownCommandArgs(e)} "Open Changes") `;if(void 0!==e.previousSha){i===P.RecentChanges&&(i=P.Blame);const t=je.toRevisionUri(e.previousSha,e.previousUri.fsPath,e.repoPath);o+=`[\`${K.SquareWithTopShadow}\`](${co.getMarkdownCommandArgs(t,i||P.Blame,s)} "Blame Previous Revision") `}return t&&(o+=`[\`${K.ArrowUpRight}\`](${no.getMarkdownCommandArgs(e.sha)} "Open in Remote") `),o+`[\`${K.MiddleEllipsis}\`](${So.getMarkdownCommandArgs(e.sha)} "Show More Actions")`}static getHoverMessage(e,t,i,s,o=0){null===t&&(t="MMMM Do, YYYY h:mma");let a="",r="",n="";if(e.isUncommitted)n=`\`${e.shortSha||"00000000"}\``;else{r=`\n\n${this.getHoverCommandBar(e,0!==i.length,s,o)}`,n=`[\`${e.shortSha}\`](${xo.getMarkdownCommandArgs(e.sha)} "Show Commit Details")`,a=e.message;for(const e of i)if(void 0!==e.provider){a=e.provider.enrichMessage(a);break}a.replace(Uo,"\\$&").replace(/^===/gm,`${K.ZeroWidthSpace}===`).replace(/\n/g,"  \n"),a=`\n\n> ${a}`}const h=new N.MarkdownString(`${n} &nbsp; ![](${e.getGravatarUri(la.config.defaultGravatarsStyle).toString()}) &nbsp;__${e.author}__, ${e.fromNow()} &nbsp; _(${e.formatDate(t)})_ ${a}${r}`);return h.isTrusted=!0,h}static getHoverDiffMessage(e,t,i){if(void 0===i||void 0===e.previousSha)return;const s=this.getCodeDiff(i);let o;o=e.isUncommitted?void 0!==t.sha&&ii.isStagedUncommitted(t.sha)?`[\`Changes\`](${Qs.getMarkdownCommandArgs(e)} "Open Changes") &nbsp; ${K.Dash} &nbsp; [\`${e.previousShortSha}\`](${xo.getMarkdownCommandArgs(e.previousSha)} "Show Commit Details") ${K.ArrowLeftRight} _${t.shortSha}_\n${s}`:`[\`Changes\`](${Qs.getMarkdownCommandArgs(e)} "Open Changes") &nbsp; ${K.Dash} &nbsp; _uncommitted_\n${s}`:`[\`Changes\`](${Qs.getMarkdownCommandArgs(e)} "Open Changes") &nbsp; ${K.Dash} &nbsp; [\`${e.previousShortSha}\`](${xo.getMarkdownCommandArgs(e.previousSha)} "Show Commit Details") ${K.ArrowLeftRight} [\`${e.shortSha}\`](${xo.getMarkdownCommandArgs(e.sha)} "Show Commit Details")\n${s}`;const a=new N.MarkdownString(o);return a.isTrusted=!0,a}static getCodeDiff(e){const t=void 0===e.previous?void 0:e.previous[0];return`\`\`\`\n-  ${void 0===t||void 0===t.line?"":t.line.trim()}\n+  ${void 0===e.line?"":e.line.trim()}\n\`\`\``}static async changesHover(e,t,i){const s=!e.isUncommitted||void 0!==i.sha&&ii.isStagedUncommitted(i.sha)?e.previousSha:void 0,o=await la.git.getDiffForLine(i,t,s);return{hoverMessage:this.getHoverDiffMessage(e,i,o)}}static gutter(e,t,i,s){const o={renderOptions:{before:Object.assign({},s)}};e.isUncommitted&&(o.renderOptions.before.color=s.uncommittedColor);const a=Gt.fromTemplate(t,e,i);return o.renderOptions.before.contentText=w.pad(a.replace(/ /g,K.Space),1,1),o}static gutterRenderOptions(e,t,i,o){let a=0;for(const e of s.values(o.tokenOptions))if(void 0!==e){if(null==e.truncateTo){a=-1;break}a+=e.truncateTo}a>=0&&(a+=w.width(w.interpolate(i,void 0)))>0&&(a+=3);let r=void 0,n=void 0;return t.enabled&&(r="solid",n="left"===t.location?"0 0 0 2px":"0 2px 0 0"),{backgroundColor:new N.ThemeColor("gitlens.gutterBackgroundColor"),borderStyle:r,borderWidth:n,color:new N.ThemeColor("gitlens.gutterForegroundColor"),fontWeight:"normal",fontStyle:"normal",height:"100%",margin:"0 26px -1px 0",textDecoration:e?"overline solid rgba(0, 0, 0, .2)":"none",width:a>=0?`${a}ch`:void 0,uncommittedColor:new N.ThemeColor("gitlens.gutterUncommittedForegroundColor")}}static heatmap(e,t,i){const s={renderOptions:{before:Object.assign({},i)}};return Lo.applyHeatmap(s,e.date,t),s}static heatmapRenderOptions(){return{borderStyle:"solid",borderWidth:"0 0 0 2px",contentText:K.ZeroWidthSpace,height:"100%",margin:"0 26px -1px 0"}}static trailing(e,t,i){const s=Gt.fromTemplate(t,e,{truncateMessageAtNewLine:!0,dateFormat:i});return{renderOptions:{after:{backgroundColor:new N.ThemeColor("gitlens.trailingLineBackgroundColor"),color:new N.ThemeColor("gitlens.trailingLineForegroundColor"),contentText:w.pad(s.replace(/ /g,K.Space),1,1),fontWeight:"normal",fontStyle:"normal"}}}}}class Oo extends ne{constructor(e,t,i,s){super(e,t,i,s),this._uri=t.uri,this._blame=e.document.isDirty?la.git.getBlameForFileContents(this._uri,e.document.getText()):la.git.getBlameForFile(this._uri),e.document.isDirty&&t.setForceDirtyStateChangeOnNextDocumentChange()}async clear(){this._hoverProviderDisposable&&this._hoverProviderDisposable.dispose(),super.clear()}async onReset(e){void 0!==this.editor&&(this._blame=this.editor.document.isDirty?la.git.getBlameForFileContents(this._uri,this.editor.document.getText()):la.git.getBlameForFile(this._uri)),super.onReset(e)}async selection(e,t){if(!this.highlightDecoration)return;if(!(void 0!==t||(t=await this._blame)&&t.lines.length))return;let i=void 0;if("string"==typeof e)i=e;else if("number"==typeof e){if(e>=0){const s=t.lines[e];i=s&&s.sha}}else i=u.first(t.commits.values()).sha;if(!i)return void this.editor.setDecorations(this.highlightDecoration,[]);const s=o.filterMap(t.lines,e=>e.sha===i?this.editor.document.validateRange(new N.Range(e.line,0,e.line,M)):void 0);this.editor.setDecorations(this.highlightDecoration,s)}async validate(){const e=await this._blame;return void 0!==e&&0!==e.lines.length}async getBlame(){const e=await this._blame;if(void 0!==e&&0!==e.lines.length)return e}registerHoverProviders(e){if(!la.config.hovers.enabled||!la.config.hovers.annotations.enabled||!e.details&&!e.changes)return;const t=[];e.changes&&t.push(N.languages.registerHoverProvider({pattern:this.document.uri.fsPath},{provideHover:this.provideChangesHover.bind(this)})),e.details&&t.push(N.languages.registerHoverProvider({pattern:this.document.uri.fsPath},{provideHover:this.provideDetailsHover.bind(this)})),this._hoverProviderDisposable=N.Disposable.from(...t)}async provideDetailsHover(e,t,i){const s=await this.getCommitForHover(t);if(void 0===s)return;let o=void 0;s.isUncommitted||void 0!==(o=await la.git.getLogCommitForFile(s.repoPath,s.uri.fsPath,{ref:s.sha}))&&(o.previousFileName=s.previousFileName,o.previousSha=s.previousSha);const a=Lo.getHoverMessage(o||s,la.config.defaultDateFormat,await la.git.getRemotes(s.repoPath),this.annotationType,this.editor.selection.active.line);return new N.Hover(a,e.validateRange(new N.Range(t.line,0,t.line,M)))}async provideChangesHover(e,t,i){const s=await this.getCommitForHover(t);if(void 0===s)return;const o=await Lo.changesHover(s,t.line,await je.fromUri(e.uri));return new N.Hover(o.hoverMessage,e.validateRange(new N.Range(t.line,0,t.line,M)))}async getCommitForHover(e){if("line"!==la.config.hovers.annotations.over&&0!==e.character)return;const t=await this.getBlame();if(void 0===t)return;const i=t.lines[e.line];return t.commits.get(i.sha)}}class Io extends Oo{async onProvideAnnotation(e,t){this.annotationType=P.Blame;const i=await this.getBlame();if(void 0===i)return!1;const o=process.hrtime(),a=la.config.blame,r=w.getTokensFromTemplate(a.format).reduce((e,t)=>(e[t.key]=t.options,e),{}),n={dateFormat:null===a.dateFormat?la.config.defaultDateFormat:a.dateFormat,tokenOptions:r},h=Date.now(),c=a.avatars,l=la.config.defaultGravatarsStyle,d=a.separateLines,m=Lo.gutterRenderOptions(d,a.heatmap,a.format,n);this.decorations=[];const u=Object.create(null),g=c?Object.create(null):void 0;let p,f,v,C=!1;for(const e of i.lines){const t=e.line;v!==e.sha?(C=!1,v=e.sha,void 0!==(p=i.commits.get(e.sha))&&(void 0===(f=u[e.sha])?(f=Lo.gutter(p,a.format,n,m),a.heatmap.enabled&&Lo.applyHeatmap(f,p.date,h),f.range=new N.Range(t,0,t,0),this.decorations.push(f),c&&void 0!==p.email&&this.addOrUpdateGravatarDecoration(p,f.range,l,g),u[e.sha]=f):(f=Object.assign({},f,{range:new N.Range(t,0,t,0)}),this.decorations.push(f),c&&void 0!==p.email&&this.addOrUpdateGravatarDecoration(p,f.range,l,g)))):(f=Object.assign({},f),a.compact&&!C&&(f.renderOptions={before:Object.assign({},f.renderOptions.before,{contentText:K.Space.repeat(w.width(f.renderOptions.before.contentText))})},d&&(f.renderOptions.before.textDecoration="none"),C=!0),f.range=new N.Range(t,0,t,0),this.decorations.push(f),c&&!a.compact&&void 0!==p&&void 0!==p.email&&this.addOrUpdateGravatarDecoration(p,f.range,l,g))}if(this.decorations.length&&(this.editor.setDecorations(this.decoration,this.decorations),c)){this.additionalDecorations=[];for(const e of s.values(g))this.additionalDecorations.push(e),this.editor.setDecorations(e.decoration,e.ranges)}const b=process.hrtime(o);return ce.log(`${1e3*b[0]+Math.floor(b[1]/1e6)} ms to compute gutter blame annotations`),this.registerHoverProviders(la.config.hovers.annotations),this.selection(e,i),!0}addOrUpdateGravatarDecoration(e,t,i,s){const o=s[e.email];void 0===o?s[e.email]={decoration:N.window.createTextEditorDecorationType({gutterIconPath:e.getGravatarUri(i),gutterIconSize:"16px 16px"}),ranges:[t]}:o.ranges.push(t)}}class Mo extends Oo{async onProvideAnnotation(e,t){this.annotationType=P.Heatmap;const i=await this.getBlame();if(void 0===i)return!1;const s=process.hrtime(),o=Date.now(),a=Lo.heatmapRenderOptions();this.decorations=[];const r=Object.create(null);let n,h;for(const e of i.lines){const t=e.line;void 0===(h=r[e.sha])?void 0!==(n=i.commits.get(e.sha))&&((h=Lo.heatmap(n,o,a)).range=new N.Range(t,0,t,0),this.decorations.push(h),r[e.sha]=h):(h=Object.assign({},h,{range:new N.Range(t,0,t,0)}),this.decorations.push(h))}this.decorations.length&&this.editor.setDecorations(this.decoration,this.decorations);const c=process.hrtime(s);return ce.log(`${1e3*c[0]+Math.floor(c[1]/1e6)} ms to compute heatmap annotations`),this.registerHoverProviders(la.config.hovers.annotations),this.selection(e,i),!0}}class Wo extends ne{constructor(e,t,i,s){super(e,t,i,s),this._uri=t.uri}async onProvideAnnotation(e){this.annotationType=P.RecentChanges;const t=await la.git.getRecentLogCommitForFile(this._uri.repoPath,this._uri.fsPath);if(void 0===t)return!1;const i=await la.git.getDiffForFile(this._uri,t.previousSha);if(void 0===i)return!1;const s=process.hrtime(),o=la.config,a=o.defaultDateFormat;this.decorations=[];for(const e of i.chunks){let i=e.currentPosition.start-2;for(const s of e.lines){if(void 0===s.line)continue;if(i++,"unchanged"===s.state)continue;const e=this.editor.document.validateRange(new N.Range(new N.Position(i,0),new N.Position(i,M)));let r=void 0;o.hovers.enabled&&o.hovers.annotations.enabled&&(o.hovers.annotations.details&&this.decorations.push({hoverMessage:Lo.getHoverMessage(t,a,await la.git.getRemotes(t.repoPath),this.annotationType,this.editor.selection.active.line),range:e}),o.hovers.annotations.changes&&(r=Lo.getHoverDiffMessage(t,this._uri,s))),this.decorations.push({hoverMessage:r,range:e})}}this.editor.setDecorations(this.decoration,this.decorations);const r=process.hrtime(s);return ce.log(`${1e3*r[0]+Math.floor(r[1]/1e6)} ms to compute recent changes annotations`),!0}async selection(e){}async validate(){return!0}}var Ho,jo;(jo=Ho||(Ho={})).User="User",jo.BlameabilityChanged="BlameabilityChanged",jo.ColumnChanged="ColumnChanged",jo.Disposing="Disposing",jo.DocumentChanged="DocumentChanged",jo.DocumentClosed="DocumentClosed";const Go={blameAnnotation:N.window.createTextEditorDecorationType({rangeBehavior:N.DecorationRangeBehavior.ClosedOpen,textDecoration:"none"}),blameHighlight:void 0,heatmapAnnotation:N.window.createTextEditorDecorationType({}),heatmapHighlight:void 0,recentChangesAnnotation:void 0,recentChangesHighlight:void 0};class Vo extends N.Disposable{constructor(){super(()=>this.dispose()),this._onDidToggleAnnotations=new N.EventEmitter,this._annotationProviders=new Map,this._keyboardScope=void 0,this._annotationType=void 0,this._disposable=N.Disposable.from(ua.onDidChange(this.onConfigurationChanged,this)),this._toggleModes=new Map,this.onConfigurationChanged(ua.initializingChangeEvent)}get onDidToggleAnnotations(){return this._onDidToggleAnnotations.event}dispose(){this.clearAll(),Go.blameAnnotation&&Go.blameAnnotation.dispose(),Go.blameHighlight&&Go.blameHighlight.dispose(),this._annotationsDisposable&&this._annotationsDisposable.dispose(),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=ua.initializing(e),i=la.config;if(t||ua.changed(e,ua.name("blame")("highlight").value)){Go.blameHighlight&&Go.blameHighlight.dispose();const e=i.blame.highlight;e.enabled?Go.blameHighlight=N.window.createTextEditorDecorationType({gutterIconSize:"contain",isWholeLine:!0,overviewRulerLane:N.OverviewRulerLane.Right,backgroundColor:e.locations.includes(T.Line)?new N.ThemeColor("gitlens.lineHighlightBackgroundColor"):void 0,overviewRulerColor:e.locations.includes(T.Overview)?new N.ThemeColor("gitlens.lineHighlightOverviewRulerColor"):void 0,dark:{gutterIconPath:e.locations.includes(T.Gutter)?la.context.asAbsolutePath("images/dark/highlight-gutter.svg"):void 0},light:{gutterIconPath:e.locations.includes(T.Gutter)?la.context.asAbsolutePath("images/light/highlight-gutter.svg"):void 0}}):Go.blameHighlight=void 0}if(t||ua.changed(e,ua.name("recentChanges")("highlight").value)){Go.recentChangesAnnotation&&Go.recentChangesAnnotation.dispose();const e=i.recentChanges.highlight;Go.recentChangesAnnotation=N.window.createTextEditorDecorationType({gutterIconSize:"contain",isWholeLine:!0,overviewRulerLane:N.OverviewRulerLane.Right,backgroundColor:e.locations.includes(T.Line)?new N.ThemeColor("gitlens.lineHighlightBackgroundColor"):void 0,overviewRulerColor:e.locations.includes(T.Overview)?new N.ThemeColor("gitlens.lineHighlightOverviewRulerColor"):void 0,dark:{gutterIconPath:e.locations.includes(T.Gutter)?la.context.asAbsolutePath("images/dark/highlight-gutter.svg"):void 0},light:{gutterIconPath:e.locations.includes(T.Gutter)?la.context.asAbsolutePath("images/light/highlight-gutter.svg"):void 0}})}if((t||ua.changed(e,ua.name("blame")("toggleMode").value))&&(this._toggleModes.set(P.Blame,i.blame.toggleMode),t||i.blame.toggleMode!==y.File||this.clearAll()),(t||ua.changed(e,ua.name("heatmap")("toggleMode").value))&&(this._toggleModes.set(P.Heatmap,i.heatmap.toggleMode),t||i.heatmap.toggleMode!==y.File||this.clearAll()),(t||ua.changed(e,ua.name("recentChanges")("toggleMode").value))&&(this._toggleModes.set(P.RecentChanges,i.recentChanges.toggleMode),t||i.recentChanges.toggleMode!==y.File||this.clearAll()),!t&&(ua.changed(e,ua.name("blame").value)||ua.changed(e,ua.name("recentChanges").value)||ua.changed(e,ua.name("hovers").value)))for(const e of this._annotationProviders.values())void 0!==e&&(e.annotationType===P.RecentChanges?e.reset({decoration:Go.recentChangesAnnotation,highlightDecoration:Go.recentChangesHighlight}):e.annotationType===P.Blame?e.reset({decoration:Go.blameAnnotation,highlightDecoration:Go.blameHighlight}):this.showAnnotations(e.editor,P.Heatmap))}async onActiveTextEditorChanged(e){if(void 0!==e&&!ee(e))return;if(this._editor=e,this.isInWindowToggle())return void await this.showAnnotations(e,this._annotationType);const t=this.getProvider(e);void 0===t?(J(j.AnnotationStatus,void 0),this.detachKeyboardHook()):(J(j.AnnotationStatus,t.status),this.attachKeyboardHook())}onBlameStateChanged(e){if(e.blameable)return;const t=N.window.activeTextEditor;void 0!==t&&this.clear(t,Ho.BlameabilityChanged)}onDirtyStateChanged(e){for(const[t,i]of this._annotationProviders)e.document.is(i.document)&&this.clearCore(t,Ho.DocumentChanged)}onTextDocumentClosed(e){if(la.git.isTrackable(e.uri))for(const[t,i]of this._annotationProviders)i.document===e&&this.clearCore(t,Ho.DocumentClosed)}onTextEditorViewColumnChanged(e){const t=this.getProvider(e.textEditor);if(void 0!==t)t.restore(e.textEditor);else{const t=u.find(this._annotationProviders.values(),t=>t.editor.document===e.textEditor.document);if(null==t)return;this.clearCore(t.correlationKey,Ho.ColumnChanged)}}onVisibleTextEditorsChanged(e){let t;for(const i of e)void 0!==(t=this.getProvider(i))&&t.restore(i)}isInWindowToggle(){return this.getToggleMode(this._annotationType)===y.Window}getToggleMode(e){return void 0===e?y.File:this._toggleModes.get(e)||y.File}clear(e,t=Ho.User){return this.isInWindowToggle()?this.clearAll():this.clearCore(ne.getCorrelationKey(e),t)}async clearAll(){this._annotationType=void 0;for(const[e]of this._annotationProviders)await this.clearCore(e,Ho.Disposing)}async getAnnotationType(e){const t=this.getProvider(e);if(void 0===t)return;const i=await la.tracker.get(e.document);return void 0!==i&&i.isBlameable?t.annotationType:void 0}getProvider(e){if(void 0!==e&&void 0!==e.document)return this._annotationProviders.get(ne.getCorrelationKey(e))}async showAnnotations(e,t,i){if(this.getToggleMode(t)===y.Window){let i=void 0===this._annotationType;const s=!i&&this._annotationType!==t;if(this._annotationType=t,s&&(await this.clearAll(),i=!0),i)for(const i of N.window.visibleTextEditors)i!==e&&this.showAnnotations(i,t)}if(void 0===e)return!1;if(this._editor=e,!(await la.tracker.getOrAdd(e.document)).isBlameable)return!1;const s=this.getProvider(e);return void 0!==s&&s.annotationType===t?(await s.selection(i),!0):void 0!==await N.window.withProgress({location:N.ProgressLocation.Window},async o=>{await J(j.AnnotationStatus,ae.Computing);const a=this.showAnnotationsCore(s,e,t,i,o),r=await a;return e===this._editor&&await J(j.AnnotationStatus,r&&r.status),a})}async toggleAnnotations(e,t,i){if(void 0!==e){const i=await la.tracker.getOrAdd(e.document);if(t===P.RecentChanges&&!i.isTracked||!i.isBlameable)return!1}const s=this.getProvider(e);if(void 0===s)return this.showAnnotations(e,t,i);const o=s.annotationType!==t;return this.isInWindowToggle()?await this.clearAll():await this.clearCore(s.correlationKey,Ho.User),!!o&&this.showAnnotations(e,t,i)}async attachKeyboardHook(){void 0===this._keyboardScope&&(this._keyboardScope=await la.keyboard.beginScope({escape:{onDidPressKey:async e=>{const t=this._editor;void 0!==t&&await this.clear(t,Ho.User)}}}))}async clearCore(e,t){const i=this._annotationProviders.get(e);void 0!==i&&(ce.log(`${t}:`,`Clear annotations for ${e}`),this._annotationProviders.delete(e),await i.dispose(),0!==this._annotationProviders.size&&e!==ne.getCorrelationKey(this._editor)||(await J(j.AnnotationStatus,void 0),await this.detachKeyboardHook()),0===this._annotationProviders.size&&(ce.log("Remove all listener registrations for annotations"),this._annotationsDisposable&&this._annotationsDisposable.dispose(),this._annotationsDisposable=void 0),this._onDidToggleAnnotations.fire())}async detachKeyboardHook(){void 0!==this._keyboardScope&&(await this._keyboardScope.dispose(),this._keyboardScope=void 0)}async showAnnotationsCore(e,t,i,s,o){if(void 0!==o){let e="annotations";switch(i){case P.Blame:e="blame annotations";break;case P.Heatmap:e="heatmap annotations";break;case P.RecentChanges:e="recent changes annotations"}o.report({message:`Computing ${e} for ${Ue.basename(t.document.fileName)}`})}this.attachKeyboardHook();const a=await la.tracker.getOrAdd(t.document);let r=void 0;switch(i){case P.Blame:r=new Io(t,a,Go.blameAnnotation,Go.blameHighlight);break;case P.Heatmap:r=new Mo(t,a,Go.heatmapAnnotation,Go.heatmapHighlight);break;case P.RecentChanges:r=new Wo(t,a,Go.recentChangesAnnotation,Go.recentChangesHighlight)}if(void 0!==r&&await r.validate())return void 0!==e&&await this.clearCore(e.correlationKey,Ho.User),this._annotationsDisposable||0!==this._annotationProviders.size||(ce.log("Add listener registrations for annotations"),this._annotationsDisposable=N.Disposable.from(N.window.onDidChangeActiveTextEditor(m.debounce(this.onActiveTextEditorChanged,50),this),N.window.onDidChangeTextEditorViewColumn(this.onTextEditorViewColumnChanged,this),N.window.onDidChangeVisibleTextEditors(m.debounce(this.onVisibleTextEditorsChanged,50),this),N.workspace.onDidCloseTextDocument(this.onTextDocumentClosed,this),la.tracker.onDidChangeBlameState(this.onBlameStateChanged,this),la.tracker.onDidChangeDirtyState(this.onDirtyStateChanged,this))),this._annotationProviders.set(r.correlationKey,r),await r.provideAnnotation(s)?(this._onDidToggleAnnotations.fire(),r):void 0}}class Qo extends N.CodeLens{constructor(e,t,i,s,o,a,r,n){super(a,n),this.symbolKind=e,this.uri=t,this.blame=i,this.blameRange=s,this.isFullRange=o,this.desiredCommand=r}getBlame(){return this.blame&&this.blame()}}class Ko extends N.CodeLens{constructor(e,t,i,s,o,a,r){super(a),this.symbolKind=e,this.uri=t,this.blame=i,this.blameRange=s,this.isFullRange=o,this.desiredCommand=r}getBlame(){return this.blame()}}class qo{constructor(e,t,i){this._git=t,this._tracker=i,this._onDidChangeCodeLenses=new N.EventEmitter}get onDidChangeCodeLenses(){return this._onDidChangeCodeLenses.event}reset(e){this._onDidChangeCodeLenses.fire()}async provideCodeLenses(e,t){const i=await this._tracker.getOrAdd(e);if(!i.isBlameable)return[];let s=!1;if(e.isDirty)if(i.isDirtyIdle){const t=ua.get(ua.name("advanced")("blame")("sizeThresholdAfterEdit").value);t>0&&e.lineCount>t&&(s=!0)}else s=!0;const o=ua.get(ua.name("codeLens").value,e.uri);let a=o.scopesByLanguage&&o.scopesByLanguage.find(t=>void 0!==t.language&&t.language.toLowerCase()===e.languageId);null==a&&(a={language:void 0,scopes:o.scopes,symbolScopes:o.symbolScopes}),a.symbolScopes=null!=a.symbolScopes?a.symbolScopes=a.symbolScopes.map(e=>e.toLowerCase()):[];const r=[],n=i.uri;let h,c;if(s)1===a.scopes.length&&a.scopes.includes(S.Document)||(c=await N.commands.executeCommand(W.ExecuteDocumentSymbolProvider,e.uri));else{if(t.isCancellationRequested)return r;if(1===a.scopes.length&&a.scopes.includes(S.Document)?h=e.isDirty?await this._git.getBlameForFileContents(n,e.getText()):await this._git.getBlameForFile(n):[h,c]=await Promise.all([e.isDirty?this._git.getBlameForFileContents(n,e.getText()):this._git.getBlameForFile(n),N.commands.executeCommand(W.ExecuteDocumentSymbolProvider,e.uri)]),void 0===h||0===h.lines.length)return r}if(t.isCancellationRequested)return r;const l=m.once(()=>e.validateRange(new N.Range(0,1e6,1e6,1e6))),d=s?{title:this.getDirtyTitle(o)}:void 0;if(void 0!==c&&(ce.log("GitCodeLensProvider.provideCodeLenses:",`${c.length} symbol(s) found`),c.forEach(t=>this.provideCodeLens(r,e,t,a,l,h,n,o,s,d))),(a.scopes.includes(S.Document)||a.symbolScopes.includes("file"))&&!a.symbolScopes.includes("!file")&&!r.find(e=>0===e.range.start.line&&0===e.range.end.line)){const e=l();let t=void 0;(s||o.recentChange.enabled)&&(s||(t=m.once(()=>this._git.getBlameForRangeSync(h,n,e))),r.push(new Qo(N.SymbolKind.File,n,t,e,!0,new N.Range(0,0,0,e.start.character),o.recentChange.command,d))),!s&&o.authors.enabled&&(void 0===t&&(t=m.once(()=>this._git.getBlameForRangeSync(h,n,e))),r.push(new Ko(N.SymbolKind.File,n,t,e,!0,new N.Range(0,1,0,e.start.character),o.authors.command)))}return r}validateSymbolAndGetBlameRange(e,t,i){let s,o=!1;const a=N.SymbolKind[e.kind].toLowerCase();switch(e.kind){case N.SymbolKind.File:(t.scopes.includes(S.Containers)||t.symbolScopes.includes(a))&&(o=!t.symbolScopes.includes(`!${a}`)),o&&(s=i());break;case N.SymbolKind.Package:(t.scopes.includes(S.Containers)||t.symbolScopes.includes(a))&&(o=!t.symbolScopes.includes(`!${a}`)),o&&0===e.location.range.start.line&&0===e.location.range.end.line&&(s=i());break;case N.SymbolKind.Class:case N.SymbolKind.Interface:case N.SymbolKind.Module:case N.SymbolKind.Namespace:case N.SymbolKind.Struct:(t.scopes.includes(S.Containers)||t.symbolScopes.includes(a))&&(o=!t.symbolScopes.includes(`!${a}`));break;case N.SymbolKind.Constructor:case N.SymbolKind.Enum:case N.SymbolKind.Function:case N.SymbolKind.Method:(t.scopes.includes(S.Blocks)||t.symbolScopes.includes(a))&&(o=!t.symbolScopes.includes(`!${a}`));break;default:t.symbolScopes.includes(a)&&(o=!t.symbolScopes.includes(`!${a}`))}return o?s||e.location.range:void 0}provideCodeLens(e,t,i,s,o,a,r,n,h,c){const l=this.validateSymbolAndGetBlameRange(i,s,o);if(void 0===l)return;const d=t.lineAt(i.location.range.start);if(e.length&&e[e.length-1].range.start.line===d.lineNumber)return;let u,g=0;if((h||n.recentChange.enabled)&&(h||(u=m.once(()=>this._git.getBlameForRangeSync(a,r,l))),e.push(new Qo(i.kind,r,u,l,!1,d.range.with(new N.Position(d.range.start.line,g)),n.recentChange.command,c)),g++),n.authors.enabled){let s=!l.isSingleLine;if(!s&&"csharp"===t.languageId)switch(i.kind){case N.SymbolKind.File:break;case N.SymbolKind.Package:case N.SymbolKind.Module:case N.SymbolKind.Namespace:case N.SymbolKind.Class:case N.SymbolKind.Interface:case N.SymbolKind.Constructor:case N.SymbolKind.Method:case N.SymbolKind.Function:case N.SymbolKind.Enum:s=!0}s&&!h&&(void 0===u&&(u=m.once(()=>this._git.getBlameForRangeSync(a,r,l))),e.push(new Ko(i.kind,r,u,l,!1,d.range.with(new N.Position(d.range.start.line,g)),n.authors.command)))}}resolveCodeLens(e,t){return e instanceof Qo?this.resolveGitRecentChangeCodeLens(e,t):e instanceof Ko?this.resolveGitAuthorsCodeLens(e,t):Promise.reject(void 0)}resolveGitRecentChangeCodeLens(e,t){const i=e.getBlame();if(void 0===i)return e;const s=u.first(i.commits.values());let o=`${s.author}, ${s.formattedDate}`;switch(la.config.debug&&(o+=` [${N.SymbolKind[e.symbolKind]}(${e.range.start.character}-${e.range.end.character}), Lines (${e.blameRange.start.line+1}-${e.blameRange.end.line+1}), Commit (${s.shortSha})]`),e.desiredCommand){case x.DiffWithPrevious:return this.applyDiffWithPreviousCommand(o,e,i,s);case x.ShowQuickCommitDetails:return this.applyShowQuickCommitDetailsCommand(o,e,i,s);case x.ShowQuickCommitFileDetails:return this.applyShowQuickCommitFileDetailsCommand(o,e,i,s);case x.ShowQuickCurrentBranchHistory:return this.applyShowQuickCurrentBranchHistoryCommand(o,e,i,s);case x.ShowQuickFileHistory:return this.applyShowQuickFileHistoryCommand(o,e,i,s);case x.ToggleFileBlame:return this.applyToggleFileBlameCommand(o,e,i);default:return e}}resolveGitAuthorsCodeLens(e,t){const i=e.getBlame();if(void 0===i)return e;const s=i.authors.size;let o=`${s} ${s>1?"authors":"author"} (${u.first(i.authors.values()).name}${s>1?" and others":""})`;switch(la.config.debug&&(o+=` [${N.SymbolKind[e.symbolKind]}(${e.range.start.character}-${e.range.end.character}), Lines (${e.blameRange.start.line+1}-${e.blameRange.end.line+1}), Authors (${u.join(u.map(i.authors.values(),e=>e.name),", ")})]`),e.desiredCommand){case x.DiffWithPrevious:return this.applyDiffWithPreviousCommand(o,e,i);case x.ShowQuickCommitDetails:return this.applyShowQuickCommitDetailsCommand(o,e,i);case x.ShowQuickCommitFileDetails:return this.applyShowQuickCommitFileDetailsCommand(o,e,i);case x.ShowQuickCurrentBranchHistory:return this.applyShowQuickCurrentBranchHistoryCommand(o,e,i);case x.ShowQuickFileHistory:return this.applyShowQuickFileHistoryCommand(o,e,i);case x.ToggleFileBlame:return this.applyToggleFileBlameCommand(o,e,i);default:return e}}applyDiffWithPreviousCommand(e,t,i,s){if(void 0===s){const e=i.allLines[t.range.start.line];s=i.commits.get(e.sha)}return t.command={title:e,command:ei.DiffWithPrevious,arguments:[N.Uri.file(t.uri.fsPath),{commit:s}]},t}applyShowQuickCommitDetailsCommand(e,t,i,s){return t.command={title:e,command:void 0!==s&&s.isUncommitted?"":x.ShowQuickCommitDetails,arguments:[N.Uri.file(t.uri.fsPath),{commit:s,sha:void 0===s?void 0:s.sha}]},t}applyShowQuickCommitFileDetailsCommand(e,t,i,s){return t.command={title:e,command:void 0!==s&&s.isUncommitted?"":x.ShowQuickCommitFileDetails,arguments:[N.Uri.file(t.uri.fsPath),{commit:s,sha:void 0===s?void 0:s.sha}]},t}applyShowQuickCurrentBranchHistoryCommand(e,t,i,s){return t.command={title:e,command:x.ShowQuickCurrentBranchHistory,arguments:[N.Uri.file(t.uri.fsPath)]},t}applyShowQuickFileHistoryCommand(e,t,i,s){return t.command={title:e,command:x.ShowQuickFileHistory,arguments:[N.Uri.file(t.uri.fsPath),{range:t.isFullRange?void 0:t.blameRange}]},t}applyToggleFileBlameCommand(e,t,i){return t.command={title:e,command:ei.ToggleFileBlame,arguments:[N.Uri.file(t.uri.fsPath)]},t}getDirtyTitle(e){return e.recentChange.enabled&&e.authors.enabled?ua.get(ua.name("strings")("codeLens")("unsavedChanges")("recentChangeAndAuthors").value):e.recentChange.enabled?ua.get(ua.name("strings")("codeLens")("unsavedChanges")("recentChangeOnly").value):ua.get(ua.name("strings")("codeLens")("unsavedChanges")("authorsOnly").value)}}qo.selector=[{scheme:V.File},{scheme:V.Git},{scheme:V.GitLensGit}];class zo extends N.Disposable{constructor(){super(()=>this.dispose()),this._canToggle=!1,this._disposable=N.Disposable.from(ua.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(ua.initializingChangeEvent)}dispose(){this._providerDisposable&&this._providerDisposable.dispose(),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=ua.initializing(e),i=ua.name("codeLens").value;if(t||ua.changed(e,i,null)||ua.changed(e,ua.name("defaultDateStyle").value)||ua.changed(e,ua.name("defaultDateFormat").value)){t||ce.log("CodeLens config changed; resetting CodeLens provider");const e=ua.get(i);e.enabled&&(e.recentChange.enabled||e.authors.enabled)?void 0!==this._provider?this._provider.reset():this.createProvider():(void 0!==this._providerDisposable&&(this._providerDisposable.dispose(),this._providerDisposable=void 0),this._provider=void 0),this._canToggle=e.recentChange.enabled||e.authors.enabled,J(j.CanToggleCodeLens,this._canToggle)}}onBlameStateChanged(e){void 0!==this._provider&&e.blameable&&(ce.log("Blame state changed; resetting CodeLens provider"),this._provider.reset("saved"))}onDirtyIdleTriggered(e){if(void 0===this._provider||!e.document.isBlameable)return;const t=ua.get(ua.name("advanced")("blame")("sizeThresholdAfterEdit").value);t>0&&e.document.lineCount>t||(ce.log("Dirty idle triggered; resetting CodeLens provider"),this._provider.reset("idle"))}toggleCodeLens(){if(this._canToggle){if(ce.log("toggleCodeLens()"),void 0!==this._provider)return void 0!==this._providerDisposable&&(this._providerDisposable.dispose(),this._providerDisposable=void 0),void(this._provider=void 0);this.createProvider()}}createProvider(){this._provider=new qo(la.context,la.git,la.tracker),this._providerDisposable=N.Disposable.from(N.languages.registerCodeLensProvider(qo.selector,this._provider),la.tracker.onDidChangeBlameState(this.onBlameStateChanged,this),la.tracker.onDidTriggerDirtyIdle(this.onDirtyIdleTriggered,this))}}class Yo extends N.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeActiveLines=new N.EventEmitter,this._state=new Map}get onDidChangeActiveLines(){return this._onDidChangeActiveLines.event}dispose(){this.stop()}onActiveTextEditorChanged(e){this._editor!==e&&(void 0===e||ee(e))&&(this.reset(),this._editor=e,this._lines=void 0!==e?e.selections.map(e=>e.active.line):void 0,this.fireLinesChanged({editor:e,lines:this._lines,reason:"editor"}))}onTextEditorSelectionChanged(e){if(this._editor!==e.textEditor&&!ee(e.textEditor))return;const t=this._editor===e.textEditor?"lines":"editor",i=e.selections.map(e=>e.active.line);this._editor===e.textEditor&&this.includesAll(i)||(this.reset(),this._editor=e.textEditor,this._lines=i,this.fireLinesChanged({editor:this._editor,lines:this._lines,reason:t}))}getState(e){return this._state.get(e)}setState(e,t){this._state.set(e,t)}get lines(){return this._lines}includes(e){return void 0!==this._lines&&this._lines.includes(e)}includesAll(e){return Yo.includesAll(e,this._lines)}reset(){this._state.clear()}start(){void 0===this._disposable&&(this._disposable=N.Disposable.from(N.window.onDidChangeActiveTextEditor(m.debounce(this.onActiveTextEditorChanged,0),this),N.window.onDidChangeTextEditorSelection(this.onTextEditorSelectionChanged,this)),setImmediate(()=>this.onActiveTextEditorChanged(N.window.activeTextEditor)))}stop(){void 0!==this._disposable&&(void 0!==this._linesChangedDebounced&&this._linesChangedDebounced.cancel(),this._disposable.dispose(),this._disposable=void 0)}fireLinesChanged(e){void 0!==e.lines?(void 0===this._linesChangedDebounced&&(this._linesChangedDebounced=m.debounce(e=>{N.window.activeTextEditor===e.editor&&Yo.includesAll(e.lines,e.editor&&e.editor.selections.map(e=>e.active.line))&&this._onDidChangeActiveLines.fire(e)},250,{track:!0})),this._linesChangedDebounced.pending()||this._onDidChangeActiveLines.fire(Object.assign({},e,{pending:!0})),this._linesChangedDebounced(e)):setImmediate(()=>{N.window.activeTextEditor===e.editor&&(void 0!==this._linesChangedDebounced&&this._linesChangedDebounced.cancel(),this._onDidChangeActiveLines.fire(e))})}static includesAll(e,t){return void 0===e&&void 0===t||void 0!==e&&void 0!==t&&t.length===e.length&&t.every((t,i)=>t===e[i])}}const Xo=N.window.createTextEditorDecorationType({after:{margin:"0 0 0 3em",textDecoration:"none"},rangeBehavior:N.DecorationRangeBehavior.ClosedOpen});class Jo{constructor(e){this._enabled=e}get enabled(){return!this.suspended&&this._enabled}get suspended(){return void 0!==this._suspendReason}reset(e){return!(this._enabled===e&&!this.suspended||(this._enabled=e,this._suspendReason=void 0,0))}resume(e){const t=void 0!==this._suspendReason;return this._suspendReason=void 0,t}suspend(e){const t=void 0===this._suspendReason;return this._suspendReason=e,t}}class Zo extends N.Disposable{constructor(){super(()=>this.dispose()),this._lineTracker=new Yo,this._disposable=N.Disposable.from(this._lineTracker,ua.onDidChange(this.onConfigurationChanged,this),la.annotations.onDidToggleAnnotations(this.onFileAnnotationsToggled,this),N.debug.onDidStartDebugSession(this.onDebugSessionStarted,this)),this.onConfigurationChanged(ua.initializingChangeEvent)}dispose(){this.clearAnnotations(this._editor),this.unregisterHoverProviders(),this._debugSessionEndDisposable&&this._debugSessionEndDisposable.dispose(),this._lineTrackingDisposable&&this._lineTrackingDisposable.dispose(),this._statusBarItem&&this._statusBarItem.dispose(),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=ua.initializing(e),i=ua.get();let s=!1;if((t||ua.changed(e,ua.name("currentLine").value))&&(s=!0,this._blameAnnotationState=void 0),(t||ua.changed(e,ua.name("hovers").value))&&(s=!0,this.unregisterHoverProviders()),t||ua.changed(e,ua.name("statusBar").value))if(s=!0,i.statusBar.enabled){const e="left"!==i.statusBar.alignment?N.StatusBarAlignment.Right:N.StatusBarAlignment.Left;void 0!==this._statusBarItem&&this._statusBarItem.alignment!==e&&(this._statusBarItem.dispose(),this._statusBarItem=void 0),this._statusBarItem=this._statusBarItem||N.window.createStatusBarItem(e,e===N.StatusBarAlignment.Right?1e3:0),this._statusBarItem.command=i.statusBar.command}else void 0!==this._statusBarItem&&(this._statusBarItem.dispose(),this._statusBarItem=void 0);s&&(i.currentLine.enabled||i.statusBar.enabled||i.hovers.enabled&&i.hovers.currentLine.enabled||void 0!==this._blameAnnotationState&&this._blameAnnotationState.enabled?(this._lineTracker.start(),this._lineTrackingDisposable=this._lineTrackingDisposable||N.Disposable.from(this._lineTracker.onDidChangeActiveLines(this.onActiveLinesChanged,this),la.tracker.onDidChangeBlameState(this.onBlameStateChanged,this),la.tracker.onDidChangeDirtyState(this.onDirtyStateChanged,this),la.tracker.onDidTriggerDirtyIdle(this.onDirtyIdleTriggered,this))):(this._lineTracker.stop(),void 0!==this._lineTrackingDisposable&&(this._lineTrackingDisposable.dispose(),this._lineTrackingDisposable=void 0)),this.refresh(N.window.activeTextEditor,{full:!0}))}onActiveLinesChanged(e){e.pending||void 0===e.lines?this.clear(e.editor,la.config.statusBar.reduceFlicker&&"lines"===e.reason&&void 0!==e.lines?"lines":void 0):this.refresh(e.editor)}onBlameStateChanged(e){e.blameable?this.refresh(e.editor):this.clear(e.editor)}onDebugSessionStarted(){this.suspendBlameAnnotations("debugging",N.window.activeTextEditor)&&(this._debugSessionEndDisposable=N.debug.onDidTerminateDebugSession(this.onDebugSessionEnded,this))}onDebugSessionEnded(){void 0!==this._debugSessionEndDisposable&&(this._debugSessionEndDisposable.dispose(),this._debugSessionEndDisposable=void 0),this.resumeBlameAnnotations("debugging",N.window.activeTextEditor)}onDirtyIdleTriggered(e){const t=ua.get(ua.name("advanced")("blame")("sizeThresholdAfterEdit").value);t>0&&e.document.lineCount>t||this.resumeBlameAnnotations("dirty",N.window.activeTextEditor)}async onDirtyStateChanged(e){e.dirty?this.suspendBlameAnnotations("dirty",N.window.activeTextEditor):this.resumeBlameAnnotations("dirty",N.window.activeTextEditor,{force:!0})}onFileAnnotationsToggled(){this.refresh(N.window.activeTextEditor)}async clear(e,t){this._editor!==e&&void 0!==this._editor&&this.clearAnnotations(this._editor),this.clearAnnotations(e),this._lineTracker.reset(),this.unregisterHoverProviders(),void 0!==this._statusBarItem&&"lines"!==t&&this._statusBarItem.hide()}async provideDetailsHover(e,t,i){if(void 0===this._editor||this._editor.document!==e||!this._lineTracker.includes(t.line))return;const s=this._lineTracker.getState(t.line),o=void 0!==s?s.commit:void 0;if(void 0===o)return;const a=await la.annotations.getAnnotationType(this._editor);if(void 0!==a&&la.config.hovers.annotations.details)return;const r="line"===la.config.hovers.currentLine.over,n=e.validateRange(new N.Range(t.line,r?0:M,t.line,M));if(!r&&n.start.character!==t.character)return;let h=void 0!==s?s.logCommit:void 0;if(void 0!==h||o.isUncommitted||void 0!==(h=await la.git.getLogCommitForFile(o.repoPath,o.uri.fsPath,{ref:o.sha}))&&(h.previousSha=o.previousSha,h.previousFileName=o.previousFileName,void 0!==s&&(s.logCommit=h)),void 0===await la.tracker.get(e))return;const c=Lo.getHoverMessage(h||o,la.config.defaultDateFormat,await la.git.getRemotes(o.repoPath),a,t.line);return new N.Hover(c,n)}async provideChangesHover(e,t,i){if(void 0===this._editor||this._editor.document!==e||!this._lineTracker.includes(t.line))return;const s=this._lineTracker.getState(t.line),o=void 0!==s?s.commit:void 0;if(void 0===o)return;if(la.config.hovers.annotations.changes&&void 0!==await la.annotations.getAnnotationType(this._editor))return;const a="line"===la.config.hovers.currentLine.over,r=e.validateRange(new N.Range(t.line,a?0:M,t.line,M));if(!a&&r.start.character!==t.character)return;const n=await la.tracker.get(e);if(void 0===n)return;const h=await Lo.changesHover(o,t.line,n.uri);return void 0!==h.hoverMessage?new N.Hover(h.hoverMessage,r):void 0}async showAnnotations(e){this.setBlameAnnotationState(!0,e)}async toggleAnnotations(e){const t=this.getBlameAnnotationState();this.setBlameAnnotationState(!t.enabled,e)}async resumeBlameAnnotations(e,t,i={}){if(!(i.force||void 0!==this._blameAnnotationState&&this._blameAnnotationState.suspended))return;let s=!1;void 0!==this._blameAnnotationState&&(s=this._blameAnnotationState.resume(e)),void 0!==t&&(i.force||s)&&await this.refresh(t)}async suspendBlameAnnotations(e,t,i={}){const s=this.getBlameAnnotationState();if(void 0===this._blameAnnotationState&&!s.enabled)return!1;void 0===this._blameAnnotationState&&(this._blameAnnotationState=new Jo(s.enabled));const o=this._blameAnnotationState.suspend(e);return void 0!==t&&(i.force||o)?(await this.refresh(t),!0):void 0}async setBlameAnnotationState(e,t){let i=!0;void 0===this._blameAnnotationState?this._blameAnnotationState=new Jo(e):i=this._blameAnnotationState.reset(e),void 0!==t&&i&&await this.refresh(t)}clearAnnotations(e){void 0!==e&&!0!==e._disposed&&e.setDecorations(Xo,[])}getBlameAnnotationState(){if(void 0!==this._blameAnnotationState)return this._blameAnnotationState;const e=la.config;return{enabled:e.currentLine.enabled||e.statusBar.enabled||e.hovers.enabled&&e.hovers.currentLine.enabled}}async refresh(e,t={}){if(void 0===e&&void 0===this._editor)return;if(void 0===e||void 0===this._lineTracker.lines)return this.clear(this._editor);this._editor!==e&&(t.full=!0,this.clearAnnotations(this._editor),this._editor=e);const i=this.getBlameAnnotationState();if(i.enabled&&(void 0===t.trackedDocument&&(t.trackedDocument=await la.tracker.getOrAdd(e.document)),t.trackedDocument.isBlameable))return i.enabled&&la.config.hovers.enabled&&la.config.hovers.currentLine.enabled&&(t.full||void 0===this._hoverProviderDisposable)&&this.registerHoverProviders(e,la.config.hovers.currentLine),void 0===this._updateBlameDebounced&&(this._updateBlameDebounced=m.debounce(this.updateBlame,50,{track:!0})),void this._updateBlameDebounced(this._lineTracker.lines,e,t.trackedDocument);await this.clear(e)}registerHoverProviders(e,t){if(this.unregisterHoverProviders(),void 0===e)return;if(!t.details&&!t.changes)return;const i=[];t.changes&&i.push(N.languages.registerHoverProvider({pattern:e.document.uri.fsPath},{provideHover:this.provideChangesHover.bind(this)})),t.details&&i.push(N.languages.registerHoverProvider({pattern:e.document.uri.fsPath},{provideHover:this.provideDetailsHover.bind(this)})),this._hoverProviderDisposable=N.Disposable.from(...i)}unregisterHoverProviders(){void 0!==this._hoverProviderDisposable&&(this._hoverProviderDisposable.dispose(),this._hoverProviderDisposable=void 0)}async updateBlame(e,t,i){if(this._lineTracker.reset(),!this._lineTracker.includesAll(e)||this._updateBlameDebounced&&this._updateBlameDebounced.pending())return;let s;if(1===e.length){const o=t.document.isDirty?await la.git.getBlameForLineContents(i.uri,e[0],t.document.getText()):await la.git.getBlameForLine(i.uri,e[0]);if(void 0===o)return this.clear(t);s=[o]}else{const o=t.document.isDirty?await la.git.getBlameForFileContents(i.uri,t.document.getText()):await la.git.getBlameForFile(i.uri);if(void 0===o)return this.clear(t);s=e.map(e=>{const t=o.lines[e];return{line:t,commit:o.commits.get(t.sha)}})}if(this._lineTracker.includesAll(e)&&i.isBlameable&&(!this._updateBlameDebounced||!this._updateBlameDebounced.pending())&&!this.getBlameAnnotationState().enabled)return this.clear(t);const o=s[0];if(this._lineTracker.setState(o.line.line,new me(o.commit)),void 0!==t.document){if(t.document.isDirty){const e=await la.tracker.get(t.document);void 0!==e&&e.setForceDirtyStateChangeOnNextDocumentChange()}this.updateStatusBar(o.commit,t),this.updateTrailingAnnotations(s,t)}}updateStatusBar(e,t){const i=la.config.statusBar;if(i.enabled&&void 0!==this._statusBarItem&&ee(t)){switch(this._statusBarItem.text=`$(git-commit) ${Gt.fromTemplate(i.format,e,{truncateMessageAtNewLine:!0,dateFormat:null===i.dateFormat?la.config.defaultDateFormat:i.dateFormat})}`,i.command){case A.ToggleFileBlame:this._statusBarItem.tooltip="Toggle Blame Annotations";break;case A.DiffWithPrevious:this._statusBarItem.command=ei.DiffLineWithPrevious,this._statusBarItem.tooltip="Compare Line Revision with Previous";break;case A.DiffWithWorking:this._statusBarItem.command=ei.DiffLineWithWorking,this._statusBarItem.tooltip="Compare Line Revision with Working";break;case A.ToggleCodeLens:this._statusBarItem.tooltip="Toggle Git CodeLens";break;case A.ShowQuickCommitDetails:this._statusBarItem.tooltip="Show Commit Details";break;case A.ShowQuickCommitFileDetails:this._statusBarItem.tooltip="Show Line Commit Details";break;case A.ShowQuickFileHistory:this._statusBarItem.tooltip="Show File History";break;case A.ShowQuickCurrentBranchHistory:this._statusBarItem.tooltip="Show Branch History"}this._statusBarItem.show()}}async updateTrailingAnnotations(e,t){const i=la.config.currentLine;if(!i.enabled||!ee(t))return;const s=[];for(const o of e){const e=o.line.line,a=Lo.trailing(o.commit,i.format,null===i.dateFormat?la.config.defaultDateFormat:i.dateFormat);a.range=t.document.validateRange(new N.Range(e,M,e,M)),s.push(a)}t.setDecorations(Xo,s)}}class ea extends N.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeAutoRefresh=new N.EventEmitter,this._onDidChangeTreeData=new N.EventEmitter,la.explorerCommands,N.commands.registerCommand("gitlens.gitExplorer.refresh",this.refresh,this),N.commands.registerCommand("gitlens.gitExplorer.refreshNode",this.refreshNode,this),N.commands.registerCommand("gitlens.gitExplorer.setFilesLayoutToAuto",()=>this.setFilesLayout(k.Auto),this),N.commands.registerCommand("gitlens.gitExplorer.setFilesLayoutToList",()=>this.setFilesLayout(k.List),this),N.commands.registerCommand("gitlens.gitExplorer.setFilesLayoutToTree",()=>this.setFilesLayout(k.Tree),this),N.commands.registerCommand("gitlens.gitExplorer.setAutoRefreshToOn",()=>this.setAutoRefresh(la.config.gitExplorer.autoRefresh,!0),this),N.commands.registerCommand("gitlens.gitExplorer.setAutoRefreshToOff",()=>this.setAutoRefresh(la.config.gitExplorer.autoRefresh,!1),this),N.commands.registerCommand("gitlens.gitExplorer.setRenameFollowingOn",()=>this.setRenameFollowing(!0),this),N.commands.registerCommand("gitlens.gitExplorer.setRenameFollowingOff",()=>this.setRenameFollowing(!1),this),N.commands.registerCommand("gitlens.gitExplorer.switchToHistoryView",()=>this.switchTo(_.History),this),N.commands.registerCommand("gitlens.gitExplorer.switchToRepositoryView",()=>this.switchTo(_.Repository),this),la.context.subscriptions.push(N.window.onDidChangeActiveTextEditor(m.debounce(this.onActiveEditorChanged,500),this),N.window.onDidChangeVisibleTextEditors(m.debounce(this.onVisibleEditorsChanged,500),this),ua.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(ua.initializingChangeEvent)}get onDidChangeAutoRefresh(){return this._onDidChangeAutoRefresh.event}get onDidChangeTreeData(){return this._onDidChangeTreeData.event}dispose(){this._disposable&&this._disposable.dispose()}async onActiveEditorChanged(e){if(this._view!==_.History)return;const t=await this.getRootNode(e);this.setRoot(t)&&this.refresh(qt.ActiveEditorChanged,t)}async onConfigurationChanged(e){const t=ua.initializing(e);if(!(t||ua.changed(e,ua.name("gitExplorer").value)||ua.changed(e,ua.name("explorers").value)||ua.changed(e,ua.name("defaultGravatarsStyle").value)||ua.changed(e,ua.name("advanced")("fileHistoryFollowsRenames").value)))return;(t||ua.changed(e,ua.name("gitExplorer")("enabled").value))&&J(j.GitExplorer,this.config.enabled),(t||ua.changed(e,ua.name("gitExplorer")("autoRefresh").value))&&this.setAutoRefresh(la.config.gitExplorer.autoRefresh);let i=this._view;if((t||ua.changed(e,ua.name("gitExplorer")("view").value))&&((i=this.config.view)===_.Auto&&(i=la.context.workspaceState.get(Y.GitExplorerView,_.Repository)),t))return this._view=i,J(j.GitExplorerView,this._view),this.setRoot(await this.getRootNode(N.window.activeTextEditor)),void(this._disposable=N.window.registerTreeDataProvider("gitlens.gitExplorer",this));this.reset(i,ua.changed(e,ua.name("advanced")("fileHistoryFollowsRenames").value))}onRepositoriesChanged(){this._view===_.Repository&&(this.clearRoot(),ce.log(`GitExplorer[view=${this._view}].onRepositoriesChanged`),this.refresh(qt.RepoChanged))}onVisibleEditorsChanged(e){void 0!==this._root&&this._view===_.History&&(0!==e.length&&e.some(e=>e.document&&la.git.isTrackable(e.document.uri))||(this.clearRoot(),this.refresh(qt.VisibleEditorsChanged)))}get autoRefresh(){return this.config.autoRefresh&&la.context.workspaceState.get(Y.GitExplorerAutoRefresh,!0)}get config(){return Object.assign({},la.config.explorers,la.config.gitExplorer)}get folderResourceUri(){if(void 0!==N.workspace.workspaceFolders&&0!==N.workspace.workspaceFolders.length)return N.workspace.workspaceFolders[0].uri}async getChildren(e){return void 0!==this._loading&&(await this._loading,this._loading=void 0),void 0===this._root?this._view===_.History?[new ai(`No active file ${K.Dash} no history to show`)]:[new ai("No repositories found")]:void 0===e?this._root.getChildren():e.getChildren()}async getTreeItem(e){return e.getTreeItem()}async getRootNode(e){switch(this._view){case _.History:{const t=this.getHistoryNode(e||N.window.activeTextEditor);return this._loading=t.then(e=>m.wait(0)),t}default:{const e=la.git.getRepositories();this._loading=e.then(e=>m.wait(0));const t=[...await e];if(0===t.length)return;if(1===t.length){const e=t[0];return new Di(je.fromRepoPath(e.path),e,this,!0)}return new Ai(t,this)}}}async getHistoryNode(e){if(void 0===e||0===N.window.visibleTextEditors.length||!N.window.visibleTextEditors.some(e=>e.document&&la.git.isTrackable(e.document.uri)))return;if(void 0===e.document||!la.git.isTrackable(e.document.uri))return this._root;const t=await je.fromUri(e.document.uri),i=await la.git.getRepository(t);return void 0!==i?oe.equals(t,this._root&&this._root.uri)?this._root:new Bi(t,i,this):void 0}getQualifiedCommand(e){return`gitlens.gitExplorer.${e}`}async refresh(e,t){void 0===e&&(e=qt.Command),ce.log(`GitExplorer[view=${this._view}].refresh`,`reason='${e}'`),(void 0===this._root||void 0===t&&this._view===_.History)&&(this.clearRoot(),this.setRoot(await this.getRootNode(N.window.activeTextEditor))),this._onDidChangeTreeData.fire()}refreshNode(e,t){ce.log(`GitExplorer[view=${this._view}].refreshNode`),void 0!==t&&e.supportsPaging&&(e.maxCount=t.maxCount),this._onDidChangeTreeData.fire(e===this._root?void 0:e)}async reset(e,t=!1){this.setView(e),t&&void 0!==this._root&&this.clearRoot(),(this.setRoot(await this.getRootNode(N.window.activeTextEditor))||t)&&this.refresh(qt.ViewChanged)}clearRoot(){void 0!==this._root&&(this._root.dispose(),this._root=void 0)}async setFilesLayout(e){return ua.update(ua.name("gitExplorer")("files")("layout").value,e,N.ConfigurationTarget.Global)}setRoot(e){return this._root!==e&&(void 0!==this._root&&this._root.dispose(),this._root=e,!0)}setView(e){this._view!==e&&(la.config.gitExplorer.view===_.Auto&&la.context.workspaceState.update(Y.GitExplorerView,e),this._view=e,J(j.GitExplorerView,this._view),e!==_.Repository&&la.git.stopWatchingFileSystem())}async switchTo(e){this._view!==e&&this.reset(e,!0)}async setAutoRefresh(e,t){void 0!==this._autoRefreshDisposable&&(this._autoRefreshDisposable.dispose(),this._autoRefreshDisposable=void 0);let i=!1;e&&(void 0===t?t=la.context.workspaceState.get(Y.GitExplorerAutoRefresh,!0):(i=t,await la.context.workspaceState.update(Y.GitExplorerAutoRefresh,t),this._onDidChangeAutoRefresh.fire()),t&&(this._autoRefreshDisposable=la.git.onDidChangeRepositories(this.onRepositoriesChanged,this),la.context.subscriptions.push(this._autoRefreshDisposable))),J(j.GitExplorerAutoRefresh,e&&t),i&&this.refresh(qt.AutoRefreshChanged)}setRenameFollowing(e){ua.updateEffective(ua.name("advanced")("fileHistoryFollowsRenames").value,e)}}class ta extends N.Disposable{constructor(){super(()=>this.dispose()),N.commands.registerCommand("gitlens.explorers.openChanges",this.openChanges,this),N.commands.registerCommand("gitlens.explorers.openChangesWithWorking",this.openChangesWithWorking,this),N.commands.registerCommand("gitlens.explorers.openFile",this.openFile,this),N.commands.registerCommand("gitlens.explorers.openFileRevision",this.openFileRevision,this),N.commands.registerCommand("gitlens.explorers.openFileRevisionInRemote",this.openFileRevisionInRemote,this),N.commands.registerCommand("gitlens.explorers.openChangedFiles",this.openChangedFiles,this),N.commands.registerCommand("gitlens.explorers.openChangedFileChanges",this.openChangedFileChanges,this),N.commands.registerCommand("gitlens.explorers.openChangedFileChangesWithWorking",this.openChangedFileChangesWithWorking,this),N.commands.registerCommand("gitlens.explorers.openChangedFileRevisions",this.openChangedFileRevisions,this),N.commands.registerCommand("gitlens.explorers.applyChanges",this.applyChanges,this),N.commands.registerCommand("gitlens.explorers.compareAncestryWithWorking",this.compareAncestryWithWorking,this),N.commands.registerCommand("gitlens.explorers.compareWithHead",this.compareWithHead,this),N.commands.registerCommand("gitlens.explorers.compareWithRemote",this.compareWithRemote,this),N.commands.registerCommand("gitlens.explorers.compareWithSelected",this.compareWithSelected,this),N.commands.registerCommand("gitlens.explorers.compareWithWorking",this.compareWithWorking,this),N.commands.registerCommand("gitlens.explorers.selectForCompare",this.selectForCompare,this),N.commands.registerCommand("gitlens.explorers.terminalCheckoutBranch",this.terminalCheckoutBranch,this),N.commands.registerCommand("gitlens.explorers.terminalCreateBranch",this.terminalCreateBranch,this),N.commands.registerCommand("gitlens.explorers.terminalDeleteBranch",this.terminalDeleteBranch,this),N.commands.registerCommand("gitlens.explorers.terminalMergeBranch",this.terminalMergeBranch,this),N.commands.registerCommand("gitlens.explorers.terminalRebaseBranch",this.terminalRebaseBranch,this),N.commands.registerCommand("gitlens.explorers.terminalRebaseBranchToRemote",this.terminalRebaseBranchToRemote,this),N.commands.registerCommand("gitlens.explorers.terminalSquashBranchIntoCommit",this.terminalSquashBranchIntoCommit,this),N.commands.registerCommand("gitlens.explorers.terminalCherryPickCommit",this.terminalCherryPickCommit,this),N.commands.registerCommand("gitlens.explorers.terminalPushCommit",this.terminalPushCommit,this),N.commands.registerCommand("gitlens.explorers.terminalRebaseCommit",this.terminalRebaseCommit,this),N.commands.registerCommand("gitlens.explorers.terminalResetCommit",this.terminalResetCommit,this),N.commands.registerCommand("gitlens.explorers.terminalRevertCommit",this.terminalRevertCommit,this),N.commands.registerCommand("gitlens.explorers.terminalRemoveRemote",this.terminalRemoveRemote,this),N.commands.registerCommand("gitlens.explorers.terminalCreateTag",this.terminalCreateTag,this),N.commands.registerCommand("gitlens.explorers.terminalDeleteTag",this.terminalDeleteTag,this)}dispose(){this._disposable&&this._disposable.dispose()}async applyChanges(e){return await la.git.checkoutFile(e.uri),this.openFile(e)}compareWithHead(e){e instanceof oi&&la.resultsExplorer.showComparisonInResults(e.repoPath,e.ref,"HEAD")}compareWithRemote(e){e.branch.tracking&&la.resultsExplorer.showComparisonInResults(e.repoPath,e.branch.tracking,e.ref)}compareWithWorking(e){e instanceof oi&&la.resultsExplorer.showComparisonInResults(e.repoPath,e.ref,"")}async compareAncestryWithWorking(e){const t=await la.git.getBranch(e.repoPath);if(void 0===t)return;const i=await la.git.getMergeBase(e.repoPath,t.name,e.ref);void 0!==i&&la.resultsExplorer.showComparisonInResults(e.repoPath,{ref:i,label:`ancestry with ${e.ref} (${ii.shortenSha(i)})`},"")}compareWithSelected(e){void 0!==this._selection&&e instanceof oi&&this._selection.repoPath===e.repoPath&&la.resultsExplorer.showComparisonInResults(this._selection.repoPath,this._selection.ref,e.ref)}selectForCompare(e){if(!(e instanceof oi))return;const t=e instanceof mi?"branch":"ref";this._selection={ref:e.ref,repoPath:e.repoPath,type:t},J(j.ExplorersCanCompare,t)}openChanges(e){const t=e.getCommand();if(void 0===t||void 0===t.arguments)return;const[i,s]=t.arguments;return s.showOptions.preview=!1,N.commands.executeCommand(t.command,i,s)}openChangesWithWorking(e){const t={commit:e.commit,showOptions:{preserveFocus:!0,preview:!1}};return N.commands.executeCommand(ei.DiffWithWorking,e.commit.toGitUri(),t)}openFile(e){return Qi(e.uri,{preserveFocus:!0,preview:!1})}openFileRevision(e,t={showOptions:{preserveFocus:!0,preview:!1}}){return Qi(t.uri||("D"===e.commit.status?je.toRevisionUri(e.commit.previousSha,e.commit.previousUri.fsPath,e.commit.repoPath):je.toRevisionUri(e.uri)),t.showOptions||{preserveFocus:!0,preview:!1})}async openChangedFileChanges(e,t={preserveFocus:!1,preview:!1}){const i=e.commit.repoPath,s=e.commit.fileStatuses.map(e=>je.fromFileStatus(e,i));for(const o of s)await this.openDiffWith(i,{uri:o,sha:void 0!==e.commit.previousSha?e.commit.previousSha:ii.deletedSha},{uri:o,sha:e.commit.sha},t)}async openChangedFileChangesWithWorking(e,t={preserveFocus:!1,preview:!1}){const i=e.commit.repoPath,s=o.filterMap(e.commit.fileStatuses,e=>"D"!==e.status?je.fromFileStatus(e,i):void 0);for(const o of s)await this.openDiffWith(i,{uri:o,sha:e.commit.sha},{uri:o,sha:""},t)}async openChangedFiles(e,t={preserveFocus:!1,preview:!1}){const i=e.commit.repoPath,s=o.filterMap(e.commit.fileStatuses,e=>je.fromFileStatus(e,i));for(const e of s)await Qi(e,t)}async openChangedFileRevisions(e,t={preserveFocus:!1,preview:!1}){const i=o.filterMap(e.commit.fileStatuses,t=>je.toRevisionUri("D"===t.status?e.commit.previousFileSha:e.commit.sha,t,e.commit.repoPath));for(const e of i)await Qi(e,t)}async openDiffWith(e,t,i,s={preserveFocus:!1,preview:!1}){const o={repoPath:e,lhs:t,rhs:i,showOptions:s};return N.commands.executeCommand(ei.DiffWith,o)}async openFileRevisionInRemote(e){return N.commands.executeCommand(ei.OpenFileInRemote,e.commit.toGitUri("D"===e.commit.status),{range:!1})}async terminalCheckoutBranch(e){if(!(e instanceof mi))return;const t=`checkout ${e.ref}`;this.sendTerminalCommand(t,e.repoPath)}async terminalCreateBranch(e){if(!(e instanceof oi))return;let t=!1,i=void 0;e instanceof mi&&e.branch.remote&&(t=!0,i=e.branch.getName());const s=await N.window.showInputBox({prompt:"Please provide a branch name (Press 'Enter' to confirm or 'Escape' to cancel)",placeHolder:"Branch name",value:i});if(void 0===s||""===s)return;const o=`branch ${t?"-t ":""}${s} ${e.ref}`;this.sendTerminalCommand(o,e.repoPath)}terminalDeleteBranch(e){if(!(e instanceof mi))return;const t=e.branch.remote?`push ${e.branch.remote} :${e.ref}`:`branch -d ${e.ref}`;this.sendTerminalCommand(t,e.repoPath)}terminalMergeBranch(e){if(!(e instanceof mi))return;const t=`merge ${e.ref}`;this.sendTerminalCommand(t,e.repoPath)}terminalRebaseBranch(e){if(!(e instanceof mi))return;const t=`rebase -i ${e.ref}`;this.sendTerminalCommand(t,e.repoPath)}terminalRebaseBranchToRemote(e){if(e instanceof mi){if(!e.branch.current||!e.branch.tracking)return;const t=`rebase -i ${e.branch.tracking}`;this.sendTerminalCommand(t,e.repoPath)}else if(e instanceof wi){const t=`rebase -i ${e.status.upstream}`;this.sendTerminalCommand(t,e.status.repoPath)}}terminalSquashBranchIntoCommit(e){if(!(e instanceof mi))return;const t=`merge --squash ${e.ref}`;this.sendTerminalCommand(t,e.repoPath)}terminalCherryPickCommit(e){if(!(e instanceof di))return;const t=`cherry-pick -e ${e.ref}`;this.sendTerminalCommand(t,e.repoPath)}async terminalPushCommit(e){if(!(e instanceof di))return;const t=e.branch||await la.git.getBranch(e.repoPath);if(void 0===t)return;const i=`push ${t.getRemote()} ${e.ref}:${t.getName()}`;this.sendTerminalCommand(i,e.repoPath)}terminalRebaseCommit(e){if(!(e instanceof di))return;const t=`rebase -i ${e.ref}^`;this.sendTerminalCommand(t,e.repoPath)}terminalResetCommit(e){if(!(e instanceof di))return;const t=`reset --soft ${e.ref}^`;this.sendTerminalCommand(t,e.repoPath)}terminalRevertCommit(e){if(!(e instanceof di))return;const t=`revert -e ${e.ref}`;this.sendTerminalCommand(t,e.repoPath)}terminalRemoveRemote(e){if(!(e instanceof gi))return;const t=`remote remove ${e.remote.name}`;this.sendTerminalCommand(t,e.remote.repoPath)}async terminalCreateTag(e){if(!(e instanceof oi))return;const t=await N.window.showInputBox({prompt:"Please provide a tag name (Press 'Enter' to confirm or 'Escape' to cancel)",placeHolder:"Tag name"});if(void 0===t||""===t)return;const i=await N.window.showInputBox({prompt:"Please provide an optional message to annotate the tag (Press 'Enter' to confirm or 'Escape' to cancel)",placeHolder:"Tag message"});if(void 0===i)return;const s=`tag ${""!==i?`-a -m "${i}" `:""}${t} ${e.ref}`;this.sendTerminalCommand(s,e.repoPath)}terminalDeleteTag(e){e instanceof Si&&this.sendTerminalCommand(`tag -d ${e.ref}`,e.repoPath)}ensureTerminal(){return void 0===this._terminal&&(this._terminal=N.window.createTerminal(O),this._disposable=N.window.onDidCloseTerminal(e=>{e.name===O&&(this._terminal=void 0,this._disposable.dispose(),this._disposable=void 0)},this),la.context.subscriptions.push(this._disposable)),this._terminal}sendTerminalCommand(e,t){const i=this.ensureTerminal();i.show(!1),i.sendText(`git -C ${t} ${e}`,!1)}}class ia{async provideTextDocumentContent(e,t){const i=je.fromRevisionUri(e);if(!i.repoPath||i.sha===ii.deletedSha)return"";try{return await la.git.getVersionedFileText(i.repoPath,i.fsPath,i.sha||"HEAD")}catch(e){return ce.error(e,"GitContentProvider","getVersionedFileText"),void N.window.showErrorMessage(`Unable to show Git revision ${ii.shortenSha(i.sha)} of '${Ue.relative(i.repoPath,i.fsPath)}'`)}}}ia.scheme=V.GitLensGit;class sa extends N.CodeLens{constructor(e,t,i){super(i),this.fileName=e,this.commit=t}}class oa extends N.CodeLens{constructor(e,t,i){super(i),this.fileName=e,this.commit=t}}class aa{async provideCodeLenses(e,t){const i=je.fromRevisionUri(e.uri),s=[],o=await la.git.getLogCommitForFile(i.repoPath,i.fsPath,{ref:i.sha,firstIfNotFound:!0});return void 0===o?s:(o.previousSha&&s.push(new oa(o.previousUri.fsPath,o,new N.Range(0,0,0,1))),s.push(new sa(o.uri.fsPath,o,new N.Range(0,1,0,2))),s)}resolveCodeLens(e,t){return e instanceof sa?this._resolveDiffWithWorkingTreeCodeLens(e,t):e instanceof oa?this._resolveGitDiffWithPreviousCodeLens(e,t):Promise.reject(void 0)}_resolveDiffWithWorkingTreeCodeLens(e,t){return e.command={title:`Compare Revision (${e.commit.shortSha}) with Working`,command:ei.DiffWithWorking,arguments:[N.Uri.file(e.fileName),{commit:e.commit,line:e.range.start.line}]},Promise.resolve(e)}_resolveGitDiffWithPreviousCodeLens(e,t){return e.command={title:`Compare Revision (${e.commit.shortSha}) with Previous (${e.commit.previousShortSha})`,command:ei.DiffWithPrevious,arguments:[N.Uri.file(e.fileName),{commit:e.commit,line:e.range.start.line}]},Promise.resolve(e)}}aa.selector={scheme:V.GitLensGit};const ra=N.Uri.parse("gitlens://authority/settings"),na=N.Uri.parse("gitlens://authority/welcome");class ha extends N.Disposable{constructor(){super(()=>this.dispose()),this._onDidChange=new N.EventEmitter,this._scope=new Map,this._disposable=N.Disposable.from(N.workspace.onDidCloseTextDocument(this.onTextDocumentClosed,this),N.workspace.registerTextDocumentContentProvider(ra.scheme,this),N.commands.registerCommand("gitlens.showSettingsPage",this.showSettings,this),N.commands.registerCommand("gitlens.showWelcomePage",this.showWelcome,this),N.commands.registerCommand("gitlens.saveSettings",this.save,this))}get onDidChange(){return this._onDidChange.event}dispose(){this._disposable.dispose()}onTextDocumentClosed(e){this._scope.delete(e.uri.toString())}async provideTextDocumentContent(e){let t=(await N.workspace.openTextDocument(N.Uri.file(la.context.asAbsolutePath(`${e.path}.html`)))).getText().replace(/{{root}}/g,N.Uri.file(la.context.asAbsolutePath(".")).toString());return t.includes("'{{data}}'")&&(t=t.replace(/'{{data}}'/g,JSON.stringify({config:la.config,scope:this.getScope(e),scopes:this.getAvailableScopes(),uri:e.toString()}))),t}getAvailableScopes(){const e=[["user","User Settings"]];return void 0!==N.workspace.workspaceFolders&&N.workspace.workspaceFolders.length&&e.push(["workspace","Workspace Settings"]),e}getScope(e){return this._scope.get(e.toString())||"user"}refresh(e){ce.log("PageProvider.refresh"),this._onDidChange.fire(e||ra)}async save(e){ce.log(`PageProvider.save: options=${JSON.stringify(e)}`),this._scope.set(e.uri,e.scope);const t="workspace"===e.scope?N.ConfigurationTarget.Workspace:N.ConfigurationTarget.Global;for(const i in e.changes)(await ua.inspect(i)).defaultValue===e.changes[i]?await ua.update(i,void 0,t):await ua.update(i,e.changes[i],t)}async showSettings(){return await N.commands.executeCommand("vscode.previewHtml",ra,N.ViewColumn.Active,"GitLens Settings")}async showWelcome(){return await N.commands.executeCommand("vscode.previewHtml",na,N.ViewColumn.Active,"Welcome to GitLens")}}class ca extends N.Disposable{constructor(){super(()=>this.dispose()),this._roots=[],this._onDidChangeTreeData=new N.EventEmitter,la.explorerCommands,N.commands.registerCommand("gitlens.resultsExplorer.refresh",this.refreshNodes,this),N.commands.registerCommand("gitlens.resultsExplorer.refreshNode",this.refreshNode,this),N.commands.registerCommand("gitlens.resultsExplorer.setFilesLayoutToAuto",()=>this.setFilesLayout(k.Auto),this),N.commands.registerCommand("gitlens.resultsExplorer.setFilesLayoutToList",()=>this.setFilesLayout(k.List),this),N.commands.registerCommand("gitlens.resultsExplorer.setFilesLayoutToTree",()=>this.setFilesLayout(k.Tree),this),N.commands.registerCommand("gitlens.resultsExplorer.clearResultsNode",this.clearResultsNode,this),N.commands.registerCommand("gitlens.resultsExplorer.close",this.close,this),N.commands.registerCommand("gitlens.resultsExplorer.setKeepResultsToOn",()=>this.setKeepResults(!0),this),N.commands.registerCommand("gitlens.resultsExplorer.setKeepResultsToOff",()=>this.setKeepResults(!1),this),N.commands.registerCommand("gitlens.resultsExplorer.swapComparision",this.swapComparision,this),J(j.ResultsExplorerKeepResults,this.keepResults),la.context.subscriptions.push(ua.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(ua.initializingChangeEvent)}get onDidChangeTreeData(){return this._onDidChangeTreeData.event}dispose(){this._disposable&&this._disposable.dispose()}async onConfigurationChanged(e){const t=ua.initializing(e);(t||ua.changed(e,ua.name("resultsExplorer").value)||ua.changed(e,ua.name("explorers").value)||ua.changed(e,ua.name("defaultGravatarsStyle").value))&&(t||0===this._roots.length||this.refresh(qt.ConfigurationChanged),t&&(this._disposable=N.window.registerTreeDataProvider("gitlens.resultsExplorer",this)))}get config(){return Object.assign({},la.config.explorers,la.config.resultsExplorer)}get folderResourceUri(){if(void 0!==N.workspace.workspaceFolders&&0!==N.workspace.workspaceFolders.length)return N.workspace.workspaceFolders[0].uri}get keepResults(){return la.context.workspaceState.get(Y.ResultsExplorerKeepResults,!1)}close(){this.clearResults(),J(j.ResultsExplorer,!1)}async getChildren(e){return 0===this._roots.length?[new ai("No results")]:void 0===e?this._roots:e.getChildren()}async getTreeItem(e){return e.getTreeItem()}getQualifiedCommand(e){return`gitlens.resultsExplorer.${e}`}async refresh(e){void 0===e&&(e=qt.Command),ce.log("ResultsExplorer.refresh",`reason='${e}'`),this._onDidChangeTreeData.fire()}refreshNode(e,t){ce.log("ResultsExplorer.refreshNode"),void 0!==t&&e.supportsPaging&&(e.maxCount=t.maxCount),e.refresh(),this._onDidChangeTreeData.fire(this._roots.includes(e)?void 0:e)}refreshNodes(){ce.log("ResultsExplorer.refreshNodes"),this._roots.forEach(e=>e.refresh()),this._onDidChangeTreeData.fire()}showComparisonInResults(e,t,i){this.addResults(new Ti(e,"string"==typeof t?{ref:t}:t,"string"==typeof i?{ref:i}:i,this)),this.showResults()}showCommitInResults(e){this.addResults(new ki(e,this)),this.showResults()}showCommitsInResults(e,t){const i=void 0===e.query?t=>Promise.resolve(e):e.query;this.addResults(new Pi(e.repoPath,async i=>{if("string"==typeof t)return t;const s=void 0!==i?i.count:0,o=void 0!==i&&i.truncated,a=void 0===t.resultsType?{singular:"result",plural:"results"}:t.resultsType;let r="";if(await la.git.getRepositoryCount()>1){const t=await la.git.getRepository(e.repoPath);r=` ${w.pad(K.Dash,1,1)} ${t&&t.formattedName||e.repoPath}`}return 1===s?`1 ${a.singular} for ${t.label}${r}`:`${0===s?"No":`${s}${o?"+":""}`} ${a.plural} for ${t.label}${r}`},m.seeded(i,e),this,Yt.SearchResults)),this.showResults()}async showResults(){await N.commands.executeCommand("workbench.view.explorer"),Xi.showResultExplorerInfoMessage(),J(j.ResultsExplorer,!0)}addResults(e){return!this._roots.includes(e)&&(this._roots.length>0&&!this.keepResults&&this.clearResults(),this._roots.splice(0,0,e),this.refreshNode(e),!0)}clearResults(){0!==this._roots.length&&(this._roots.forEach(e=>e.dispose()),this._roots=[],this.refresh())}clearResultsNode(e){const t=this._roots.findIndex(t=>t===e);-1!==t&&(this._roots.splice(t,1),e.dispose(),this.refresh())}async setFilesLayout(e){return ua.update(ua.name("resultsExplorer")("files")("layout").value,e,N.ConfigurationTarget.Global)}setKeepResults(e){la.context.workspaceState.update(Y.ResultsExplorerKeepResults,e),J(j.ResultsExplorerKeepResults,e)}swapComparision(e){e instanceof Ti&&this.showComparisonInResults(e.repoPath,e.ref2,e.ref1)}}class la{static initialize(e,t){if(this._context=e,this._config=t,e.subscriptions.push(this._tracker=new ue),e.subscriptions.push(this._git=new ii),this._tracker.initialize(),e.subscriptions.push(this._annotationController=new Vo),e.subscriptions.push(this._currentLineController=new Zo),e.subscriptions.push(this._codeLensController=new zo),e.subscriptions.push(this._keyboard=new vs),e.subscriptions.push(this._pageProvider=new ha),t.gitExplorer.enabled)e.subscriptions.push(this._gitExplorer=new ea);else{let t;t=ua.onDidChange(i=>{ua.changed(i,ua.name("gitExplorer")("enabled").value)&&(t.dispose(),e.subscriptions.push(this._gitExplorer=new ea))})}e.subscriptions.push(N.workspace.registerTextDocumentContentProvider(ia.scheme,new ia)),e.subscriptions.push(N.languages.registerCodeLensProvider(aa.selector,new aa))}static get annotations(){return this._annotationController}static get codeLens(){return this._codeLensController}static get config(){return void 0===this._config&&(this._config=ua.get()),this._config}static get context(){return this._context}static get explorerCommands(){return void 0===this._explorerCommands&&this._context.subscriptions.push(this._explorerCommands=new ta),this._explorerCommands}static get git(){return this._git}static get gitExplorer(){return this._gitExplorer}static get keyboard(){return this._keyboard}static get lineAnnotations(){return this._currentLineController}static get pages(){return this._pageProvider}static get resultsExplorer(){return void 0===this._resultsExplorer&&this._context.subscriptions.push(this._resultsExplorer=new ca),this._resultsExplorer}static get tracker(){return this._tracker}static resetConfig(){this._config=void 0}}const da=new Proxy({},{get:(e,t,i)=>da});class ma{constructor(){this._onDidChange=new N.EventEmitter,this.initializingChangeEvent={affectsConfiguration:(e,t)=>!1}}static configure(e){e.subscriptions.push(N.workspace.onDidChangeConfiguration(ua.onConfigurationChanged,ua))}get onDidChange(){return this._onDidChange.event}onConfigurationChanged(e){if(!e.affectsConfiguration(U,null))return;la.resetConfig(),void 0!==la.pages&&la.pages.refresh(),ua.changed(e,ua.name("defaultGravatarsStyle").value)&&Ge.clear();const t=ua.name("keymap").value;ua.changed(e,t)&&J(j.KeyMap,this.get(t)),this._onDidChange.fire(e)}get(e,t,i){return void 0===i?N.workspace.getConfiguration(void 0===e?void 0:U,t).get(void 0===e?U:e):N.workspace.getConfiguration(void 0===e?void 0:U,t).get(void 0===e?U:e,i)}changed(e,t,i){return e.affectsConfiguration(`${U}.${t}`,i)}initializing(e){return e===this.initializingChangeEvent}inspect(e,t){return N.workspace.getConfiguration(void 0===e?void 0:U,t).inspect(void 0===e?U:e)}async migrate(e,t,i={}){const s=ua.inspect(e);if(void 0===s)return!1;let o=!1;return void 0!==s.globalValue&&(await this.update(t,i.migrationFn?i.migrationFn(s.globalValue):s.globalValue,N.ConfigurationTarget.Global),o=!0),void 0!==s.workspaceValue&&(await this.update(t,i.migrationFn?i.migrationFn(s.workspaceValue):s.workspaceValue,N.ConfigurationTarget.Workspace),o=!0),void 0!==s.workspaceFolderValue&&(await this.update(t,i.migrationFn?i.migrationFn(s.workspaceFolderValue):s.workspaceFolderValue,N.ConfigurationTarget.WorkspaceFolder),o=!0),o||void 0===i.fallbackValue||(await this.update(t,i.fallbackValue,N.ConfigurationTarget.Global),o=!0),o}async migrateIfMissing(e,t,i={}){const s=ua.inspect(e);if(void 0===s)return;const o=ua.inspect(t);void 0!==s.globalValue&&(void 0!==o&&void 0!==o.globalValue||await this.update(t,i.migrationFn?i.migrationFn(s.globalValue):s.globalValue,N.ConfigurationTarget.Global)),void 0!==s.workspaceValue&&(void 0!==o&&void 0!==o.workspaceValue||await this.update(t,i.migrationFn?i.migrationFn(s.workspaceValue):s.workspaceValue,N.ConfigurationTarget.Workspace)),void 0!==s.workspaceFolderValue&&(void 0!==o&&void 0!==o.workspaceFolderValue||await this.update(t,i.migrationFn?i.migrationFn(s.workspaceFolderValue):s.workspaceFolderValue,N.ConfigurationTarget.WorkspaceFolder))}name(e){return m.propOf(da,e)}update(e,t,i,s){return N.workspace.getConfiguration(U,i===N.ConfigurationTarget.Global?void 0:s).update(e,t,i)}async updateEffective(e,t,i=null){const s=await ua.inspect(e,i);void 0!==s.workspaceFolderValue?await ua.update(e,t,N.ConfigurationTarget.WorkspaceFolder,i):void 0!==s.workspaceValue?await ua.update(e,t,N.ConfigurationTarget.Workspace):await ua.update(e,t,N.ConfigurationTarget.Global)}}const ua=new ma;async function ga(e){const t=process.hrtime();ce.configure(e);const i=N.extensions.getExtension(I).packageJSON.version,s=N.workspace.getConfiguration("git",null).get("enabled",!0);if(!s)return ce.log(`GitLens(v${i}) was NOT activated -- "git.enabled": false`),void J(j.Enabled,s);ma.configure(e);const o=e.globalState.get(z.GitLensVersion);await async function(e,t){if(void 0===t)return;const i=C.fromString(t);try{if(1!==C.compare(i,C.from(7,5,10))&&(await ua.migrate("annotations.file.gutter.gravatars",ua.name("blame")("avatars").value),await ua.migrate("annotations.file.gutter.compact",ua.name("blame")("compact").value),await ua.migrate("annotations.file.gutter.dateFormat",ua.name("blame")("dateFormat").value),await ua.migrate("annotations.file.gutter.format",ua.name("blame")("format").value),await ua.migrate("annotations.file.gutter.heatmap.enabled",ua.name("blame")("heatmap")("enabled").value),await ua.migrate("annotations.file.gutter.heatmap.location",ua.name("blame")("heatmap")("location").value),await ua.migrate("annotations.file.gutter.lineHighlight.enabled",ua.name("blame")("highlight")("enabled").value),await ua.migrate("annotations.file.gutter.lineHighlight.locations",ua.name("blame")("highlight")("locations").value),await ua.migrate("annotations.file.gutter.separateLines",ua.name("blame")("separateLines").value),await ua.migrate("codeLens.locations",ua.name("codeLens")("scopes").value),await ua.migrate("codeLens.perLanguageLocations",ua.name("codeLens")("scopesByLanguage").value,{migrationFn:e=>{return e.map(e=>({language:e.language,scopes:e.locations,symbolScopes:e.customSymbols}))}}),await ua.migrate("codeLens.customLocationSymbols",ua.name("codeLens")("symbolScopes").value),await ua.migrate("annotations.line.trailing.dateFormat",ua.name("currentLine")("dateFormat").value),await ua.migrate("blame.line.enabled",ua.name("currentLine")("enabled").value),await ua.migrate("annotations.line.trailing.format",ua.name("currentLine")("format").value),await ua.migrate("annotations.file.gutter.hover.changes",ua.name("hovers")("annotations")("changes").value),await ua.migrate("annotations.file.gutter.hover.details",ua.name("hovers")("annotations")("details").value),await ua.migrate("annotations.file.gutter.hover.details",ua.name("hovers")("annotations")("enabled").value),await ua.migrate("annotations.file.gutter.hover.wholeLine",ua.name("hovers")("annotations")("over").value,{migrationFn:e=>e?"line":"annotation"}),await ua.migrate("annotations.line.trailing.hover.changes",ua.name("hovers")("currentLine")("changes").value),await ua.migrate("annotations.line.trailing.hover.details",ua.name("hovers")("currentLine")("details").value),await ua.migrate("blame.line.enabled",ua.name("hovers")("currentLine")("enabled").value),await ua.migrate("annotations.line.trailing.hover.wholeLine",ua.name("hovers")("currentLine")("over").value,{migrationFn:e=>e?"line":"annotation"}),await ua.migrate("gitExplorer.gravatars",ua.name("explorers")("avatars").value),await ua.migrate("gitExplorer.commitFileFormat",ua.name("explorers")("commitFileFormat").value),await ua.migrate("gitExplorer.commitFormat",ua.name("explorers")("commitFormat").value),await ua.migrate("gitExplorer.stashFileFormat",ua.name("explorers")("stashFileFormat").value),await ua.migrate("gitExplorer.stashFormat",ua.name("explorers")("stashFormat").value),await ua.migrate("gitExplorer.statusFileFormat",ua.name("explorers")("statusFileFormat").value),await ua.migrate("recentChanges.file.lineHighlight.locations",ua.name("recentChanges")("highlight")("locations").value)),1!==C.compare(i,C.from(8,0,0,"beta2"))&&(await ua.migrate("debug",ua.name("outputLevel").value,{migrationFn:e=>e?B.Debug:ua.get(ua.name("outputLevel").value)}),await ua.migrate("debug",ua.name("debug").value,{migrationFn:e=>void 0})),1!==C.compare(i,C.from(8,0,0,"rc"))){let e=ua.name("blame")("highlight")("locations").value;await ua.migrate(e,e,{migrationFn:e=>{const t=e.indexOf("overviewRuler");return-1!==t&&e.splice(t,1,"overview"),e}}),e=ua.name("recentChanges")("highlight")("locations").value,await ua.migrate(e,e,{migrationFn:e=>{const t=e.indexOf("overviewRuler");return-1!==t&&e.splice(t,1,"overview"),e}})}if(1!==C.compare(i,C.from(8,0,0))&&(await ua.migrateIfMissing("annotations.file.gutter.gravatars",ua.name("blame")("avatars").value),await ua.migrateIfMissing("annotations.file.gutter.compact",ua.name("blame")("compact").value),await ua.migrateIfMissing("annotations.file.gutter.dateFormat",ua.name("blame")("dateFormat").value),await ua.migrateIfMissing("annotations.file.gutter.format",ua.name("blame")("format").value),await ua.migrateIfMissing("annotations.file.gutter.heatmap.enabled",ua.name("blame")("heatmap")("enabled").value),await ua.migrateIfMissing("annotations.file.gutter.heatmap.location",ua.name("blame")("heatmap")("location").value),await ua.migrateIfMissing("annotations.file.gutter.lineHighlight.enabled",ua.name("blame")("highlight")("enabled").value),await ua.migrateIfMissing("annotations.file.gutter.lineHighlight.locations",ua.name("blame")("highlight")("locations").value),await ua.migrateIfMissing("annotations.file.gutter.separateLines",ua.name("blame")("separateLines").value),await ua.migrateIfMissing("codeLens.locations",ua.name("codeLens")("scopes").value),await ua.migrateIfMissing("codeLens.perLanguageLocations",ua.name("codeLens")("scopesByLanguage").value,{migrationFn:e=>{return e.map(e=>({language:e.language,scopes:e.locations,symbolScopes:e.customSymbols}))}}),await ua.migrateIfMissing("codeLens.customLocationSymbols",ua.name("codeLens")("symbolScopes").value),await ua.migrateIfMissing("annotations.line.trailing.dateFormat",ua.name("currentLine")("dateFormat").value),await ua.migrateIfMissing("blame.line.enabled",ua.name("currentLine")("enabled").value),await ua.migrateIfMissing("annotations.line.trailing.format",ua.name("currentLine")("format").value),await ua.migrateIfMissing("annotations.file.gutter.hover.changes",ua.name("hovers")("annotations")("changes").value),await ua.migrateIfMissing("annotations.file.gutter.hover.details",ua.name("hovers")("annotations")("details").value),await ua.migrateIfMissing("annotations.file.gutter.hover.details",ua.name("hovers")("annotations")("enabled").value),await ua.migrateIfMissing("annotations.file.gutter.hover.wholeLine",ua.name("hovers")("annotations")("over").value,{migrationFn:e=>e?"line":"annotation"}),await ua.migrateIfMissing("annotations.line.trailing.hover.changes",ua.name("hovers")("currentLine")("changes").value),await ua.migrateIfMissing("annotations.line.trailing.hover.details",ua.name("hovers")("currentLine")("details").value),await ua.migrateIfMissing("blame.line.enabled",ua.name("hovers")("currentLine")("enabled").value),await ua.migrateIfMissing("annotations.line.trailing.hover.wholeLine",ua.name("hovers")("currentLine")("over").value,{migrationFn:e=>e?"line":"annotation"}),await ua.migrateIfMissing("gitExplorer.gravatars",ua.name("explorers")("avatars").value),await ua.migrateIfMissing("gitExplorer.commitFileFormat",ua.name("explorers")("commitFileFormat").value),await ua.migrateIfMissing("gitExplorer.commitFormat",ua.name("explorers")("commitFormat").value),await ua.migrateIfMissing("gitExplorer.stashFileFormat",ua.name("explorers")("stashFileFormat").value),await ua.migrateIfMissing("gitExplorer.stashFormat",ua.name("explorers")("stashFormat").value),await ua.migrateIfMissing("gitExplorer.statusFileFormat",ua.name("explorers")("statusFileFormat").value),await ua.migrateIfMissing("recentChanges.file.lineHighlight.locations",ua.name("recentChanges")("highlight")("locations").value)),1!==C.compare(i,C.from(8,0,2))){const e=ua.name("keymap").value;await ua.migrate(e,e,{fallbackValue:E.Alternate,migrationFn:e=>"standard"===e?E.Alternate:e})}}catch(e){ce.error(e,"migrateSettings")}}(0,o);const a=ua.get();try{await ii.initialize(a.advanced.git||N.workspace.getConfiguration("git").get("path"))}catch(e){return ce.error(e,`GitLens(v${i}).activate`),e.message.includes("Unable to find git")&&await N.window.showErrorMessage(`GitLens was unable to find Git. Please make sure Git is installed. Also ensure that Git is either in the PATH, or that '${U}.${ua.name("advanced")("git").value}' is pointed to its installed location.`),void J(j.Enabled,!1)}la.initialize(e,a),J(j.KeyMap,la.config.keymap),la.context.subscriptions.push(new Ji),la.context.subscriptions.push(new oo),la.context.subscriptions.push(new so),la.context.subscriptions.push(new Zi),la.context.subscriptions.push(new es),la.context.subscriptions.push(new Hs),la.context.subscriptions.push(new js),la.context.subscriptions.push(new Gs),la.context.subscriptions.push(new Vs),la.context.subscriptions.push(new Qs),la.context.subscriptions.push(new Ks),la.context.subscriptions.push(new qs),la.context.subscriptions.push(new zs),la.context.subscriptions.push(new Ys),la.context.subscriptions.push(new Xs),la.context.subscriptions.push(new ao),la.context.subscriptions.push(new ro),la.context.subscriptions.push(new no),la.context.subscriptions.push(new ho),la.context.subscriptions.push(new co),la.context.subscriptions.push(new lo),la.context.subscriptions.push(new mo),la.context.subscriptions.push(new uo),la.context.subscriptions.push(new Ki),la.context.subscriptions.push(new wo),la.context.subscriptions.push(new bo),la.context.subscriptions.push(new Eo),la.context.subscriptions.push(new Bo),la.context.subscriptions.push(new Ao),la.context.subscriptions.push(new No),la.context.subscriptions.push(new go),la.context.subscriptions.push(new Co),la.context.subscriptions.push(new yo),la.context.subscriptions.push(new $o),la.context.subscriptions.push(new xo),la.context.subscriptions.push(new So),la.context.subscriptions.push(new vo),la.context.subscriptions.push(new Do),la.context.subscriptions.push(new Fo),la.context.subscriptions.push(new ko),la.context.subscriptions.push(new Po),la.context.subscriptions.push(new _o),la.context.subscriptions.push(new Ro),la.context.subscriptions.push(new To),function(e){ii.validateGitVersion(2,2)||Xi.showUnsupportedGitVersionErrorMessage(e)}(ii.getGitVersion()),async function(e,t){if(void 0===t)return ce.log("GitLens first-time install"),void(la.config.showWhatsNewAfterUpgrades&&await N.commands.executeCommand(ei.ShowWelcomePage));if(t!==e&&(ce.log(`GitLens upgraded from v${t} to v${e}`),0===C.compare(C.fromString(t),C.from(8,0,0))))return void await N.commands.executeCommand(ei.ShowWelcomePage);if(!la.config.showWhatsNewAfterUpgrades)return;const[i,s]=e.split("."),[o,a]=t.split(".");i===o&&s===a||i<o||i===o&&s<a||await N.commands.executeCommand(ei.ShowWelcomePage)}(i,o),e.globalState.update(z.GitLensVersion,i);const r=process.hrtime(t);ce.log(`GitLens(v${i}) activated in ${1e3*r[0]+Math.floor(r[1]/1e6)} ms`)}function pa(){}i.d(t,"activate",function(){return ga}),i.d(t,"deactivate",function(){return pa})},function(e,t){e.exports=require("lodash.once")},function(e,t){e.exports=require("lodash.debounce")},function(e,t){e.exports=require("copy-paste")},function(e,t){e.exports=require("tmp")}]);